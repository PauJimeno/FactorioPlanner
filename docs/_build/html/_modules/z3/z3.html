
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>z3.z3 &#8212; model 4/9/2024 documentation</title>
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/alabaster.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/graphviz.css" />
    <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="../../_static/doctools.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <h1>Source code for z3.z3</h1><div class="highlight"><pre>
<span></span><span class="c1">############################################</span>
<span class="c1"># Copyright (c) 2012 Microsoft Corporation</span>
<span class="c1">#</span>
<span class="c1"># Z3 Python interface</span>
<span class="c1">#</span>
<span class="c1"># Author: Leonardo de Moura (leonardo)</span>
<span class="c1">############################################</span>

<span class="sd">&quot;&quot;&quot;Z3 is a high performance theorem prover developed at Microsoft Research.</span>

<span class="sd">Z3 is used in many applications such as: software/hardware verification and testing,</span>
<span class="sd">constraint solving, analysis of hybrid systems, security, biology (in silico analysis),</span>
<span class="sd">and geometrical problems.</span>


<span class="sd">Please send feedback, comments and/or corrections on the Issue tracker for</span>
<span class="sd">https://github.com/Z3prover/z3.git. Your comments are very valuable.</span>

<span class="sd">Small example:</span>

<span class="sd">&gt;&gt;&gt; x = Int(&#39;x&#39;)</span>
<span class="sd">&gt;&gt;&gt; y = Int(&#39;y&#39;)</span>
<span class="sd">&gt;&gt;&gt; s = Solver()</span>
<span class="sd">&gt;&gt;&gt; s.add(x &gt; 0)</span>
<span class="sd">&gt;&gt;&gt; s.add(x &lt; 2)</span>
<span class="sd">&gt;&gt;&gt; s.add(y == x + 1)</span>
<span class="sd">&gt;&gt;&gt; s.check()</span>
<span class="sd">sat</span>
<span class="sd">&gt;&gt;&gt; m = s.model()</span>
<span class="sd">&gt;&gt;&gt; m[x]</span>
<span class="sd">1</span>
<span class="sd">&gt;&gt;&gt; m[y]</span>
<span class="sd">2</span>

<span class="sd">Z3 exceptions:</span>

<span class="sd">&gt;&gt;&gt; try:</span>
<span class="sd">...   x = BitVec(&#39;x&#39;, 32)</span>
<span class="sd">...   y = Bool(&#39;y&#39;)</span>
<span class="sd">...   # the expression x + y is type incorrect</span>
<span class="sd">...   n = x + y</span>
<span class="sd">... except Z3Exception as ex:</span>
<span class="sd">...   print(&quot;failed: %s&quot; % ex)</span>
<span class="sd">failed: sort mismatch</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">z3core</span>
<span class="kn">from</span> <span class="nn">.z3core</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">.z3types</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">.z3consts</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">.z3printer</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">fractions</span> <span class="kn">import</span> <span class="n">Fraction</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">io</span>
<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">import</span> <span class="nn">copy</span>
<span class="k">if</span> <span class="n">sys</span><span class="o">.</span><span class="n">version_info</span><span class="o">.</span><span class="n">major</span> <span class="o">&gt;=</span> <span class="mi">3</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Iterable</span>

<span class="n">Z3_DEBUG</span> <span class="o">=</span> <span class="n">__debug__</span>


<span class="k">def</span> <span class="nf">z3_debug</span><span class="p">():</span>
    <span class="k">global</span> <span class="n">Z3_DEBUG</span>
    <span class="k">return</span> <span class="n">Z3_DEBUG</span>


<span class="k">if</span> <span class="n">sys</span><span class="o">.</span><span class="n">version_info</span><span class="o">.</span><span class="n">major</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">_is_int</span><span class="p">(</span><span class="n">v</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">long</span><span class="p">))</span>
<span class="k">else</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">_is_int</span><span class="p">(</span><span class="n">v</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">enable_trace</span><span class="p">(</span><span class="n">msg</span><span class="p">):</span>
    <span class="n">Z3_enable_trace</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">disable_trace</span><span class="p">(</span><span class="n">msg</span><span class="p">):</span>
    <span class="n">Z3_disable_trace</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">get_version_string</span><span class="p">():</span>
    <span class="n">major</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_uint</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">minor</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_uint</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">build</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_uint</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">rev</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_uint</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">Z3_get_version</span><span class="p">(</span><span class="n">major</span><span class="p">,</span> <span class="n">minor</span><span class="p">,</span> <span class="n">build</span><span class="p">,</span> <span class="n">rev</span><span class="p">)</span>
    <span class="k">return</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2">.</span><span class="si">%s</span><span class="s2">.</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">major</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">minor</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">build</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">get_version</span><span class="p">():</span>
    <span class="n">major</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_uint</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">minor</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_uint</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">build</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_uint</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">rev</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_uint</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">Z3_get_version</span><span class="p">(</span><span class="n">major</span><span class="p">,</span> <span class="n">minor</span><span class="p">,</span> <span class="n">build</span><span class="p">,</span> <span class="n">rev</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">major</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">minor</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">build</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">rev</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">get_full_version</span><span class="p">():</span>
    <span class="k">return</span> <span class="n">Z3_get_full_version</span><span class="p">()</span>


<span class="k">def</span> <span class="nf">_z3_assert</span><span class="p">(</span><span class="n">cond</span><span class="p">,</span> <span class="n">msg</span><span class="p">):</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">cond</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">Z3Exception</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_z3_check_cint_overflow</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
    <span class="n">_z3_assert</span><span class="p">(</span><span class="n">ctypes</span><span class="o">.</span><span class="n">c_int</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="n">n</span><span class="p">,</span> <span class="n">name</span> <span class="o">+</span> <span class="s2">&quot; is too large&quot;</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">open_log</span><span class="p">(</span><span class="n">fname</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Log interaction to a file. This function must be invoked immediately after init(). &quot;&quot;&quot;</span>
    <span class="n">Z3_open_log</span><span class="p">(</span><span class="n">fname</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">append_log</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Append user-defined string to interaction log. &quot;&quot;&quot;</span>
    <span class="n">Z3_append_log</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">to_symbol</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">ctx</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Convert an integer or string into a Z3 symbol.&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">_is_int</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Z3_mk_int_symbol</span><span class="p">(</span><span class="n">_get_ctx</span><span class="p">(</span><span class="n">ctx</span><span class="p">)</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="n">s</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">Z3_mk_string_symbol</span><span class="p">(</span><span class="n">_get_ctx</span><span class="p">(</span><span class="n">ctx</span><span class="p">)</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="n">s</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_symbol2py</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">s</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Convert a Z3 symbol back into a Python object. &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">Z3_get_symbol_kind</span><span class="p">(</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="n">s</span><span class="p">)</span> <span class="o">==</span> <span class="n">Z3_INT_SYMBOL</span><span class="p">:</span>
        <span class="k">return</span> <span class="s2">&quot;k!</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">Z3_get_symbol_int</span><span class="p">(</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="n">s</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">Z3_get_symbol_string</span><span class="p">(</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="n">s</span><span class="p">)</span>

<span class="c1"># Hack for having nary functions that can receive one argument that is the</span>
<span class="c1"># list of arguments.</span>
<span class="c1"># Use this when function takes a single list of arguments</span>


<span class="k">def</span> <span class="nf">_get_args</span><span class="p">(</span><span class="n">args</span><span class="p">):</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">tuple</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">list</span><span class="p">)):</span>
            <span class="k">return</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">set</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">AstVector</span><span class="p">)):</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">arg</span> <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">args</span>
    <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>  <span class="c1"># len is not necessarily defined when args is not a sequence (use reflection?)</span>
        <span class="k">return</span> <span class="n">args</span>

<span class="c1"># Use this when function takes multiple arguments</span>


<span class="k">def</span> <span class="nf">_get_args_ast_list</span><span class="p">(</span><span class="n">args</span><span class="p">):</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="p">(</span><span class="nb">set</span><span class="p">,</span> <span class="n">AstVector</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">arg</span> <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">args</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">args</span>
    <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">args</span>


<span class="k">def</span> <span class="nf">_to_param_value</span><span class="p">(</span><span class="n">val</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;true&quot;</span> <span class="k">if</span> <span class="n">val</span> <span class="k">else</span> <span class="s2">&quot;false&quot;</span>
    <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">z3_error_handler</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">e</span><span class="p">):</span>
    <span class="c1"># Do nothing error handler, just avoid exit(0)</span>
    <span class="c1"># The wrappers in z3core.py will raise a Z3Exception if an error is detected</span>
    <span class="k">return</span>


<span class="k">class</span> <span class="nc">Context</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;A Context manages all other Z3 objects, global configuration options, etc.</span>

<span class="sd">    Z3Py uses a default global context. For most applications this is sufficient.</span>
<span class="sd">    An application may use multiple Z3 contexts. Objects created in one context</span>
<span class="sd">    cannot be used in another one. However, several objects may be &quot;translated&quot; from</span>
<span class="sd">    one context to another. It is not safe to access Z3 objects from multiple threads.</span>
<span class="sd">    The only exception is the method `interrupt()` that can be used to interrupt() a long</span>
<span class="sd">    computation.</span>
<span class="sd">    The initialization method receives global configuration options for the new context.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kws</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">z3_debug</span><span class="p">():</span>
            <span class="n">_z3_assert</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;Argument list must have an even number of elements.&quot;</span><span class="p">)</span>
        <span class="n">conf</span> <span class="o">=</span> <span class="n">Z3_mk_config</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">kws</span><span class="p">:</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">kws</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
            <span class="n">Z3_set_param_value</span><span class="p">(</span><span class="n">conf</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">key</span><span class="p">)</span><span class="o">.</span><span class="n">upper</span><span class="p">(),</span> <span class="n">_to_param_value</span><span class="p">(</span><span class="n">value</span><span class="p">))</span>
        <span class="n">prev</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">args</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">prev</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">prev</span> <span class="o">=</span> <span class="n">a</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">Z3_set_param_value</span><span class="p">(</span><span class="n">conf</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">prev</span><span class="p">),</span> <span class="n">_to_param_value</span><span class="p">(</span><span class="n">a</span><span class="p">))</span>
                <span class="n">prev</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span> <span class="o">=</span> <span class="n">Z3_mk_context_rc</span><span class="p">(</span><span class="n">conf</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">owner</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">eh</span> <span class="o">=</span> <span class="n">Z3_set_error_handler</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">,</span> <span class="n">z3_error_handler</span><span class="p">)</span>
        <span class="n">Z3_set_ast_print_mode</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">,</span> <span class="n">Z3_PRINT_SMTLIB2_COMPLIANT</span><span class="p">)</span>
        <span class="n">Z3_del_config</span><span class="p">(</span><span class="n">conf</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__del__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">Z3_del_context</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">owner</span><span class="p">:</span>
            <span class="n">Z3_del_context</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">eh</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">ref</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a reference to the actual C pointer to the Z3 context.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span>

    <span class="k">def</span> <span class="nf">interrupt</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Interrupt a solver performing a satisfiability test, a tactic processing a goal, or simplify functions.</span>

<span class="sd">        This method can be invoked from a thread different from the one executing the</span>
<span class="sd">        interruptible procedure.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">Z3_interrupt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ref</span><span class="p">())</span>

    <span class="k">def</span> <span class="nf">param_descrs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the global parameter description set.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">ParamDescrsRef</span><span class="p">(</span><span class="n">Z3_get_global_param_descrs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ref</span><span class="p">()),</span> <span class="bp">self</span><span class="p">)</span>
        

<span class="c1"># Global Z3 context</span>
<span class="n">_main_ctx</span> <span class="o">=</span> <span class="kc">None</span>


<span class="k">def</span> <span class="nf">main_ctx</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return a reference to the global Z3 context.</span>

<span class="sd">    &gt;&gt;&gt; x = Real(&#39;x&#39;)</span>
<span class="sd">    &gt;&gt;&gt; x.ctx == main_ctx()</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; c = Context()</span>
<span class="sd">    &gt;&gt;&gt; c == main_ctx()</span>
<span class="sd">    False</span>
<span class="sd">    &gt;&gt;&gt; x2 = Real(&#39;x&#39;, c)</span>
<span class="sd">    &gt;&gt;&gt; x2.ctx == c</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; eq(x, x2)</span>
<span class="sd">    False</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">global</span> <span class="n">_main_ctx</span>
    <span class="k">if</span> <span class="n">_main_ctx</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">_main_ctx</span> <span class="o">=</span> <span class="n">Context</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">_main_ctx</span>


<span class="k">def</span> <span class="nf">_get_ctx</span><span class="p">(</span><span class="n">ctx</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">ctx</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">main_ctx</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">ctx</span>


<span class="k">def</span> <span class="nf">get_ctx</span><span class="p">(</span><span class="n">ctx</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">_get_ctx</span><span class="p">(</span><span class="n">ctx</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">set_param</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kws</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Set Z3 global (or module) parameters.</span>

<span class="sd">    &gt;&gt;&gt; set_param(precision=10)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">z3_debug</span><span class="p">():</span>
        <span class="n">_z3_assert</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;Argument list must have an even number of elements.&quot;</span><span class="p">)</span>
    <span class="n">new_kws</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">kws</span><span class="p">:</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">kws</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">set_pp_option</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
            <span class="n">new_kws</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>
    <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">new_kws</span><span class="p">:</span>
        <span class="n">value</span> <span class="o">=</span> <span class="n">new_kws</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
        <span class="n">Z3_global_param_set</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">key</span><span class="p">)</span><span class="o">.</span><span class="n">upper</span><span class="p">(),</span> <span class="n">_to_param_value</span><span class="p">(</span><span class="n">value</span><span class="p">))</span>
    <span class="n">prev</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">args</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">prev</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">prev</span> <span class="o">=</span> <span class="n">a</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">Z3_global_param_set</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">prev</span><span class="p">),</span> <span class="n">_to_param_value</span><span class="p">(</span><span class="n">a</span><span class="p">))</span>
            <span class="n">prev</span> <span class="o">=</span> <span class="kc">None</span>


<span class="k">def</span> <span class="nf">reset_params</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Reset all global (or module) parameters.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">Z3_global_param_reset_all</span><span class="p">()</span>


<span class="k">def</span> <span class="nf">set_option</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kws</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Alias for &#39;set_param&#39; for backward compatibility.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">set_param</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kws</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">get_param</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return the value of a Z3 global (or module) parameter</span>

<span class="sd">    &gt;&gt;&gt; get_param(&#39;nlsat.reorder&#39;)</span>
<span class="sd">    &#39;true&#39;</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ptr</span> <span class="o">=</span> <span class="p">(</span><span class="n">ctypes</span><span class="o">.</span><span class="n">c_char_p</span> <span class="o">*</span> <span class="mi">1</span><span class="p">)()</span>
    <span class="k">if</span> <span class="n">Z3_global_param_get</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">name</span><span class="p">),</span> <span class="n">ptr</span><span class="p">):</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">z3core</span><span class="o">.</span><span class="n">_to_pystr</span><span class="p">(</span><span class="n">ptr</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">r</span>
    <span class="k">raise</span> <span class="n">Z3Exception</span><span class="p">(</span><span class="s2">&quot;failed to retrieve value for &#39;</span><span class="si">%s</span><span class="s2">&#39;&quot;</span> <span class="o">%</span> <span class="n">name</span><span class="p">)</span>

<span class="c1">#########################################</span>
<span class="c1">#</span>
<span class="c1"># ASTs base class</span>
<span class="c1">#</span>
<span class="c1">#########################################</span>

<span class="c1"># Mark objects that use pretty printer</span>


<span class="k">class</span> <span class="nc">Z3PPObject</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Superclass for all Z3 objects that have support for pretty printing.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">use_pp</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">_repr_html_</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">in_html</span> <span class="o">=</span> <span class="n">in_html_mode</span><span class="p">()</span>
        <span class="n">set_html_mode</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">res</span> <span class="o">=</span> <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">set_html_mode</span><span class="p">(</span><span class="n">in_html</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">res</span>


<span class="k">class</span> <span class="nc">AstRef</span><span class="p">(</span><span class="n">Z3PPObject</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;AST are Direct Acyclic Graphs (DAGs) used to represent sorts, declarations and expressions.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ast</span><span class="p">,</span> <span class="n">ctx</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ast</span> <span class="o">=</span> <span class="n">ast</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span> <span class="o">=</span> <span class="n">_get_ctx</span><span class="p">(</span><span class="n">ctx</span><span class="p">)</span>
        <span class="n">Z3_inc_ref</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_ast</span><span class="p">())</span>

    <span class="k">def</span> <span class="fm">__del__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">()</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">ast</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">Z3_dec_ref</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">Z3_dec_ref</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_ast</span><span class="p">())</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ast</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">__deepcopy__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">memo</span><span class="o">=</span><span class="p">{}):</span>
        <span class="k">return</span> <span class="n">_to_ast_ref</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ast</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">obj_to_string</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">obj_to_string</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">eq</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">hash</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">__nonzero__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__bool__</span><span class="p">()</span>

    <span class="k">def</span> <span class="fm">__bool__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">is_true</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">elif</span> <span class="n">is_false</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">elif</span> <span class="n">is_eq</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_args</span><span class="p">()</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">arg</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">eq</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">arg</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">Z3Exception</span><span class="p">(</span><span class="s2">&quot;Symbolic expressions cannot be cast to concrete Boolean values.&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">sexpr</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a string representing the AST node in s-expression notation.</span>

<span class="sd">        &gt;&gt;&gt; x = Int(&#39;x&#39;)</span>
<span class="sd">        &gt;&gt;&gt; ((x + 1)*x).sexpr()</span>
<span class="sd">        &#39;(* (+ x 1) x)&#39;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Z3_ast_to_string</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx_ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_ast</span><span class="p">())</span>

    <span class="k">def</span> <span class="nf">as_ast</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a pointer to the corresponding C Z3_ast object.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ast</span>

    <span class="k">def</span> <span class="nf">get_id</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return unique identifier for object. It can be used for hash-tables and maps.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Z3_get_ast_id</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx_ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_ast</span><span class="p">())</span>

    <span class="k">def</span> <span class="nf">ctx_ref</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a reference to the C context where this AST node is stored.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">eq</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return `True` if `self` and `other` are structurally identical.</span>

<span class="sd">        &gt;&gt;&gt; x = Int(&#39;x&#39;)</span>
<span class="sd">        &gt;&gt;&gt; n1 = x + 1</span>
<span class="sd">        &gt;&gt;&gt; n2 = 1 + x</span>
<span class="sd">        &gt;&gt;&gt; n1.eq(n2)</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; n1 = simplify(n1)</span>
<span class="sd">        &gt;&gt;&gt; n2 = simplify(n2)</span>
<span class="sd">        &gt;&gt;&gt; n1.eq(n2)</span>
<span class="sd">        True</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">z3_debug</span><span class="p">():</span>
            <span class="n">_z3_assert</span><span class="p">(</span><span class="n">is_ast</span><span class="p">(</span><span class="n">other</span><span class="p">),</span> <span class="s2">&quot;Z3 AST expected&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Z3_is_eq_ast</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx_ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_ast</span><span class="p">(),</span> <span class="n">other</span><span class="o">.</span><span class="n">as_ast</span><span class="p">())</span>

    <span class="k">def</span> <span class="nf">translate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Translate `self` to the context `target`. That is, return a copy of `self` in the context `target`.</span>

<span class="sd">        &gt;&gt;&gt; c1 = Context()</span>
<span class="sd">        &gt;&gt;&gt; c2 = Context()</span>
<span class="sd">        &gt;&gt;&gt; x  = Int(&#39;x&#39;, c1)</span>
<span class="sd">        &gt;&gt;&gt; y  = Int(&#39;y&#39;, c2)</span>
<span class="sd">        &gt;&gt;&gt; # Nodes in different contexts can&#39;t be mixed.</span>
<span class="sd">        &gt;&gt;&gt; # However, we can translate nodes from one context to another.</span>
<span class="sd">        &gt;&gt;&gt; x.translate(c2) + y</span>
<span class="sd">        x + y</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">z3_debug</span><span class="p">():</span>
            <span class="n">_z3_assert</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">Context</span><span class="p">),</span> <span class="s2">&quot;argument must be a Z3 context&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">_to_ast_ref</span><span class="p">(</span><span class="n">Z3_translate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_ast</span><span class="p">(),</span> <span class="n">target</span><span class="o">.</span><span class="n">ref</span><span class="p">()),</span> <span class="n">target</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__copy__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">translate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">hash</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a hashcode for the `self`.</span>

<span class="sd">        &gt;&gt;&gt; n1 = simplify(Int(&#39;x&#39;) + 1)</span>
<span class="sd">        &gt;&gt;&gt; n2 = simplify(2 + Int(&#39;x&#39;) - 1)</span>
<span class="sd">        &gt;&gt;&gt; n1.hash() == n2.hash()</span>
<span class="sd">        True</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Z3_get_ast_hash</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx_ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_ast</span><span class="p">())</span>


<span class="k">def</span> <span class="nf">is_ast</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return `True` if `a` is an AST node.</span>

<span class="sd">    &gt;&gt;&gt; is_ast(10)</span>
<span class="sd">    False</span>
<span class="sd">    &gt;&gt;&gt; is_ast(IntVal(10))</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; is_ast(Int(&#39;x&#39;))</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; is_ast(BoolSort())</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; is_ast(Function(&#39;f&#39;, IntSort(), IntSort()))</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; is_ast(&quot;x&quot;)</span>
<span class="sd">    False</span>
<span class="sd">    &gt;&gt;&gt; is_ast(Solver())</span>
<span class="sd">    False</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">AstRef</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">eq</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return `True` if `a` and `b` are structurally identical AST nodes.</span>

<span class="sd">    &gt;&gt;&gt; x = Int(&#39;x&#39;)</span>
<span class="sd">    &gt;&gt;&gt; y = Int(&#39;y&#39;)</span>
<span class="sd">    &gt;&gt;&gt; eq(x, y)</span>
<span class="sd">    False</span>
<span class="sd">    &gt;&gt;&gt; eq(x + 1, x + 1)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; eq(x + 1, 1 + x)</span>
<span class="sd">    False</span>
<span class="sd">    &gt;&gt;&gt; eq(simplify(x + 1), simplify(1 + x))</span>
<span class="sd">    True</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">z3_debug</span><span class="p">():</span>
        <span class="n">_z3_assert</span><span class="p">(</span><span class="n">is_ast</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="ow">and</span> <span class="n">is_ast</span><span class="p">(</span><span class="n">b</span><span class="p">),</span> <span class="s2">&quot;Z3 ASTs expected&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">a</span><span class="o">.</span><span class="n">eq</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_ast_kind</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">a</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">is_ast</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">as_ast</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">Z3_get_ast_kind</span><span class="p">(</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="n">a</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_ctx_from_ast_arg_list</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">default_ctx</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="n">ctx</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">args</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">is_ast</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="ow">or</span> <span class="n">is_probe</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">ctx</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">ctx</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">ctx</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">z3_debug</span><span class="p">():</span>
                    <span class="n">_z3_assert</span><span class="p">(</span><span class="n">ctx</span> <span class="o">==</span> <span class="n">a</span><span class="o">.</span><span class="n">ctx</span><span class="p">,</span> <span class="s2">&quot;Context mismatch&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">ctx</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">ctx</span> <span class="o">=</span> <span class="n">default_ctx</span>
    <span class="k">return</span> <span class="n">ctx</span>


<span class="k">def</span> <span class="nf">_ctx_from_ast_args</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">_ctx_from_ast_arg_list</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_to_func_decl_array</span><span class="p">(</span><span class="n">args</span><span class="p">):</span>
    <span class="n">sz</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
    <span class="n">_args</span> <span class="o">=</span> <span class="p">(</span><span class="n">FuncDecl</span> <span class="o">*</span> <span class="n">sz</span><span class="p">)()</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">sz</span><span class="p">):</span>
        <span class="n">_args</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">as_func_decl</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">_args</span><span class="p">,</span> <span class="n">sz</span>


<span class="k">def</span> <span class="nf">_to_ast_array</span><span class="p">(</span><span class="n">args</span><span class="p">):</span>
    <span class="n">sz</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
    <span class="n">_args</span> <span class="o">=</span> <span class="p">(</span><span class="n">Ast</span> <span class="o">*</span> <span class="n">sz</span><span class="p">)()</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">sz</span><span class="p">):</span>
        <span class="n">_args</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">as_ast</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">_args</span><span class="p">,</span> <span class="n">sz</span>


<span class="k">def</span> <span class="nf">_to_ref_array</span><span class="p">(</span><span class="n">ref</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
    <span class="n">sz</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
    <span class="n">_args</span> <span class="o">=</span> <span class="p">(</span><span class="n">ref</span> <span class="o">*</span> <span class="n">sz</span><span class="p">)()</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">sz</span><span class="p">):</span>
        <span class="n">_args</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">as_ast</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">_args</span><span class="p">,</span> <span class="n">sz</span>


<span class="k">def</span> <span class="nf">_to_ast_ref</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">ctx</span><span class="p">):</span>
    <span class="n">k</span> <span class="o">=</span> <span class="n">_ast_kind</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="n">Z3_SORT_AST</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_to_sort_ref</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">ctx</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">k</span> <span class="o">==</span> <span class="n">Z3_FUNC_DECL_AST</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_to_func_decl_ref</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">ctx</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_to_expr_ref</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">ctx</span><span class="p">)</span>


<span class="c1">#########################################</span>
<span class="c1">#</span>
<span class="c1"># Sorts</span>
<span class="c1">#</span>
<span class="c1">#########################################</span>

<span class="k">def</span> <span class="nf">_sort_kind</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">s</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">Z3_get_sort_kind</span><span class="p">(</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="n">s</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">SortRef</span><span class="p">(</span><span class="n">AstRef</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;A Sort is essentially a type. Every Z3 expression has a sort. A sort is an AST node.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">as_ast</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Z3_sort_to_ast</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx_ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">ast</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_id</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Z3_get_ast_id</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx_ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_ast</span><span class="p">())</span>

    <span class="k">def</span> <span class="nf">kind</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the Z3 internal kind of a sort.</span>
<span class="sd">        This method can be used to test if `self` is one of the Z3 builtin sorts.</span>

<span class="sd">        &gt;&gt;&gt; b = BoolSort()</span>
<span class="sd">        &gt;&gt;&gt; b.kind() == Z3_BOOL_SORT</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; b.kind() == Z3_INT_SORT</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; A = ArraySort(IntSort(), IntSort())</span>
<span class="sd">        &gt;&gt;&gt; A.kind() == Z3_ARRAY_SORT</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; A.kind() == Z3_INT_SORT</span>
<span class="sd">        False</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_sort_kind</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ast</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">subsort</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return `True` if `self` is a subsort of `other`.</span>

<span class="sd">        &gt;&gt;&gt; IntSort().subsort(RealSort())</span>
<span class="sd">        True</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">cast</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Try to cast `val` as an element of sort `self`.</span>

<span class="sd">        This method is used in Z3Py to convert Python objects such as integers,</span>
<span class="sd">        floats, longs and strings into Z3 expressions.</span>

<span class="sd">        &gt;&gt;&gt; x = Int(&#39;x&#39;)</span>
<span class="sd">        &gt;&gt;&gt; RealSort().cast(x)</span>
<span class="sd">        ToReal(x)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">z3_debug</span><span class="p">():</span>
            <span class="n">_z3_assert</span><span class="p">(</span><span class="n">is_expr</span><span class="p">(</span><span class="n">val</span><span class="p">),</span> <span class="s2">&quot;Z3 expression expected&quot;</span><span class="p">)</span>
            <span class="n">_z3_assert</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">eq</span><span class="p">(</span><span class="n">val</span><span class="o">.</span><span class="n">sort</span><span class="p">()),</span> <span class="s2">&quot;Sort mismatch&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">val</span>

    <span class="k">def</span> <span class="nf">name</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the name (string) of sort `self`.</span>

<span class="sd">        &gt;&gt;&gt; BoolSort().name()</span>
<span class="sd">        &#39;Bool&#39;</span>
<span class="sd">        &gt;&gt;&gt; ArraySort(IntSort(), IntSort()).name()</span>
<span class="sd">        &#39;Array&#39;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_symbol2py</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">,</span> <span class="n">Z3_get_sort_name</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx_ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">ast</span><span class="p">))</span>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return `True` if `self` and `other` are the same Z3 sort.</span>

<span class="sd">        &gt;&gt;&gt; p = Bool(&#39;p&#39;)</span>
<span class="sd">        &gt;&gt;&gt; p.sort() == BoolSort()</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; p.sort() == IntSort()</span>
<span class="sd">        False</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">other</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="n">Z3_is_eq_sort</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx_ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">ast</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">ast</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return `True` if `self` and `other` are not the same Z3 sort.</span>

<span class="sd">        &gt;&gt;&gt; p = Bool(&#39;p&#39;)</span>
<span class="sd">        &gt;&gt;&gt; p.sort() != BoolSort()</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; p.sort() != IntSort()</span>
<span class="sd">        True</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="n">Z3_is_eq_sort</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx_ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">ast</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">ast</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Hash code. &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">AstRef</span><span class="o">.</span><span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">is_sort</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return `True` if `s` is a Z3 sort.</span>

<span class="sd">    &gt;&gt;&gt; is_sort(IntSort())</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; is_sort(Int(&#39;x&#39;))</span>
<span class="sd">    False</span>
<span class="sd">    &gt;&gt;&gt; is_expr(Int(&#39;x&#39;))</span>
<span class="sd">    True</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">SortRef</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_to_sort_ref</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">ctx</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">z3_debug</span><span class="p">():</span>
        <span class="n">_z3_assert</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">Sort</span><span class="p">),</span> <span class="s2">&quot;Z3 Sort expected&quot;</span><span class="p">)</span>
    <span class="n">k</span> <span class="o">=</span> <span class="n">_sort_kind</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="n">Z3_BOOL_SORT</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">BoolSortRef</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">ctx</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">k</span> <span class="o">==</span> <span class="n">Z3_INT_SORT</span> <span class="ow">or</span> <span class="n">k</span> <span class="o">==</span> <span class="n">Z3_REAL_SORT</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">ArithSortRef</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">ctx</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">k</span> <span class="o">==</span> <span class="n">Z3_BV_SORT</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">BitVecSortRef</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">ctx</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">k</span> <span class="o">==</span> <span class="n">Z3_ARRAY_SORT</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">ArraySortRef</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">ctx</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">k</span> <span class="o">==</span> <span class="n">Z3_DATATYPE_SORT</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">DatatypeSortRef</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">ctx</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">k</span> <span class="o">==</span> <span class="n">Z3_FINITE_DOMAIN_SORT</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">FiniteDomainSortRef</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">ctx</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">k</span> <span class="o">==</span> <span class="n">Z3_FLOATING_POINT_SORT</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">FPSortRef</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">ctx</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">k</span> <span class="o">==</span> <span class="n">Z3_ROUNDING_MODE_SORT</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">FPRMSortRef</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">ctx</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">k</span> <span class="o">==</span> <span class="n">Z3_RE_SORT</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">ReSortRef</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">ctx</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">k</span> <span class="o">==</span> <span class="n">Z3_SEQ_SORT</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">SeqSortRef</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">ctx</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">k</span> <span class="o">==</span> <span class="n">Z3_CHAR_SORT</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">CharSortRef</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">ctx</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">k</span> <span class="o">==</span> <span class="n">Z3_TYPE_VAR</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">TypeVarRef</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">ctx</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">SortRef</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">ctx</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_sort</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">a</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">_to_sort_ref</span><span class="p">(</span><span class="n">Z3_get_sort</span><span class="p">(</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="n">a</span><span class="p">),</span> <span class="n">ctx</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">DeclareSort</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">ctx</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Create a new uninterpreted sort named `name`.</span>

<span class="sd">    If `ctx=None`, then the new sort is declared in the global Z3Py context.</span>

<span class="sd">    &gt;&gt;&gt; A = DeclareSort(&#39;A&#39;)</span>
<span class="sd">    &gt;&gt;&gt; a = Const(&#39;a&#39;, A)</span>
<span class="sd">    &gt;&gt;&gt; b = Const(&#39;b&#39;, A)</span>
<span class="sd">    &gt;&gt;&gt; a.sort() == A</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; b.sort() == A</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; a == b</span>
<span class="sd">    a == b</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ctx</span> <span class="o">=</span> <span class="n">_get_ctx</span><span class="p">(</span><span class="n">ctx</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">SortRef</span><span class="p">(</span><span class="n">Z3_mk_uninterpreted_sort</span><span class="p">(</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="n">to_symbol</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">ctx</span><span class="p">)),</span> <span class="n">ctx</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">TypeVarRef</span><span class="p">(</span><span class="n">SortRef</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Type variable reference&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">subsort</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">True</span>
    
    <span class="k">def</span> <span class="nf">cast</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">val</span>
    

<span class="k">def</span> <span class="nf">DeclareTypeVar</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">ctx</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Create a new type variable named `name`.</span>

<span class="sd">    If `ctx=None`, then the new sort is declared in the global Z3Py context.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ctx</span> <span class="o">=</span> <span class="n">_get_ctx</span><span class="p">(</span><span class="n">ctx</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">TypeVarRef</span><span class="p">(</span><span class="n">Z3_mk_type_variable</span><span class="p">(</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="n">to_symbol</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">ctx</span><span class="p">)),</span> <span class="n">ctx</span><span class="p">)</span>


<span class="c1">#########################################</span>
<span class="c1">#</span>
<span class="c1"># Function Declarations</span>
<span class="c1">#</span>
<span class="c1">#########################################</span>


<span class="k">class</span> <span class="nc">FuncDeclRef</span><span class="p">(</span><span class="n">AstRef</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Function declaration. Every constant and function have an associated declaration.</span>

<span class="sd">    The declaration assigns a name, a sort (i.e., type), and for function</span>
<span class="sd">    the sort (i.e., type) of each of its arguments. Note that, in Z3,</span>
<span class="sd">    a constant is a function with 0 arguments.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">as_ast</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Z3_func_decl_to_ast</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx_ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">ast</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_id</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Z3_get_ast_id</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx_ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_ast</span><span class="p">())</span>

    <span class="k">def</span> <span class="nf">as_func_decl</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ast</span>

    <span class="k">def</span> <span class="nf">name</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the name of the function declaration `self`.</span>

<span class="sd">        &gt;&gt;&gt; f = Function(&#39;f&#39;, IntSort(), IntSort())</span>
<span class="sd">        &gt;&gt;&gt; f.name()</span>
<span class="sd">        &#39;f&#39;</span>
<span class="sd">        &gt;&gt;&gt; isinstance(f.name(), str)</span>
<span class="sd">        True</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_symbol2py</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">,</span> <span class="n">Z3_get_decl_name</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx_ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">ast</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">arity</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the number of arguments of a function declaration.</span>
<span class="sd">        If `self` is a constant, then `self.arity()` is 0.</span>

<span class="sd">        &gt;&gt;&gt; f = Function(&#39;f&#39;, IntSort(), RealSort(), BoolSort())</span>
<span class="sd">        &gt;&gt;&gt; f.arity()</span>
<span class="sd">        2</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">Z3_get_arity</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx_ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">ast</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">domain</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the sort of the argument `i` of a function declaration.</span>
<span class="sd">        This method assumes that `0 &lt;= i &lt; self.arity()`.</span>

<span class="sd">        &gt;&gt;&gt; f = Function(&#39;f&#39;, IntSort(), RealSort(), BoolSort())</span>
<span class="sd">        &gt;&gt;&gt; f.domain(0)</span>
<span class="sd">        Int</span>
<span class="sd">        &gt;&gt;&gt; f.domain(1)</span>
<span class="sd">        Real</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_to_sort_ref</span><span class="p">(</span><span class="n">Z3_get_domain</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx_ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">ast</span><span class="p">,</span> <span class="n">i</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">range</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the sort of the range of a function declaration.</span>
<span class="sd">        For constants, this is the sort of the constant.</span>

<span class="sd">        &gt;&gt;&gt; f = Function(&#39;f&#39;, IntSort(), RealSort(), BoolSort())</span>
<span class="sd">        &gt;&gt;&gt; f.range()</span>
<span class="sd">        Bool</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_to_sort_ref</span><span class="p">(</span><span class="n">Z3_get_range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx_ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">ast</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">kind</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the internal kind of a function declaration.</span>
<span class="sd">        It can be used to identify Z3 built-in functions such as addition, multiplication, etc.</span>

<span class="sd">        &gt;&gt;&gt; x = Int(&#39;x&#39;)</span>
<span class="sd">        &gt;&gt;&gt; d = (x + 1).decl()</span>
<span class="sd">        &gt;&gt;&gt; d.kind() == Z3_OP_ADD</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; d.kind() == Z3_OP_MUL</span>
<span class="sd">        False</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Z3_get_decl_kind</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx_ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">ast</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">params</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">ctx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">Z3_get_decl_num_parameters</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx_ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">ast</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="n">k</span> <span class="o">=</span> <span class="n">Z3_get_decl_parameter_kind</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx_ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">ast</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="n">Z3_PARAMETER_INT</span><span class="p">:</span>
                <span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">Z3_get_decl_int_parameter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx_ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">ast</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">k</span> <span class="o">==</span> <span class="n">Z3_PARAMETER_DOUBLE</span><span class="p">:</span>
                <span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">Z3_get_decl_double_parameter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx_ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">ast</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">k</span> <span class="o">==</span> <span class="n">Z3_PARAMETER_RATIONAL</span><span class="p">:</span>
                <span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">Z3_get_decl_rational_parameter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx_ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">ast</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">k</span> <span class="o">==</span> <span class="n">Z3_PARAMETER_SYMBOL</span><span class="p">:</span>
                <span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">Z3_get_decl_symbol_parameter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx_ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">ast</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">k</span> <span class="o">==</span> <span class="n">Z3_PARAMETER_SORT</span><span class="p">:</span>
                <span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">SortRef</span><span class="p">(</span><span class="n">Z3_get_decl_sort_parameter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx_ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">ast</span><span class="p">,</span> <span class="n">i</span><span class="p">),</span> <span class="n">ctx</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">k</span> <span class="o">==</span> <span class="n">Z3_PARAMETER_AST</span><span class="p">:</span>
                <span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">ExprRef</span><span class="p">(</span><span class="n">Z3_get_decl_ast_parameter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx_ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">ast</span><span class="p">,</span> <span class="n">i</span><span class="p">),</span> <span class="n">ctx</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">k</span> <span class="o">==</span> <span class="n">Z3_PARAMETER_FUNC_DECL</span><span class="p">:</span>
                <span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">FuncDeclRef</span><span class="p">(</span><span class="n">Z3_get_decl_func_decl_parameter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx_ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">ast</span><span class="p">,</span> <span class="n">i</span><span class="p">),</span> <span class="n">ctx</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">assert</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create a Z3 application expression using the function `self`, and the given arguments.</span>

<span class="sd">        The arguments must be Z3 expressions. This method assumes that</span>
<span class="sd">        the sorts of the elements in `args` match the sorts of the</span>
<span class="sd">        domain. Limited coercion is supported.  For example, if</span>
<span class="sd">        args[0] is a Python integer, and the function expects a Z3</span>
<span class="sd">        integer, then the argument is automatically converted into a</span>
<span class="sd">        Z3 integer.</span>

<span class="sd">        &gt;&gt;&gt; f = Function(&#39;f&#39;, IntSort(), RealSort(), BoolSort())</span>
<span class="sd">        &gt;&gt;&gt; x = Int(&#39;x&#39;)</span>
<span class="sd">        &gt;&gt;&gt; y = Real(&#39;y&#39;)</span>
<span class="sd">        &gt;&gt;&gt; f(x, y)</span>
<span class="sd">        f(x, y)</span>
<span class="sd">        &gt;&gt;&gt; f(x, x)</span>
<span class="sd">        f(x, ToReal(x))</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">args</span> <span class="o">=</span> <span class="n">_get_args</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
        <span class="n">num</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
        <span class="n">_args</span> <span class="o">=</span> <span class="p">(</span><span class="n">Ast</span> <span class="o">*</span> <span class="n">num</span><span class="p">)()</span>
        <span class="n">saved</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num</span><span class="p">):</span>
            <span class="c1"># self.domain(i).cast(args[i]) may create a new Z3 expression,</span>
            <span class="c1"># then we must save in &#39;saved&#39; to prevent it from being garbage collected.</span>
            <span class="n">tmp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">domain</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="n">saved</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tmp</span><span class="p">)</span>
            <span class="n">_args</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">.</span><span class="n">as_ast</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">_to_expr_ref</span><span class="p">(</span><span class="n">Z3_mk_app</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx_ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">ast</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">),</span> <span class="n">_args</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">is_func_decl</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return `True` if `a` is a Z3 function declaration.</span>

<span class="sd">    &gt;&gt;&gt; f = Function(&#39;f&#39;, IntSort(), IntSort())</span>
<span class="sd">    &gt;&gt;&gt; is_func_decl(f)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; x = Real(&#39;x&#39;)</span>
<span class="sd">    &gt;&gt;&gt; is_func_decl(x)</span>
<span class="sd">    False</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">FuncDeclRef</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">Function</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="o">*</span><span class="n">sig</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Create a new Z3 uninterpreted function with the given sorts.</span>

<span class="sd">    &gt;&gt;&gt; f = Function(&#39;f&#39;, IntSort(), IntSort())</span>
<span class="sd">    &gt;&gt;&gt; f(f(0))</span>
<span class="sd">    f(f(0))</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">sig</span> <span class="o">=</span> <span class="n">_get_args</span><span class="p">(</span><span class="n">sig</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">z3_debug</span><span class="p">():</span>
        <span class="n">_z3_assert</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sig</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;At least two arguments expected&quot;</span><span class="p">)</span>
    <span class="n">arity</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">sig</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="n">rng</span> <span class="o">=</span> <span class="n">sig</span><span class="p">[</span><span class="n">arity</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">z3_debug</span><span class="p">():</span>
        <span class="n">_z3_assert</span><span class="p">(</span><span class="n">is_sort</span><span class="p">(</span><span class="n">rng</span><span class="p">),</span> <span class="s2">&quot;Z3 sort expected&quot;</span><span class="p">)</span>
    <span class="n">dom</span> <span class="o">=</span> <span class="p">(</span><span class="n">Sort</span> <span class="o">*</span> <span class="n">arity</span><span class="p">)()</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">arity</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">z3_debug</span><span class="p">():</span>
            <span class="n">_z3_assert</span><span class="p">(</span><span class="n">is_sort</span><span class="p">(</span><span class="n">sig</span><span class="p">[</span><span class="n">i</span><span class="p">]),</span> <span class="s2">&quot;Z3 sort expected&quot;</span><span class="p">)</span>
        <span class="n">dom</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">sig</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">ast</span>
    <span class="n">ctx</span> <span class="o">=</span> <span class="n">rng</span><span class="o">.</span><span class="n">ctx</span>
    <span class="k">return</span> <span class="n">FuncDeclRef</span><span class="p">(</span><span class="n">Z3_mk_func_decl</span><span class="p">(</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="n">to_symbol</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">ctx</span><span class="p">),</span> <span class="n">arity</span><span class="p">,</span> <span class="n">dom</span><span class="p">,</span> <span class="n">rng</span><span class="o">.</span><span class="n">ast</span><span class="p">),</span> <span class="n">ctx</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">FreshFunction</span><span class="p">(</span><span class="o">*</span><span class="n">sig</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Create a new fresh Z3 uninterpreted function with the given sorts.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">sig</span> <span class="o">=</span> <span class="n">_get_args</span><span class="p">(</span><span class="n">sig</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">z3_debug</span><span class="p">():</span>
        <span class="n">_z3_assert</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sig</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;At least two arguments expected&quot;</span><span class="p">)</span>
    <span class="n">arity</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">sig</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="n">rng</span> <span class="o">=</span> <span class="n">sig</span><span class="p">[</span><span class="n">arity</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">z3_debug</span><span class="p">():</span>
        <span class="n">_z3_assert</span><span class="p">(</span><span class="n">is_sort</span><span class="p">(</span><span class="n">rng</span><span class="p">),</span> <span class="s2">&quot;Z3 sort expected&quot;</span><span class="p">)</span>
    <span class="n">dom</span> <span class="o">=</span> <span class="p">(</span><span class="n">z3</span><span class="o">.</span><span class="n">Sort</span> <span class="o">*</span> <span class="n">arity</span><span class="p">)()</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">arity</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">z3_debug</span><span class="p">():</span>
            <span class="n">_z3_assert</span><span class="p">(</span><span class="n">is_sort</span><span class="p">(</span><span class="n">sig</span><span class="p">[</span><span class="n">i</span><span class="p">]),</span> <span class="s2">&quot;Z3 sort expected&quot;</span><span class="p">)</span>
        <span class="n">dom</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">sig</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">ast</span>
    <span class="n">ctx</span> <span class="o">=</span> <span class="n">rng</span><span class="o">.</span><span class="n">ctx</span>
    <span class="k">return</span> <span class="n">FuncDeclRef</span><span class="p">(</span><span class="n">Z3_mk_fresh_func_decl</span><span class="p">(</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="s2">&quot;f&quot;</span><span class="p">,</span> <span class="n">arity</span><span class="p">,</span> <span class="n">dom</span><span class="p">,</span> <span class="n">rng</span><span class="o">.</span><span class="n">ast</span><span class="p">),</span> <span class="n">ctx</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_to_func_decl_ref</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">ctx</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">FuncDeclRef</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">ctx</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">RecFunction</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="o">*</span><span class="n">sig</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Create a new Z3 recursive with the given sorts.&quot;&quot;&quot;</span>
    <span class="n">sig</span> <span class="o">=</span> <span class="n">_get_args</span><span class="p">(</span><span class="n">sig</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">z3_debug</span><span class="p">():</span>
        <span class="n">_z3_assert</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sig</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;At least two arguments expected&quot;</span><span class="p">)</span>
    <span class="n">arity</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">sig</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="n">rng</span> <span class="o">=</span> <span class="n">sig</span><span class="p">[</span><span class="n">arity</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">z3_debug</span><span class="p">():</span>
        <span class="n">_z3_assert</span><span class="p">(</span><span class="n">is_sort</span><span class="p">(</span><span class="n">rng</span><span class="p">),</span> <span class="s2">&quot;Z3 sort expected&quot;</span><span class="p">)</span>
    <span class="n">dom</span> <span class="o">=</span> <span class="p">(</span><span class="n">Sort</span> <span class="o">*</span> <span class="n">arity</span><span class="p">)()</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">arity</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">z3_debug</span><span class="p">():</span>
            <span class="n">_z3_assert</span><span class="p">(</span><span class="n">is_sort</span><span class="p">(</span><span class="n">sig</span><span class="p">[</span><span class="n">i</span><span class="p">]),</span> <span class="s2">&quot;Z3 sort expected&quot;</span><span class="p">)</span>
        <span class="n">dom</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">sig</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">ast</span>
    <span class="n">ctx</span> <span class="o">=</span> <span class="n">rng</span><span class="o">.</span><span class="n">ctx</span>
    <span class="k">return</span> <span class="n">FuncDeclRef</span><span class="p">(</span><span class="n">Z3_mk_rec_func_decl</span><span class="p">(</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="n">to_symbol</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">ctx</span><span class="p">),</span> <span class="n">arity</span><span class="p">,</span> <span class="n">dom</span><span class="p">,</span> <span class="n">rng</span><span class="o">.</span><span class="n">ast</span><span class="p">),</span> <span class="n">ctx</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">RecAddDefinition</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">body</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Set the body of a recursive function.</span>
<span class="sd">       Recursive definitions can be simplified if they are applied to ground</span>
<span class="sd">       arguments.</span>
<span class="sd">    &gt;&gt;&gt; ctx = Context()</span>
<span class="sd">    &gt;&gt;&gt; fac = RecFunction(&#39;fac&#39;, IntSort(ctx), IntSort(ctx))</span>
<span class="sd">    &gt;&gt;&gt; n = Int(&#39;n&#39;, ctx)</span>
<span class="sd">    &gt;&gt;&gt; RecAddDefinition(fac, n, If(n == 0, 1, n*fac(n-1)))</span>
<span class="sd">    &gt;&gt;&gt; simplify(fac(5))</span>
<span class="sd">    120</span>
<span class="sd">    &gt;&gt;&gt; s = Solver(ctx=ctx)</span>
<span class="sd">    &gt;&gt;&gt; s.add(fac(n) &lt; 3)</span>
<span class="sd">    &gt;&gt;&gt; s.check()</span>
<span class="sd">    sat</span>
<span class="sd">    &gt;&gt;&gt; s.model().eval(fac(5))</span>
<span class="sd">    120</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">is_app</span><span class="p">(</span><span class="n">args</span><span class="p">):</span>
        <span class="n">args</span> <span class="o">=</span> <span class="p">[</span><span class="n">args</span><span class="p">]</span>
    <span class="n">ctx</span> <span class="o">=</span> <span class="n">body</span><span class="o">.</span><span class="n">ctx</span>
    <span class="n">args</span> <span class="o">=</span> <span class="n">_get_args</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
    <span class="n">_args</span> <span class="o">=</span> <span class="p">(</span><span class="n">Ast</span> <span class="o">*</span> <span class="n">n</span><span class="p">)()</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="n">_args</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">ast</span>
    <span class="n">Z3_add_rec_def</span><span class="p">(</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="n">f</span><span class="o">.</span><span class="n">ast</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">_args</span><span class="p">,</span> <span class="n">body</span><span class="o">.</span><span class="n">ast</span><span class="p">)</span>

<span class="c1">#########################################</span>
<span class="c1">#</span>
<span class="c1"># Expressions</span>
<span class="c1">#</span>
<span class="c1">#########################################</span>


<span class="k">class</span> <span class="nc">ExprRef</span><span class="p">(</span><span class="n">AstRef</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Constraints, formulas and terms are expressions in Z3.</span>

<span class="sd">    Expressions are ASTs. Every expression has a sort.</span>
<span class="sd">    There are three main kinds of expressions:</span>
<span class="sd">    function applications, quantifiers and bounded variables.</span>
<span class="sd">    A constant is a function application with 0 arguments.</span>
<span class="sd">    For quantifier free problems, all expressions are</span>
<span class="sd">    function applications.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">as_ast</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ast</span>

    <span class="k">def</span> <span class="nf">get_id</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Z3_get_ast_id</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx_ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_ast</span><span class="p">())</span>

    <span class="k">def</span> <span class="nf">sort</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the sort of expression `self`.</span>

<span class="sd">        &gt;&gt;&gt; x = Int(&#39;x&#39;)</span>
<span class="sd">        &gt;&gt;&gt; (x + 1).sort()</span>
<span class="sd">        Int</span>
<span class="sd">        &gt;&gt;&gt; y = Real(&#39;y&#39;)</span>
<span class="sd">        &gt;&gt;&gt; (x + y).sort()</span>
<span class="sd">        Real</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_sort</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_ast</span><span class="p">())</span>

    <span class="k">def</span> <span class="nf">sort_kind</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Shorthand for `self.sort().kind()`.</span>

<span class="sd">        &gt;&gt;&gt; a = Array(&#39;a&#39;, IntSort(), IntSort())</span>
<span class="sd">        &gt;&gt;&gt; a.sort_kind() == Z3_ARRAY_SORT</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; a.sort_kind() == Z3_INT_SORT</span>
<span class="sd">        False</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span><span class="o">.</span><span class="n">kind</span><span class="p">()</span>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a Z3 expression that represents the constraint `self == other`.</span>

<span class="sd">        If `other` is `None`, then this method simply returns `False`.</span>

<span class="sd">        &gt;&gt;&gt; a = Int(&#39;a&#39;)</span>
<span class="sd">        &gt;&gt;&gt; b = Int(&#39;b&#39;)</span>
<span class="sd">        &gt;&gt;&gt; a == b</span>
<span class="sd">        a == b</span>
<span class="sd">        &gt;&gt;&gt; a is None</span>
<span class="sd">        False</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">other</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">_coerce_exprs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">BoolRef</span><span class="p">(</span><span class="n">Z3_mk_eq</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx_ref</span><span class="p">(),</span> <span class="n">a</span><span class="o">.</span><span class="n">as_ast</span><span class="p">(),</span> <span class="n">b</span><span class="o">.</span><span class="n">as_ast</span><span class="p">()),</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Hash code. &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">AstRef</span><span class="o">.</span><span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a Z3 expression that represents the constraint `self != other`.</span>

<span class="sd">        If `other` is `None`, then this method simply returns `True`.</span>

<span class="sd">        &gt;&gt;&gt; a = Int(&#39;a&#39;)</span>
<span class="sd">        &gt;&gt;&gt; b = Int(&#39;b&#39;)</span>
<span class="sd">        &gt;&gt;&gt; a != b</span>
<span class="sd">        a != b</span>
<span class="sd">        &gt;&gt;&gt; a is not None</span>
<span class="sd">        True</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">other</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">_coerce_exprs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
        <span class="n">_args</span><span class="p">,</span> <span class="n">sz</span> <span class="o">=</span> <span class="n">_to_ast_array</span><span class="p">((</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">BoolRef</span><span class="p">(</span><span class="n">Z3_mk_distinct</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx_ref</span><span class="p">(),</span> <span class="mi">2</span><span class="p">,</span> <span class="n">_args</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">params</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">decl</span><span class="p">()</span><span class="o">.</span><span class="n">params</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">decl</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the Z3 function declaration associated with a Z3 application.</span>

<span class="sd">        &gt;&gt;&gt; f = Function(&#39;f&#39;, IntSort(), IntSort())</span>
<span class="sd">        &gt;&gt;&gt; a = Int(&#39;a&#39;)</span>
<span class="sd">        &gt;&gt;&gt; t = f(a)</span>
<span class="sd">        &gt;&gt;&gt; eq(t.decl(), f)</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; (a + 1).decl()</span>
<span class="sd">        +</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">z3_debug</span><span class="p">():</span>
            <span class="n">_z3_assert</span><span class="p">(</span><span class="n">is_app</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="s2">&quot;Z3 application expected&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">FuncDeclRef</span><span class="p">(</span><span class="n">Z3_get_app_decl</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx_ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_ast</span><span class="p">()),</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">num_args</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the number of arguments of a Z3 application.</span>

<span class="sd">        &gt;&gt;&gt; a = Int(&#39;a&#39;)</span>
<span class="sd">        &gt;&gt;&gt; b = Int(&#39;b&#39;)</span>
<span class="sd">        &gt;&gt;&gt; (a + b).num_args()</span>
<span class="sd">        2</span>
<span class="sd">        &gt;&gt;&gt; f = Function(&#39;f&#39;, IntSort(), IntSort(), IntSort(), IntSort())</span>
<span class="sd">        &gt;&gt;&gt; t = f(a, b, 0)</span>
<span class="sd">        &gt;&gt;&gt; t.num_args()</span>
<span class="sd">        3</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">z3_debug</span><span class="p">():</span>
            <span class="n">_z3_assert</span><span class="p">(</span><span class="n">is_app</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="s2">&quot;Z3 application expected&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">Z3_get_app_num_args</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx_ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_ast</span><span class="p">()))</span>

    <span class="k">def</span> <span class="nf">arg</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return argument `idx` of the application `self`.</span>

<span class="sd">        This method assumes that `self` is a function application with at least `idx+1` arguments.</span>

<span class="sd">        &gt;&gt;&gt; a = Int(&#39;a&#39;)</span>
<span class="sd">        &gt;&gt;&gt; b = Int(&#39;b&#39;)</span>
<span class="sd">        &gt;&gt;&gt; f = Function(&#39;f&#39;, IntSort(), IntSort(), IntSort(), IntSort())</span>
<span class="sd">        &gt;&gt;&gt; t = f(a, b, 0)</span>
<span class="sd">        &gt;&gt;&gt; t.arg(0)</span>
<span class="sd">        a</span>
<span class="sd">        &gt;&gt;&gt; t.arg(1)</span>
<span class="sd">        b</span>
<span class="sd">        &gt;&gt;&gt; t.arg(2)</span>
<span class="sd">        0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">z3_debug</span><span class="p">():</span>
            <span class="n">_z3_assert</span><span class="p">(</span><span class="n">is_app</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="s2">&quot;Z3 application expected&quot;</span><span class="p">)</span>
            <span class="n">_z3_assert</span><span class="p">(</span><span class="n">idx</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_args</span><span class="p">(),</span> <span class="s2">&quot;Invalid argument index&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">_to_expr_ref</span><span class="p">(</span><span class="n">Z3_get_app_arg</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx_ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_ast</span><span class="p">(),</span> <span class="n">idx</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">children</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a list containing the children of the given expression</span>

<span class="sd">        &gt;&gt;&gt; a = Int(&#39;a&#39;)</span>
<span class="sd">        &gt;&gt;&gt; b = Int(&#39;b&#39;)</span>
<span class="sd">        &gt;&gt;&gt; f = Function(&#39;f&#39;, IntSort(), IntSort(), IntSort(), IntSort())</span>
<span class="sd">        &gt;&gt;&gt; t = f(a, b, 0)</span>
<span class="sd">        &gt;&gt;&gt; t.children()</span>
<span class="sd">        [a, b, 0]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">is_app</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">arg</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_args</span><span class="p">())]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span>

    <span class="k">def</span> <span class="nf">from_string</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">):</span>
        <span class="k">pass</span>

    <span class="k">def</span> <span class="nf">serialize</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">Solver</span><span class="p">()</span>
        <span class="n">f</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s1">&#39;F&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sort</span><span class="p">(),</span> <span class="n">BoolSort</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">))</span>
        <span class="n">s</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">s</span><span class="o">.</span><span class="n">sexpr</span><span class="p">()</span>

<span class="k">def</span> <span class="nf">deserialize</span><span class="p">(</span><span class="n">st</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;inverse function to the serialize method on ExprRef.</span>
<span class="sd">    It is made available to make it easier for users to serialize expressions back and forth between</span>
<span class="sd">    strings. Solvers can be serialized using the &#39;sexpr()&#39; method.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">Solver</span><span class="p">()</span>
    <span class="n">s</span><span class="o">.</span><span class="n">from_string</span><span class="p">(</span><span class="n">st</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">assertions</span><span class="p">())</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">Z3Exception</span><span class="p">(</span><span class="s2">&quot;single assertion expected&quot;</span><span class="p">)</span>
    <span class="n">fml</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">assertions</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">fml</span><span class="o">.</span><span class="n">num_args</span><span class="p">()</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">Z3Exception</span><span class="p">(</span><span class="s2">&quot;dummy function &#39;F&#39; expected&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">fml</span><span class="o">.</span><span class="n">arg</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">_to_expr_ref</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">ctx</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">Pattern</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">PatternRef</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">ctx</span><span class="p">)</span>
    <span class="n">ctx_ref</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">()</span>
    <span class="n">k</span> <span class="o">=</span> <span class="n">Z3_get_ast_kind</span><span class="p">(</span><span class="n">ctx_ref</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="n">Z3_QUANTIFIER_AST</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">QuantifierRef</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">ctx</span><span class="p">)</span>
    <span class="n">sk</span> <span class="o">=</span> <span class="n">Z3_get_sort_kind</span><span class="p">(</span><span class="n">ctx_ref</span><span class="p">,</span> <span class="n">Z3_get_sort</span><span class="p">(</span><span class="n">ctx_ref</span><span class="p">,</span> <span class="n">a</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">sk</span> <span class="o">==</span> <span class="n">Z3_BOOL_SORT</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">BoolRef</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">ctx</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">sk</span> <span class="o">==</span> <span class="n">Z3_INT_SORT</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="n">Z3_NUMERAL_AST</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">IntNumRef</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">ctx</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ArithRef</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">ctx</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">sk</span> <span class="o">==</span> <span class="n">Z3_REAL_SORT</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="n">Z3_NUMERAL_AST</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">RatNumRef</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">ctx</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">_is_algebraic</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">a</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">AlgebraicNumRef</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">ctx</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ArithRef</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">ctx</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">sk</span> <span class="o">==</span> <span class="n">Z3_BV_SORT</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="n">Z3_NUMERAL_AST</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">BitVecNumRef</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">ctx</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">BitVecRef</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">ctx</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">sk</span> <span class="o">==</span> <span class="n">Z3_ARRAY_SORT</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">ArrayRef</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">ctx</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">sk</span> <span class="o">==</span> <span class="n">Z3_DATATYPE_SORT</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">DatatypeRef</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">ctx</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">sk</span> <span class="o">==</span> <span class="n">Z3_FLOATING_POINT_SORT</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="n">Z3_APP_AST</span> <span class="ow">and</span> <span class="n">_is_numeral</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">a</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">FPNumRef</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">ctx</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">FPRef</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">ctx</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">sk</span> <span class="o">==</span> <span class="n">Z3_FINITE_DOMAIN_SORT</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="n">Z3_NUMERAL_AST</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">FiniteDomainNumRef</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">ctx</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">FiniteDomainRef</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">ctx</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">sk</span> <span class="o">==</span> <span class="n">Z3_ROUNDING_MODE_SORT</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">FPRMRef</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">ctx</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">sk</span> <span class="o">==</span> <span class="n">Z3_SEQ_SORT</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">SeqRef</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">ctx</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">sk</span> <span class="o">==</span> <span class="n">Z3_CHAR_SORT</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">CharRef</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">ctx</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">sk</span> <span class="o">==</span> <span class="n">Z3_RE_SORT</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">ReRef</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">ctx</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">ExprRef</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">ctx</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_coerce_expr_merge</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">a</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">is_expr</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
        <span class="n">s1</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">s</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">s1</span>
        <span class="k">if</span> <span class="n">s1</span><span class="o">.</span><span class="n">eq</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">s</span>
        <span class="k">elif</span> <span class="n">s</span><span class="o">.</span><span class="n">subsort</span><span class="p">(</span><span class="n">s1</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">s1</span>
        <span class="k">elif</span> <span class="n">s1</span><span class="o">.</span><span class="n">subsort</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">s</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">z3_debug</span><span class="p">():</span>
                <span class="n">_z3_assert</span><span class="p">(</span><span class="n">s1</span><span class="o">.</span><span class="n">ctx</span> <span class="o">==</span> <span class="n">s</span><span class="o">.</span><span class="n">ctx</span><span class="p">,</span> <span class="s2">&quot;context mismatch&quot;</span><span class="p">)</span>
                <span class="n">_z3_assert</span><span class="p">(</span><span class="kc">False</span><span class="p">,</span> <span class="s2">&quot;sort mismatch&quot;</span><span class="p">)</span>        
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">s</span>


<span class="k">def</span> <span class="nf">_coerce_exprs</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">ctx</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">is_expr</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">is_expr</span><span class="p">(</span><span class="n">b</span><span class="p">):</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">_py2expr</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">ctx</span><span class="p">)</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">_py2expr</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">ctx</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">SeqRef</span><span class="p">):</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">StringVal</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">SeqRef</span><span class="p">):</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">StringVal</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">ArithRef</span><span class="p">):</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">RealVal</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">ArithRef</span><span class="p">):</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">RealVal</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>

    <span class="n">s</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">_coerce_expr_merge</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">_coerce_expr_merge</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_reduce</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">sequence</span><span class="p">,</span> <span class="n">initial</span><span class="p">):</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">initial</span>
    <span class="k">for</span> <span class="n">element</span> <span class="ow">in</span> <span class="n">sequence</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">element</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">result</span>


<span class="k">def</span> <span class="nf">_coerce_expr_list</span><span class="p">(</span><span class="n">alist</span><span class="p">,</span> <span class="n">ctx</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="n">has_expr</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">alist</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">is_expr</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
            <span class="n">has_expr</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">break</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">has_expr</span><span class="p">:</span>
        <span class="n">alist</span> <span class="o">=</span> <span class="p">[</span><span class="n">_py2expr</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">ctx</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">alist</span><span class="p">]</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">_reduce</span><span class="p">(</span><span class="n">_coerce_expr_merge</span><span class="p">,</span> <span class="n">alist</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">s</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">alist</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">is_expr</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return `True` if `a` is a Z3 expression.</span>

<span class="sd">    &gt;&gt;&gt; a = Int(&#39;a&#39;)</span>
<span class="sd">    &gt;&gt;&gt; is_expr(a)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; is_expr(a + 1)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; is_expr(IntSort())</span>
<span class="sd">    False</span>
<span class="sd">    &gt;&gt;&gt; is_expr(1)</span>
<span class="sd">    False</span>
<span class="sd">    &gt;&gt;&gt; is_expr(IntVal(1))</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; x = Int(&#39;x&#39;)</span>
<span class="sd">    &gt;&gt;&gt; is_expr(ForAll(x, x &gt;= 0))</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; is_expr(FPVal(1.0))</span>
<span class="sd">    True</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">ExprRef</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">is_app</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return `True` if `a` is a Z3 function application.</span>

<span class="sd">    Note that, constants are function applications with 0 arguments.</span>

<span class="sd">    &gt;&gt;&gt; a = Int(&#39;a&#39;)</span>
<span class="sd">    &gt;&gt;&gt; is_app(a)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; is_app(a + 1)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; is_app(IntSort())</span>
<span class="sd">    False</span>
<span class="sd">    &gt;&gt;&gt; is_app(1)</span>
<span class="sd">    False</span>
<span class="sd">    &gt;&gt;&gt; is_app(IntVal(1))</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; x = Int(&#39;x&#39;)</span>
<span class="sd">    &gt;&gt;&gt; is_app(ForAll(x, x &gt;= 0))</span>
<span class="sd">    False</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">ExprRef</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">False</span>
    <span class="n">k</span> <span class="o">=</span> <span class="n">_ast_kind</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">ctx</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">k</span> <span class="o">==</span> <span class="n">Z3_NUMERAL_AST</span> <span class="ow">or</span> <span class="n">k</span> <span class="o">==</span> <span class="n">Z3_APP_AST</span>


<span class="k">def</span> <span class="nf">is_const</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return `True` if `a` is Z3 constant/variable expression.</span>

<span class="sd">    &gt;&gt;&gt; a = Int(&#39;a&#39;)</span>
<span class="sd">    &gt;&gt;&gt; is_const(a)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; is_const(a + 1)</span>
<span class="sd">    False</span>
<span class="sd">    &gt;&gt;&gt; is_const(1)</span>
<span class="sd">    False</span>
<span class="sd">    &gt;&gt;&gt; is_const(IntVal(1))</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; x = Int(&#39;x&#39;)</span>
<span class="sd">    &gt;&gt;&gt; is_const(ForAll(x, x &gt;= 0))</span>
<span class="sd">    False</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">is_app</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="ow">and</span> <span class="n">a</span><span class="o">.</span><span class="n">num_args</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span>


<span class="k">def</span> <span class="nf">is_var</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return `True` if `a` is variable.</span>

<span class="sd">    Z3 uses de-Bruijn indices for representing bound variables in</span>
<span class="sd">    quantifiers.</span>

<span class="sd">    &gt;&gt;&gt; x = Int(&#39;x&#39;)</span>
<span class="sd">    &gt;&gt;&gt; is_var(x)</span>
<span class="sd">    False</span>
<span class="sd">    &gt;&gt;&gt; is_const(x)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; f = Function(&#39;f&#39;, IntSort(), IntSort())</span>
<span class="sd">    &gt;&gt;&gt; # Z3 replaces x with bound variables when ForAll is executed.</span>
<span class="sd">    &gt;&gt;&gt; q = ForAll(x, f(x) == x)</span>
<span class="sd">    &gt;&gt;&gt; b = q.body()</span>
<span class="sd">    &gt;&gt;&gt; b</span>
<span class="sd">    f(Var(0)) == Var(0)</span>
<span class="sd">    &gt;&gt;&gt; b.arg(1)</span>
<span class="sd">    Var(0)</span>
<span class="sd">    &gt;&gt;&gt; is_var(b.arg(1))</span>
<span class="sd">    True</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">is_expr</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="ow">and</span> <span class="n">_ast_kind</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">ctx</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span> <span class="o">==</span> <span class="n">Z3_VAR_AST</span>


<span class="k">def</span> <span class="nf">get_var_index</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return the de-Bruijn index of the Z3 bounded variable `a`.</span>

<span class="sd">    &gt;&gt;&gt; x = Int(&#39;x&#39;)</span>
<span class="sd">    &gt;&gt;&gt; y = Int(&#39;y&#39;)</span>
<span class="sd">    &gt;&gt;&gt; is_var(x)</span>
<span class="sd">    False</span>
<span class="sd">    &gt;&gt;&gt; is_const(x)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; f = Function(&#39;f&#39;, IntSort(), IntSort(), IntSort())</span>
<span class="sd">    &gt;&gt;&gt; # Z3 replaces x and y with bound variables when ForAll is executed.</span>
<span class="sd">    &gt;&gt;&gt; q = ForAll([x, y], f(x, y) == x + y)</span>
<span class="sd">    &gt;&gt;&gt; q.body()</span>
<span class="sd">    f(Var(1), Var(0)) == Var(1) + Var(0)</span>
<span class="sd">    &gt;&gt;&gt; b = q.body()</span>
<span class="sd">    &gt;&gt;&gt; b.arg(0)</span>
<span class="sd">    f(Var(1), Var(0))</span>
<span class="sd">    &gt;&gt;&gt; v1 = b.arg(0).arg(0)</span>
<span class="sd">    &gt;&gt;&gt; v2 = b.arg(0).arg(1)</span>
<span class="sd">    &gt;&gt;&gt; v1</span>
<span class="sd">    Var(1)</span>
<span class="sd">    &gt;&gt;&gt; v2</span>
<span class="sd">    Var(0)</span>
<span class="sd">    &gt;&gt;&gt; get_var_index(v1)</span>
<span class="sd">    1</span>
<span class="sd">    &gt;&gt;&gt; get_var_index(v2)</span>
<span class="sd">    0</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">z3_debug</span><span class="p">():</span>
        <span class="n">_z3_assert</span><span class="p">(</span><span class="n">is_var</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="s2">&quot;Z3 bound variable expected&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">Z3_get_index_value</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="n">a</span><span class="o">.</span><span class="n">as_ast</span><span class="p">()))</span>


<span class="k">def</span> <span class="nf">is_app_of</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return `True` if `a` is an application of the given kind `k`.</span>

<span class="sd">    &gt;&gt;&gt; x = Int(&#39;x&#39;)</span>
<span class="sd">    &gt;&gt;&gt; n = x + 1</span>
<span class="sd">    &gt;&gt;&gt; is_app_of(n, Z3_OP_ADD)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; is_app_of(n, Z3_OP_MUL)</span>
<span class="sd">    False</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">is_app</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="ow">and</span> <span class="n">a</span><span class="o">.</span><span class="n">decl</span><span class="p">()</span><span class="o">.</span><span class="n">kind</span><span class="p">()</span> <span class="o">==</span> <span class="n">k</span>


<span class="k">def</span> <span class="nf">If</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">ctx</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Create a Z3 if-then-else expression.</span>

<span class="sd">    &gt;&gt;&gt; x = Int(&#39;x&#39;)</span>
<span class="sd">    &gt;&gt;&gt; y = Int(&#39;y&#39;)</span>
<span class="sd">    &gt;&gt;&gt; max = If(x &gt; y, x, y)</span>
<span class="sd">    &gt;&gt;&gt; max</span>
<span class="sd">    If(x &gt; y, x, y)</span>
<span class="sd">    &gt;&gt;&gt; simplify(max)</span>
<span class="sd">    If(x &lt;= y, y, x)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">Probe</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">Tactic</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">Tactic</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Cond</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">ctx</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">ctx</span> <span class="o">=</span> <span class="n">_get_ctx</span><span class="p">(</span><span class="n">_ctx_from_ast_arg_list</span><span class="p">([</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">],</span> <span class="n">ctx</span><span class="p">))</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">BoolSort</span><span class="p">(</span><span class="n">ctx</span><span class="p">)</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
        <span class="n">b</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="n">_coerce_exprs</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">ctx</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">z3_debug</span><span class="p">():</span>
            <span class="n">_z3_assert</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">ctx</span> <span class="o">==</span> <span class="n">b</span><span class="o">.</span><span class="n">ctx</span><span class="p">,</span> <span class="s2">&quot;Context mismatch&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">_to_expr_ref</span><span class="p">(</span><span class="n">Z3_mk_ite</span><span class="p">(</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="n">a</span><span class="o">.</span><span class="n">as_ast</span><span class="p">(),</span> <span class="n">b</span><span class="o">.</span><span class="n">as_ast</span><span class="p">(),</span> <span class="n">c</span><span class="o">.</span><span class="n">as_ast</span><span class="p">()),</span> <span class="n">ctx</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">Distinct</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Create a Z3 distinct expression.</span>

<span class="sd">    &gt;&gt;&gt; x = Int(&#39;x&#39;)</span>
<span class="sd">    &gt;&gt;&gt; y = Int(&#39;y&#39;)</span>
<span class="sd">    &gt;&gt;&gt; Distinct(x, y)</span>
<span class="sd">    x != y</span>
<span class="sd">    &gt;&gt;&gt; z = Int(&#39;z&#39;)</span>
<span class="sd">    &gt;&gt;&gt; Distinct(x, y, z)</span>
<span class="sd">    Distinct(x, y, z)</span>
<span class="sd">    &gt;&gt;&gt; simplify(Distinct(x, y, z))</span>
<span class="sd">    Distinct(x, y, z)</span>
<span class="sd">    &gt;&gt;&gt; simplify(Distinct(x, y, z), blast_distinct=True)</span>
<span class="sd">    And(Not(x == y), Not(x == z), Not(y == z))</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">args</span> <span class="o">=</span> <span class="n">_get_args</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
    <span class="n">ctx</span> <span class="o">=</span> <span class="n">_ctx_from_ast_arg_list</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">z3_debug</span><span class="p">():</span>
        <span class="n">_z3_assert</span><span class="p">(</span><span class="n">ctx</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;At least one of the arguments must be a Z3 expression&quot;</span><span class="p">)</span>
    <span class="n">args</span> <span class="o">=</span> <span class="n">_coerce_expr_list</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">ctx</span><span class="p">)</span>
    <span class="n">_args</span><span class="p">,</span> <span class="n">sz</span> <span class="o">=</span> <span class="n">_to_ast_array</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">BoolRef</span><span class="p">(</span><span class="n">Z3_mk_distinct</span><span class="p">(</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="n">sz</span><span class="p">,</span> <span class="n">_args</span><span class="p">),</span> <span class="n">ctx</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_mk_bin</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="n">args</span> <span class="o">=</span> <span class="p">(</span><span class="n">Ast</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)()</span>
    <span class="k">if</span> <span class="n">z3_debug</span><span class="p">():</span>
        <span class="n">_z3_assert</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">ctx</span> <span class="o">==</span> <span class="n">b</span><span class="o">.</span><span class="n">ctx</span><span class="p">,</span> <span class="s2">&quot;Context mismatch&quot;</span><span class="p">)</span>
    <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">as_ast</span><span class="p">()</span>
    <span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="n">as_ast</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">f</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="mi">2</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">Const</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">sort</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Create a constant of the given sort.</span>

<span class="sd">    &gt;&gt;&gt; Const(&#39;x&#39;, IntSort())</span>
<span class="sd">    x</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">z3_debug</span><span class="p">():</span>
        <span class="n">_z3_assert</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">sort</span><span class="p">,</span> <span class="n">SortRef</span><span class="p">),</span> <span class="s2">&quot;Z3 sort expected&quot;</span><span class="p">)</span>
    <span class="n">ctx</span> <span class="o">=</span> <span class="n">sort</span><span class="o">.</span><span class="n">ctx</span>
    <span class="k">return</span> <span class="n">_to_expr_ref</span><span class="p">(</span><span class="n">Z3_mk_const</span><span class="p">(</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="n">to_symbol</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">ctx</span><span class="p">),</span> <span class="n">sort</span><span class="o">.</span><span class="n">ast</span><span class="p">),</span> <span class="n">ctx</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">Consts</span><span class="p">(</span><span class="n">names</span><span class="p">,</span> <span class="n">sort</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Create several constants of the given sort.</span>

<span class="sd">    `names` is a string containing the names of all constants to be created.</span>
<span class="sd">    Blank spaces separate the names of different constants.</span>

<span class="sd">    &gt;&gt;&gt; x, y, z = Consts(&#39;x y z&#39;, IntSort())</span>
<span class="sd">    &gt;&gt;&gt; x + y + z</span>
<span class="sd">    x + y + z</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">names</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="n">names</span> <span class="o">=</span> <span class="n">names</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot; &quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">Const</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">sort</span><span class="p">)</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">names</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">FreshConst</span><span class="p">(</span><span class="n">sort</span><span class="p">,</span> <span class="n">prefix</span><span class="o">=</span><span class="s2">&quot;c&quot;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Create a fresh constant of a specified sort&quot;&quot;&quot;</span>
    <span class="n">ctx</span> <span class="o">=</span> <span class="n">_get_ctx</span><span class="p">(</span><span class="n">sort</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">_to_expr_ref</span><span class="p">(</span><span class="n">Z3_mk_fresh_const</span><span class="p">(</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="n">prefix</span><span class="p">,</span> <span class="n">sort</span><span class="o">.</span><span class="n">ast</span><span class="p">),</span> <span class="n">ctx</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">Var</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">s</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Create a Z3 free variable. Free variables are used to create quantified formulas.</span>
<span class="sd">    A free variable with index n is bound when it occurs within the scope of n+1 quantified</span>
<span class="sd">    declarations.</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; Var(0, IntSort())</span>
<span class="sd">    Var(0)</span>
<span class="sd">    &gt;&gt;&gt; eq(Var(0, IntSort()), Var(0, BoolSort()))</span>
<span class="sd">    False</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">z3_debug</span><span class="p">():</span>
        <span class="n">_z3_assert</span><span class="p">(</span><span class="n">is_sort</span><span class="p">(</span><span class="n">s</span><span class="p">),</span> <span class="s2">&quot;Z3 sort expected&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">_to_expr_ref</span><span class="p">(</span><span class="n">Z3_mk_bound</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">ctx_ref</span><span class="p">(),</span> <span class="n">idx</span><span class="p">,</span> <span class="n">s</span><span class="o">.</span><span class="n">ast</span><span class="p">),</span> <span class="n">s</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">RealVar</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">ctx</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create a real free variable. Free variables are used to create quantified formulas.</span>
<span class="sd">    They are also used to create polynomials.</span>

<span class="sd">    &gt;&gt;&gt; RealVar(0)</span>
<span class="sd">    Var(0)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">Var</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">RealSort</span><span class="p">(</span><span class="n">ctx</span><span class="p">))</span>


<span class="k">def</span> <span class="nf">RealVarVector</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">ctx</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create a list of Real free variables.</span>
<span class="sd">    The variables have ids: 0, 1, ..., n-1</span>

<span class="sd">    &gt;&gt;&gt; x0, x1, x2, x3 = RealVarVector(4)</span>
<span class="sd">    &gt;&gt;&gt; x2</span>
<span class="sd">    Var(2)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">RealVar</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">ctx</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)]</span>

<span class="c1">#########################################</span>
<span class="c1">#</span>
<span class="c1"># Booleans</span>
<span class="c1">#</span>
<span class="c1">#########################################</span>


<span class="k">class</span> <span class="nc">BoolSortRef</span><span class="p">(</span><span class="n">SortRef</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Boolean sort.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">cast</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Try to cast `val` as a Boolean.</span>

<span class="sd">        &gt;&gt;&gt; x = BoolSort().cast(True)</span>
<span class="sd">        &gt;&gt;&gt; x</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; is_expr(x)</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; is_expr(True)</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; x.sort()</span>
<span class="sd">        Bool</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">BoolVal</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">z3_debug</span><span class="p">():</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">is_expr</span><span class="p">(</span><span class="n">val</span><span class="p">):</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;True, False or Z3 Boolean expression expected. Received </span><span class="si">%s</span><span class="s2"> of type </span><span class="si">%s</span><span class="s2">&quot;</span>
                <span class="n">_z3_assert</span><span class="p">(</span><span class="n">is_expr</span><span class="p">(</span><span class="n">val</span><span class="p">),</span> <span class="n">msg</span> <span class="o">%</span> <span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">val</span><span class="p">)))</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">eq</span><span class="p">(</span><span class="n">val</span><span class="o">.</span><span class="n">sort</span><span class="p">()):</span>
                <span class="n">_z3_assert</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">eq</span><span class="p">(</span><span class="n">val</span><span class="o">.</span><span class="n">sort</span><span class="p">()),</span> <span class="s2">&quot;Value cannot be converted into a Z3 Boolean value&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">val</span>

    <span class="k">def</span> <span class="nf">subsort</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">ArithSortRef</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">is_int</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">is_bool</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">True</span>


<span class="k">class</span> <span class="nc">BoolRef</span><span class="p">(</span><span class="n">ExprRef</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;All Boolean expressions are instances of this class.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">sort</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">BoolSortRef</span><span class="p">(</span><span class="n">Z3_get_sort</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx_ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_ast</span><span class="p">()),</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">BoolRef</span><span class="p">):</span>
            <span class="n">other</span> <span class="o">=</span> <span class="n">If</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">If</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="n">other</span>

    <span class="k">def</span> <span class="fm">__radd__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span> <span class="o">+</span> <span class="n">other</span>
 
    <span class="k">def</span> <span class="fm">__rmul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span> <span class="o">*</span> <span class="n">other</span>

    <span class="k">def</span> <span class="fm">__mul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create the Z3 expression `self * other`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">and</span> <span class="n">other</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">If</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">and</span> <span class="n">other</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">IntVal</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">BoolRef</span><span class="p">):</span>
            <span class="n">other</span> <span class="o">=</span> <span class="n">If</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">If</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        
    <span class="k">def</span> <span class="fm">__and__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">And</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
    
    <span class="k">def</span> <span class="fm">__or__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Or</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__xor__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Xor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
    
    <span class="k">def</span> <span class="fm">__invert__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Not</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
    
    

    
<span class="k">def</span> <span class="nf">is_bool</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return `True` if `a` is a Z3 Boolean expression.</span>

<span class="sd">    &gt;&gt;&gt; p = Bool(&#39;p&#39;)</span>
<span class="sd">    &gt;&gt;&gt; is_bool(p)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; q = Bool(&#39;q&#39;)</span>
<span class="sd">    &gt;&gt;&gt; is_bool(And(p, q))</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; x = Real(&#39;x&#39;)</span>
<span class="sd">    &gt;&gt;&gt; is_bool(x)</span>
<span class="sd">    False</span>
<span class="sd">    &gt;&gt;&gt; is_bool(x == 0)</span>
<span class="sd">    True</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">BoolRef</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">is_true</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return `True` if `a` is the Z3 true expression.</span>

<span class="sd">    &gt;&gt;&gt; p = Bool(&#39;p&#39;)</span>
<span class="sd">    &gt;&gt;&gt; is_true(p)</span>
<span class="sd">    False</span>
<span class="sd">    &gt;&gt;&gt; is_true(simplify(p == p))</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; x = Real(&#39;x&#39;)</span>
<span class="sd">    &gt;&gt;&gt; is_true(x == 0)</span>
<span class="sd">    False</span>
<span class="sd">    &gt;&gt;&gt; # True is a Python Boolean expression</span>
<span class="sd">    &gt;&gt;&gt; is_true(True)</span>
<span class="sd">    False</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">is_app_of</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">Z3_OP_TRUE</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">is_false</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return `True` if `a` is the Z3 false expression.</span>

<span class="sd">    &gt;&gt;&gt; p = Bool(&#39;p&#39;)</span>
<span class="sd">    &gt;&gt;&gt; is_false(p)</span>
<span class="sd">    False</span>
<span class="sd">    &gt;&gt;&gt; is_false(False)</span>
<span class="sd">    False</span>
<span class="sd">    &gt;&gt;&gt; is_false(BoolVal(False))</span>
<span class="sd">    True</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">is_app_of</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">Z3_OP_FALSE</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">is_and</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return `True` if `a` is a Z3 and expression.</span>

<span class="sd">    &gt;&gt;&gt; p, q = Bools(&#39;p q&#39;)</span>
<span class="sd">    &gt;&gt;&gt; is_and(And(p, q))</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; is_and(Or(p, q))</span>
<span class="sd">    False</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">is_app_of</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">Z3_OP_AND</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">is_or</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return `True` if `a` is a Z3 or expression.</span>

<span class="sd">    &gt;&gt;&gt; p, q = Bools(&#39;p q&#39;)</span>
<span class="sd">    &gt;&gt;&gt; is_or(Or(p, q))</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; is_or(And(p, q))</span>
<span class="sd">    False</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">is_app_of</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">Z3_OP_OR</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">is_implies</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return `True` if `a` is a Z3 implication expression.</span>

<span class="sd">    &gt;&gt;&gt; p, q = Bools(&#39;p q&#39;)</span>
<span class="sd">    &gt;&gt;&gt; is_implies(Implies(p, q))</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; is_implies(And(p, q))</span>
<span class="sd">    False</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">is_app_of</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">Z3_OP_IMPLIES</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">is_not</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return `True` if `a` is a Z3 not expression.</span>

<span class="sd">    &gt;&gt;&gt; p = Bool(&#39;p&#39;)</span>
<span class="sd">    &gt;&gt;&gt; is_not(p)</span>
<span class="sd">    False</span>
<span class="sd">    &gt;&gt;&gt; is_not(Not(p))</span>
<span class="sd">    True</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">is_app_of</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">Z3_OP_NOT</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">is_eq</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return `True` if `a` is a Z3 equality expression.</span>

<span class="sd">    &gt;&gt;&gt; x, y = Ints(&#39;x y&#39;)</span>
<span class="sd">    &gt;&gt;&gt; is_eq(x == y)</span>
<span class="sd">    True</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">is_app_of</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">Z3_OP_EQ</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">is_distinct</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return `True` if `a` is a Z3 distinct expression.</span>

<span class="sd">    &gt;&gt;&gt; x, y, z = Ints(&#39;x y z&#39;)</span>
<span class="sd">    &gt;&gt;&gt; is_distinct(x == y)</span>
<span class="sd">    False</span>
<span class="sd">    &gt;&gt;&gt; is_distinct(Distinct(x, y, z))</span>
<span class="sd">    True</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">is_app_of</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">Z3_OP_DISTINCT</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">BoolSort</span><span class="p">(</span><span class="n">ctx</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return the Boolean Z3 sort. If `ctx=None`, then the global context is used.</span>

<span class="sd">    &gt;&gt;&gt; BoolSort()</span>
<span class="sd">    Bool</span>
<span class="sd">    &gt;&gt;&gt; p = Const(&#39;p&#39;, BoolSort())</span>
<span class="sd">    &gt;&gt;&gt; is_bool(p)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; r = Function(&#39;r&#39;, IntSort(), IntSort(), BoolSort())</span>
<span class="sd">    &gt;&gt;&gt; r(0, 1)</span>
<span class="sd">    r(0, 1)</span>
<span class="sd">    &gt;&gt;&gt; is_bool(r(0, 1))</span>
<span class="sd">    True</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ctx</span> <span class="o">=</span> <span class="n">_get_ctx</span><span class="p">(</span><span class="n">ctx</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">BoolSortRef</span><span class="p">(</span><span class="n">Z3_mk_bool_sort</span><span class="p">(</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">()),</span> <span class="n">ctx</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">BoolVal</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">ctx</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return the Boolean value `True` or `False`. If `ctx=None`, then the global context is used.</span>

<span class="sd">    &gt;&gt;&gt; BoolVal(True)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; is_true(BoolVal(True))</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; is_true(True)</span>
<span class="sd">    False</span>
<span class="sd">    &gt;&gt;&gt; is_false(BoolVal(False))</span>
<span class="sd">    True</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ctx</span> <span class="o">=</span> <span class="n">_get_ctx</span><span class="p">(</span><span class="n">ctx</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">val</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">BoolRef</span><span class="p">(</span><span class="n">Z3_mk_true</span><span class="p">(</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">()),</span> <span class="n">ctx</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">BoolRef</span><span class="p">(</span><span class="n">Z3_mk_false</span><span class="p">(</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">()),</span> <span class="n">ctx</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">Bool</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">ctx</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return a Boolean constant named `name`. If `ctx=None`, then the global context is used.</span>

<span class="sd">    &gt;&gt;&gt; p = Bool(&#39;p&#39;)</span>
<span class="sd">    &gt;&gt;&gt; q = Bool(&#39;q&#39;)</span>
<span class="sd">    &gt;&gt;&gt; And(p, q)</span>
<span class="sd">    And(p, q)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ctx</span> <span class="o">=</span> <span class="n">_get_ctx</span><span class="p">(</span><span class="n">ctx</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">BoolRef</span><span class="p">(</span><span class="n">Z3_mk_const</span><span class="p">(</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="n">to_symbol</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">ctx</span><span class="p">),</span> <span class="n">BoolSort</span><span class="p">(</span><span class="n">ctx</span><span class="p">)</span><span class="o">.</span><span class="n">ast</span><span class="p">),</span> <span class="n">ctx</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">Bools</span><span class="p">(</span><span class="n">names</span><span class="p">,</span> <span class="n">ctx</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return a tuple of Boolean constants.</span>

<span class="sd">    `names` is a single string containing all names separated by blank spaces.</span>
<span class="sd">    If `ctx=None`, then the global context is used.</span>

<span class="sd">    &gt;&gt;&gt; p, q, r = Bools(&#39;p q r&#39;)</span>
<span class="sd">    &gt;&gt;&gt; And(p, Or(q, r))</span>
<span class="sd">    And(p, Or(q, r))</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ctx</span> <span class="o">=</span> <span class="n">_get_ctx</span><span class="p">(</span><span class="n">ctx</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">names</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="n">names</span> <span class="o">=</span> <span class="n">names</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot; &quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">Bool</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">ctx</span><span class="p">)</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">names</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">BoolVector</span><span class="p">(</span><span class="n">prefix</span><span class="p">,</span> <span class="n">sz</span><span class="p">,</span> <span class="n">ctx</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return a list of Boolean constants of size `sz`.</span>

<span class="sd">    The constants are named using the given prefix.</span>
<span class="sd">    If `ctx=None`, then the global context is used.</span>

<span class="sd">    &gt;&gt;&gt; P = BoolVector(&#39;p&#39;, 3)</span>
<span class="sd">    &gt;&gt;&gt; P</span>
<span class="sd">    [p__0, p__1, p__2]</span>
<span class="sd">    &gt;&gt;&gt; And(P)</span>
<span class="sd">    And(p__0, p__1, p__2)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">Bool</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">__</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">prefix</span><span class="p">,</span> <span class="n">i</span><span class="p">))</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">sz</span><span class="p">)]</span>


<span class="k">def</span> <span class="nf">FreshBool</span><span class="p">(</span><span class="n">prefix</span><span class="o">=</span><span class="s2">&quot;b&quot;</span><span class="p">,</span> <span class="n">ctx</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return a fresh Boolean constant in the given context using the given prefix.</span>

<span class="sd">    If `ctx=None`, then the global context is used.</span>

<span class="sd">    &gt;&gt;&gt; b1 = FreshBool()</span>
<span class="sd">    &gt;&gt;&gt; b2 = FreshBool()</span>
<span class="sd">    &gt;&gt;&gt; eq(b1, b2)</span>
<span class="sd">    False</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ctx</span> <span class="o">=</span> <span class="n">_get_ctx</span><span class="p">(</span><span class="n">ctx</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">BoolRef</span><span class="p">(</span><span class="n">Z3_mk_fresh_const</span><span class="p">(</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="n">prefix</span><span class="p">,</span> <span class="n">BoolSort</span><span class="p">(</span><span class="n">ctx</span><span class="p">)</span><span class="o">.</span><span class="n">ast</span><span class="p">),</span> <span class="n">ctx</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">Implies</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">ctx</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Create a Z3 implies expression.</span>

<span class="sd">    &gt;&gt;&gt; p, q = Bools(&#39;p q&#39;)</span>
<span class="sd">    &gt;&gt;&gt; Implies(p, q)</span>
<span class="sd">    Implies(p, q)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ctx</span> <span class="o">=</span> <span class="n">_get_ctx</span><span class="p">(</span><span class="n">_ctx_from_ast_arg_list</span><span class="p">([</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">],</span> <span class="n">ctx</span><span class="p">))</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">BoolSort</span><span class="p">(</span><span class="n">ctx</span><span class="p">)</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">BoolRef</span><span class="p">(</span><span class="n">Z3_mk_implies</span><span class="p">(</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="n">a</span><span class="o">.</span><span class="n">as_ast</span><span class="p">(),</span> <span class="n">b</span><span class="o">.</span><span class="n">as_ast</span><span class="p">()),</span> <span class="n">ctx</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">Xor</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">ctx</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Create a Z3 Xor expression.</span>

<span class="sd">    &gt;&gt;&gt; p, q = Bools(&#39;p q&#39;)</span>
<span class="sd">    &gt;&gt;&gt; Xor(p, q)</span>
<span class="sd">    Xor(p, q)</span>
<span class="sd">    &gt;&gt;&gt; simplify(Xor(p, q))</span>
<span class="sd">    Not(p == q)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ctx</span> <span class="o">=</span> <span class="n">_get_ctx</span><span class="p">(</span><span class="n">_ctx_from_ast_arg_list</span><span class="p">([</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">],</span> <span class="n">ctx</span><span class="p">))</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">BoolSort</span><span class="p">(</span><span class="n">ctx</span><span class="p">)</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">BoolRef</span><span class="p">(</span><span class="n">Z3_mk_xor</span><span class="p">(</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="n">a</span><span class="o">.</span><span class="n">as_ast</span><span class="p">(),</span> <span class="n">b</span><span class="o">.</span><span class="n">as_ast</span><span class="p">()),</span> <span class="n">ctx</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">Not</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">ctx</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Create a Z3 not expression or probe.</span>

<span class="sd">    &gt;&gt;&gt; p = Bool(&#39;p&#39;)</span>
<span class="sd">    &gt;&gt;&gt; Not(Not(p))</span>
<span class="sd">    Not(Not(p))</span>
<span class="sd">    &gt;&gt;&gt; simplify(Not(Not(p)))</span>
<span class="sd">    p</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ctx</span> <span class="o">=</span> <span class="n">_get_ctx</span><span class="p">(</span><span class="n">_ctx_from_ast_arg_list</span><span class="p">([</span><span class="n">a</span><span class="p">],</span> <span class="n">ctx</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">is_probe</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
        <span class="c1"># Not is also used to build probes</span>
        <span class="k">return</span> <span class="n">Probe</span><span class="p">(</span><span class="n">Z3_probe_not</span><span class="p">(</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="n">a</span><span class="o">.</span><span class="n">probe</span><span class="p">),</span> <span class="n">ctx</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">BoolSort</span><span class="p">(</span><span class="n">ctx</span><span class="p">)</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">BoolRef</span><span class="p">(</span><span class="n">Z3_mk_not</span><span class="p">(</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="n">a</span><span class="o">.</span><span class="n">as_ast</span><span class="p">()),</span> <span class="n">ctx</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">mk_not</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">is_not</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">a</span><span class="o">.</span><span class="n">arg</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">Not</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_has_probe</span><span class="p">(</span><span class="n">args</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return `True` if one of the elements of the given collection is a Z3 probe.&quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">args</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">is_probe</span><span class="p">(</span><span class="n">arg</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">True</span>
    <span class="k">return</span> <span class="kc">False</span>


<span class="k">def</span> <span class="nf">And</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Create a Z3 and-expression or and-probe.</span>

<span class="sd">    &gt;&gt;&gt; p, q, r = Bools(&#39;p q r&#39;)</span>
<span class="sd">    &gt;&gt;&gt; And(p, q, r)</span>
<span class="sd">    And(p, q, r)</span>
<span class="sd">    &gt;&gt;&gt; P = BoolVector(&#39;p&#39;, 5)</span>
<span class="sd">    &gt;&gt;&gt; And(P)</span>
<span class="sd">    And(p__0, p__1, p__2, p__3, p__4)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">last_arg</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">last_arg</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">last_arg</span><span class="p">,</span> <span class="n">Context</span><span class="p">):</span>
        <span class="n">ctx</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
        <span class="n">args</span> <span class="o">=</span> <span class="n">args</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">AstVector</span><span class="p">):</span>
        <span class="n">ctx</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">ctx</span>
        <span class="n">args</span> <span class="o">=</span> <span class="p">[</span><span class="n">a</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">ctx</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">args</span> <span class="o">=</span> <span class="n">_get_args</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
    <span class="n">ctx</span> <span class="o">=</span> <span class="n">_get_ctx</span><span class="p">(</span><span class="n">_ctx_from_ast_arg_list</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">ctx</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">z3_debug</span><span class="p">():</span>
        <span class="n">_z3_assert</span><span class="p">(</span><span class="n">ctx</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;At least one of the arguments must be a Z3 expression or probe&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">_has_probe</span><span class="p">(</span><span class="n">args</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">_probe_and</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">ctx</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">args</span> <span class="o">=</span> <span class="n">_coerce_expr_list</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">ctx</span><span class="p">)</span>
        <span class="n">_args</span><span class="p">,</span> <span class="n">sz</span> <span class="o">=</span> <span class="n">_to_ast_array</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">BoolRef</span><span class="p">(</span><span class="n">Z3_mk_and</span><span class="p">(</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="n">sz</span><span class="p">,</span> <span class="n">_args</span><span class="p">),</span> <span class="n">ctx</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">Or</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Create a Z3 or-expression or or-probe.</span>

<span class="sd">    &gt;&gt;&gt; p, q, r = Bools(&#39;p q r&#39;)</span>
<span class="sd">    &gt;&gt;&gt; Or(p, q, r)</span>
<span class="sd">    Or(p, q, r)</span>
<span class="sd">    &gt;&gt;&gt; P = BoolVector(&#39;p&#39;, 5)</span>
<span class="sd">    &gt;&gt;&gt; Or(P)</span>
<span class="sd">    Or(p__0, p__1, p__2, p__3, p__4)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">last_arg</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">last_arg</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">last_arg</span><span class="p">,</span> <span class="n">Context</span><span class="p">):</span>
        <span class="n">ctx</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
        <span class="n">args</span> <span class="o">=</span> <span class="n">args</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">AstVector</span><span class="p">):</span>
        <span class="n">ctx</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">ctx</span>
        <span class="n">args</span> <span class="o">=</span> <span class="p">[</span><span class="n">a</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">ctx</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">args</span> <span class="o">=</span> <span class="n">_get_args</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
    <span class="n">ctx</span> <span class="o">=</span> <span class="n">_get_ctx</span><span class="p">(</span><span class="n">_ctx_from_ast_arg_list</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">ctx</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">z3_debug</span><span class="p">():</span>
        <span class="n">_z3_assert</span><span class="p">(</span><span class="n">ctx</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;At least one of the arguments must be a Z3 expression or probe&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">_has_probe</span><span class="p">(</span><span class="n">args</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">_probe_or</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">ctx</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">args</span> <span class="o">=</span> <span class="n">_coerce_expr_list</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">ctx</span><span class="p">)</span>
        <span class="n">_args</span><span class="p">,</span> <span class="n">sz</span> <span class="o">=</span> <span class="n">_to_ast_array</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">BoolRef</span><span class="p">(</span><span class="n">Z3_mk_or</span><span class="p">(</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="n">sz</span><span class="p">,</span> <span class="n">_args</span><span class="p">),</span> <span class="n">ctx</span><span class="p">)</span>

<span class="c1">#########################################</span>
<span class="c1">#</span>
<span class="c1"># Patterns</span>
<span class="c1">#</span>
<span class="c1">#########################################</span>


<span class="k">class</span> <span class="nc">PatternRef</span><span class="p">(</span><span class="n">ExprRef</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Patterns are hints for quantifier instantiation.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">as_ast</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Z3_pattern_to_ast</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx_ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">ast</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_id</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Z3_get_ast_id</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx_ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_ast</span><span class="p">())</span>


<span class="k">def</span> <span class="nf">is_pattern</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return `True` if `a` is a Z3 pattern (hint for quantifier instantiation.</span>

<span class="sd">    &gt;&gt;&gt; f = Function(&#39;f&#39;, IntSort(), IntSort())</span>
<span class="sd">    &gt;&gt;&gt; x = Int(&#39;x&#39;)</span>
<span class="sd">    &gt;&gt;&gt; q = ForAll(x, f(x) == 0, patterns = [ f(x) ])</span>
<span class="sd">    &gt;&gt;&gt; q</span>
<span class="sd">    ForAll(x, f(x) == 0)</span>
<span class="sd">    &gt;&gt;&gt; q.num_patterns()</span>
<span class="sd">    1</span>
<span class="sd">    &gt;&gt;&gt; is_pattern(q.pattern(0))</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; q.pattern(0)</span>
<span class="sd">    f(Var(0))</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">PatternRef</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">MultiPattern</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Create a Z3 multi-pattern using the given expressions `*args`</span>

<span class="sd">    &gt;&gt;&gt; f = Function(&#39;f&#39;, IntSort(), IntSort())</span>
<span class="sd">    &gt;&gt;&gt; g = Function(&#39;g&#39;, IntSort(), IntSort())</span>
<span class="sd">    &gt;&gt;&gt; x = Int(&#39;x&#39;)</span>
<span class="sd">    &gt;&gt;&gt; q = ForAll(x, f(x) != g(x), patterns = [ MultiPattern(f(x), g(x)) ])</span>
<span class="sd">    &gt;&gt;&gt; q</span>
<span class="sd">    ForAll(x, f(x) != g(x))</span>
<span class="sd">    &gt;&gt;&gt; q.num_patterns()</span>
<span class="sd">    1</span>
<span class="sd">    &gt;&gt;&gt; is_pattern(q.pattern(0))</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; q.pattern(0)</span>
<span class="sd">    MultiPattern(f(Var(0)), g(Var(0)))</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">z3_debug</span><span class="p">():</span>
        <span class="n">_z3_assert</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;At least one argument expected&quot;</span><span class="p">)</span>
        <span class="n">_z3_assert</span><span class="p">(</span><span class="nb">all</span><span class="p">([</span><span class="n">is_expr</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">args</span><span class="p">]),</span> <span class="s2">&quot;Z3 expressions expected&quot;</span><span class="p">)</span>
    <span class="n">ctx</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">ctx</span>
    <span class="n">args</span><span class="p">,</span> <span class="n">sz</span> <span class="o">=</span> <span class="n">_to_ast_array</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">PatternRef</span><span class="p">(</span><span class="n">Z3_mk_pattern</span><span class="p">(</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="n">sz</span><span class="p">,</span> <span class="n">args</span><span class="p">),</span> <span class="n">ctx</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_to_pattern</span><span class="p">(</span><span class="n">arg</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">is_pattern</span><span class="p">(</span><span class="n">arg</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">arg</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">MultiPattern</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>

<span class="c1">#########################################</span>
<span class="c1">#</span>
<span class="c1"># Quantifiers</span>
<span class="c1">#</span>
<span class="c1">#########################################</span>


<span class="k">class</span> <span class="nc">QuantifierRef</span><span class="p">(</span><span class="n">BoolRef</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Universally and Existentially quantified formulas.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">as_ast</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ast</span>

    <span class="k">def</span> <span class="nf">get_id</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Z3_get_ast_id</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx_ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_ast</span><span class="p">())</span>

    <span class="k">def</span> <span class="nf">sort</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the Boolean sort or sort of Lambda.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_lambda</span><span class="p">():</span>
            <span class="k">return</span> <span class="n">_sort</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_ast</span><span class="p">())</span>
        <span class="k">return</span> <span class="n">BoolSort</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">is_forall</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return `True` if `self` is a universal quantifier.</span>

<span class="sd">        &gt;&gt;&gt; f = Function(&#39;f&#39;, IntSort(), IntSort())</span>
<span class="sd">        &gt;&gt;&gt; x = Int(&#39;x&#39;)</span>
<span class="sd">        &gt;&gt;&gt; q = ForAll(x, f(x) == 0)</span>
<span class="sd">        &gt;&gt;&gt; q.is_forall()</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; q = Exists(x, f(x) != 0)</span>
<span class="sd">        &gt;&gt;&gt; q.is_forall()</span>
<span class="sd">        False</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Z3_is_quantifier_forall</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx_ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">ast</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">is_exists</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return `True` if `self` is an existential quantifier.</span>

<span class="sd">        &gt;&gt;&gt; f = Function(&#39;f&#39;, IntSort(), IntSort())</span>
<span class="sd">        &gt;&gt;&gt; x = Int(&#39;x&#39;)</span>
<span class="sd">        &gt;&gt;&gt; q = ForAll(x, f(x) == 0)</span>
<span class="sd">        &gt;&gt;&gt; q.is_exists()</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; q = Exists(x, f(x) != 0)</span>
<span class="sd">        &gt;&gt;&gt; q.is_exists()</span>
<span class="sd">        True</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Z3_is_quantifier_exists</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx_ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">ast</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">is_lambda</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return `True` if `self` is a lambda expression.</span>

<span class="sd">        &gt;&gt;&gt; f = Function(&#39;f&#39;, IntSort(), IntSort())</span>
<span class="sd">        &gt;&gt;&gt; x = Int(&#39;x&#39;)</span>
<span class="sd">        &gt;&gt;&gt; q = Lambda(x, f(x))</span>
<span class="sd">        &gt;&gt;&gt; q.is_lambda()</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; q = Exists(x, f(x) != 0)</span>
<span class="sd">        &gt;&gt;&gt; q.is_lambda()</span>
<span class="sd">        False</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Z3_is_lambda</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx_ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">ast</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arg</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the Z3 expression `self[arg]`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">z3_debug</span><span class="p">():</span>
            <span class="n">_z3_assert</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">is_lambda</span><span class="p">(),</span> <span class="s2">&quot;quantifier should be a lambda expression&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">_array_select</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arg</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">weight</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the weight annotation of `self`.</span>

<span class="sd">        &gt;&gt;&gt; f = Function(&#39;f&#39;, IntSort(), IntSort())</span>
<span class="sd">        &gt;&gt;&gt; x = Int(&#39;x&#39;)</span>
<span class="sd">        &gt;&gt;&gt; q = ForAll(x, f(x) == 0)</span>
<span class="sd">        &gt;&gt;&gt; q.weight()</span>
<span class="sd">        1</span>
<span class="sd">        &gt;&gt;&gt; q = ForAll(x, f(x) == 0, weight=10)</span>
<span class="sd">        &gt;&gt;&gt; q.weight()</span>
<span class="sd">        10</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">Z3_get_quantifier_weight</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx_ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">ast</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">skolem_id</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the skolem id of `self`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_symbol2py</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">,</span> <span class="n">Z3_get_quantifier_skolem_id</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx_ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">ast</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">qid</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the quantifier id of `self`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_symbol2py</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">,</span> <span class="n">Z3_get_quantifier_id</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx_ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">ast</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">num_patterns</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the number of patterns (i.e., quantifier instantiation hints) in `self`.</span>

<span class="sd">        &gt;&gt;&gt; f = Function(&#39;f&#39;, IntSort(), IntSort())</span>
<span class="sd">        &gt;&gt;&gt; g = Function(&#39;g&#39;, IntSort(), IntSort())</span>
<span class="sd">        &gt;&gt;&gt; x = Int(&#39;x&#39;)</span>
<span class="sd">        &gt;&gt;&gt; q = ForAll(x, f(x) != g(x), patterns = [ f(x), g(x) ])</span>
<span class="sd">        &gt;&gt;&gt; q.num_patterns()</span>
<span class="sd">        2</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">Z3_get_quantifier_num_patterns</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx_ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">ast</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">pattern</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a pattern (i.e., quantifier instantiation hints) in `self`.</span>

<span class="sd">        &gt;&gt;&gt; f = Function(&#39;f&#39;, IntSort(), IntSort())</span>
<span class="sd">        &gt;&gt;&gt; g = Function(&#39;g&#39;, IntSort(), IntSort())</span>
<span class="sd">        &gt;&gt;&gt; x = Int(&#39;x&#39;)</span>
<span class="sd">        &gt;&gt;&gt; q = ForAll(x, f(x) != g(x), patterns = [ f(x), g(x) ])</span>
<span class="sd">        &gt;&gt;&gt; q.num_patterns()</span>
<span class="sd">        2</span>
<span class="sd">        &gt;&gt;&gt; q.pattern(0)</span>
<span class="sd">        f(Var(0))</span>
<span class="sd">        &gt;&gt;&gt; q.pattern(1)</span>
<span class="sd">        g(Var(0))</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">z3_debug</span><span class="p">():</span>
            <span class="n">_z3_assert</span><span class="p">(</span><span class="n">idx</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_patterns</span><span class="p">(),</span> <span class="s2">&quot;Invalid pattern idx&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">PatternRef</span><span class="p">(</span><span class="n">Z3_get_quantifier_pattern_ast</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx_ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">ast</span><span class="p">,</span> <span class="n">idx</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">num_no_patterns</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the number of no-patterns.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Z3_get_quantifier_num_no_patterns</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx_ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">ast</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">no_pattern</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a no-pattern.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">z3_debug</span><span class="p">():</span>
            <span class="n">_z3_assert</span><span class="p">(</span><span class="n">idx</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_no_patterns</span><span class="p">(),</span> <span class="s2">&quot;Invalid no-pattern idx&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">_to_expr_ref</span><span class="p">(</span><span class="n">Z3_get_quantifier_no_pattern_ast</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx_ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">ast</span><span class="p">,</span> <span class="n">idx</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">body</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the expression being quantified.</span>

<span class="sd">        &gt;&gt;&gt; f = Function(&#39;f&#39;, IntSort(), IntSort())</span>
<span class="sd">        &gt;&gt;&gt; x = Int(&#39;x&#39;)</span>
<span class="sd">        &gt;&gt;&gt; q = ForAll(x, f(x) == 0)</span>
<span class="sd">        &gt;&gt;&gt; q.body()</span>
<span class="sd">        f(Var(0)) == 0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_to_expr_ref</span><span class="p">(</span><span class="n">Z3_get_quantifier_body</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx_ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">ast</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">num_vars</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the number of variables bounded by this quantifier.</span>

<span class="sd">        &gt;&gt;&gt; f = Function(&#39;f&#39;, IntSort(), IntSort(), IntSort())</span>
<span class="sd">        &gt;&gt;&gt; x = Int(&#39;x&#39;)</span>
<span class="sd">        &gt;&gt;&gt; y = Int(&#39;y&#39;)</span>
<span class="sd">        &gt;&gt;&gt; q = ForAll([x, y], f(x, y) &gt;= x)</span>
<span class="sd">        &gt;&gt;&gt; q.num_vars()</span>
<span class="sd">        2</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">Z3_get_quantifier_num_bound</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx_ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">ast</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">var_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a string representing a name used when displaying the quantifier.</span>

<span class="sd">        &gt;&gt;&gt; f = Function(&#39;f&#39;, IntSort(), IntSort(), IntSort())</span>
<span class="sd">        &gt;&gt;&gt; x = Int(&#39;x&#39;)</span>
<span class="sd">        &gt;&gt;&gt; y = Int(&#39;y&#39;)</span>
<span class="sd">        &gt;&gt;&gt; q = ForAll([x, y], f(x, y) &gt;= x)</span>
<span class="sd">        &gt;&gt;&gt; q.var_name(0)</span>
<span class="sd">        &#39;x&#39;</span>
<span class="sd">        &gt;&gt;&gt; q.var_name(1)</span>
<span class="sd">        &#39;y&#39;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">z3_debug</span><span class="p">():</span>
            <span class="n">_z3_assert</span><span class="p">(</span><span class="n">idx</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_vars</span><span class="p">(),</span> <span class="s2">&quot;Invalid variable idx&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">_symbol2py</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">,</span> <span class="n">Z3_get_quantifier_bound_name</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx_ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">ast</span><span class="p">,</span> <span class="n">idx</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">var_sort</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the sort of a bound variable.</span>

<span class="sd">        &gt;&gt;&gt; f = Function(&#39;f&#39;, IntSort(), RealSort(), IntSort())</span>
<span class="sd">        &gt;&gt;&gt; x = Int(&#39;x&#39;)</span>
<span class="sd">        &gt;&gt;&gt; y = Real(&#39;y&#39;)</span>
<span class="sd">        &gt;&gt;&gt; q = ForAll([x, y], f(x, y) &gt;= x)</span>
<span class="sd">        &gt;&gt;&gt; q.var_sort(0)</span>
<span class="sd">        Int</span>
<span class="sd">        &gt;&gt;&gt; q.var_sort(1)</span>
<span class="sd">        Real</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">z3_debug</span><span class="p">():</span>
            <span class="n">_z3_assert</span><span class="p">(</span><span class="n">idx</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_vars</span><span class="p">(),</span> <span class="s2">&quot;Invalid variable idx&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">_to_sort_ref</span><span class="p">(</span><span class="n">Z3_get_quantifier_bound_sort</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx_ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">ast</span><span class="p">,</span> <span class="n">idx</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">children</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a list containing a single element self.body()</span>

<span class="sd">        &gt;&gt;&gt; f = Function(&#39;f&#39;, IntSort(), IntSort())</span>
<span class="sd">        &gt;&gt;&gt; x = Int(&#39;x&#39;)</span>
<span class="sd">        &gt;&gt;&gt; q = ForAll(x, f(x) == 0)</span>
<span class="sd">        &gt;&gt;&gt; q.children()</span>
<span class="sd">        [f(Var(0)) == 0]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">body</span><span class="p">()]</span>


<span class="k">def</span> <span class="nf">is_quantifier</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return `True` if `a` is a Z3 quantifier.</span>

<span class="sd">    &gt;&gt;&gt; f = Function(&#39;f&#39;, IntSort(), IntSort())</span>
<span class="sd">    &gt;&gt;&gt; x = Int(&#39;x&#39;)</span>
<span class="sd">    &gt;&gt;&gt; q = ForAll(x, f(x) == 0)</span>
<span class="sd">    &gt;&gt;&gt; is_quantifier(q)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; is_quantifier(f(x))</span>
<span class="sd">    False</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">QuantifierRef</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_mk_quantifier</span><span class="p">(</span><span class="n">is_forall</span><span class="p">,</span> <span class="n">vs</span><span class="p">,</span> <span class="n">body</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">qid</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">skid</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">patterns</span><span class="o">=</span><span class="p">[],</span> <span class="n">no_patterns</span><span class="o">=</span><span class="p">[]):</span>
    <span class="k">if</span> <span class="n">z3_debug</span><span class="p">():</span>
        <span class="n">_z3_assert</span><span class="p">(</span><span class="n">is_bool</span><span class="p">(</span><span class="n">body</span><span class="p">)</span> <span class="ow">or</span> <span class="n">is_app</span><span class="p">(</span><span class="n">vs</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">vs</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">is_app</span><span class="p">(</span><span class="n">vs</span><span class="p">[</span><span class="mi">0</span><span class="p">])),</span> <span class="s2">&quot;Z3 expression expected&quot;</span><span class="p">)</span>
        <span class="n">_z3_assert</span><span class="p">(</span><span class="n">is_const</span><span class="p">(</span><span class="n">vs</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">vs</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="nb">all</span><span class="p">([</span><span class="n">is_const</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">vs</span><span class="p">])),</span> <span class="s2">&quot;Invalid bounded variable(s)&quot;</span><span class="p">)</span>
        <span class="n">_z3_assert</span><span class="p">(</span><span class="nb">all</span><span class="p">([</span><span class="n">is_pattern</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="ow">or</span> <span class="n">is_expr</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">patterns</span><span class="p">]),</span> <span class="s2">&quot;Z3 patterns expected&quot;</span><span class="p">)</span>
        <span class="n">_z3_assert</span><span class="p">(</span><span class="nb">all</span><span class="p">([</span><span class="n">is_expr</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">no_patterns</span><span class="p">]),</span> <span class="s2">&quot;no patterns are Z3 expressions&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">is_app</span><span class="p">(</span><span class="n">vs</span><span class="p">):</span>
        <span class="n">ctx</span> <span class="o">=</span> <span class="n">vs</span><span class="o">.</span><span class="n">ctx</span>
        <span class="n">vs</span> <span class="o">=</span> <span class="p">[</span><span class="n">vs</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">ctx</span> <span class="o">=</span> <span class="n">vs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">ctx</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">is_expr</span><span class="p">(</span><span class="n">body</span><span class="p">):</span>
        <span class="n">body</span> <span class="o">=</span> <span class="n">BoolVal</span><span class="p">(</span><span class="n">body</span><span class="p">,</span> <span class="n">ctx</span><span class="p">)</span>
    <span class="n">num_vars</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">vs</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">num_vars</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">body</span>
    <span class="n">_vs</span> <span class="o">=</span> <span class="p">(</span><span class="n">Ast</span> <span class="o">*</span> <span class="n">num_vars</span><span class="p">)()</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_vars</span><span class="p">):</span>
        <span class="c1"># TODO: Check if is constant</span>
        <span class="n">_vs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">vs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">as_ast</span><span class="p">()</span>
    <span class="n">patterns</span> <span class="o">=</span> <span class="p">[</span><span class="n">_to_pattern</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">patterns</span><span class="p">]</span>
    <span class="n">num_pats</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">patterns</span><span class="p">)</span>
    <span class="n">_pats</span> <span class="o">=</span> <span class="p">(</span><span class="n">Pattern</span> <span class="o">*</span> <span class="n">num_pats</span><span class="p">)()</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_pats</span><span class="p">):</span>
        <span class="n">_pats</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">patterns</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">ast</span>
    <span class="n">_no_pats</span><span class="p">,</span> <span class="n">num_no_pats</span> <span class="o">=</span> <span class="n">_to_ast_array</span><span class="p">(</span><span class="n">no_patterns</span><span class="p">)</span>
    <span class="n">qid</span> <span class="o">=</span> <span class="n">to_symbol</span><span class="p">(</span><span class="n">qid</span><span class="p">,</span> <span class="n">ctx</span><span class="p">)</span>
    <span class="n">skid</span> <span class="o">=</span> <span class="n">to_symbol</span><span class="p">(</span><span class="n">skid</span><span class="p">,</span> <span class="n">ctx</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">QuantifierRef</span><span class="p">(</span><span class="n">Z3_mk_quantifier_const_ex</span><span class="p">(</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="n">is_forall</span><span class="p">,</span> <span class="n">weight</span><span class="p">,</span> <span class="n">qid</span><span class="p">,</span> <span class="n">skid</span><span class="p">,</span>
                                                   <span class="n">num_vars</span><span class="p">,</span> <span class="n">_vs</span><span class="p">,</span>
                                                   <span class="n">num_pats</span><span class="p">,</span> <span class="n">_pats</span><span class="p">,</span>
                                                   <span class="n">num_no_pats</span><span class="p">,</span> <span class="n">_no_pats</span><span class="p">,</span>
                                                   <span class="n">body</span><span class="o">.</span><span class="n">as_ast</span><span class="p">()),</span> <span class="n">ctx</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">ForAll</span><span class="p">(</span><span class="n">vs</span><span class="p">,</span> <span class="n">body</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">qid</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">skid</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">patterns</span><span class="o">=</span><span class="p">[],</span> <span class="n">no_patterns</span><span class="o">=</span><span class="p">[]):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Create a Z3 forall formula.</span>

<span class="sd">    The parameters `weight`, `qid`, `skid`, `patterns` and `no_patterns` are optional annotations.</span>

<span class="sd">    &gt;&gt;&gt; f = Function(&#39;f&#39;, IntSort(), IntSort(), IntSort())</span>
<span class="sd">    &gt;&gt;&gt; x = Int(&#39;x&#39;)</span>
<span class="sd">    &gt;&gt;&gt; y = Int(&#39;y&#39;)</span>
<span class="sd">    &gt;&gt;&gt; ForAll([x, y], f(x, y) &gt;= x)</span>
<span class="sd">    ForAll([x, y], f(x, y) &gt;= x)</span>
<span class="sd">    &gt;&gt;&gt; ForAll([x, y], f(x, y) &gt;= x, patterns=[ f(x, y) ])</span>
<span class="sd">    ForAll([x, y], f(x, y) &gt;= x)</span>
<span class="sd">    &gt;&gt;&gt; ForAll([x, y], f(x, y) &gt;= x, weight=10)</span>
<span class="sd">    ForAll([x, y], f(x, y) &gt;= x)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_mk_quantifier</span><span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="n">vs</span><span class="p">,</span> <span class="n">body</span><span class="p">,</span> <span class="n">weight</span><span class="p">,</span> <span class="n">qid</span><span class="p">,</span> <span class="n">skid</span><span class="p">,</span> <span class="n">patterns</span><span class="p">,</span> <span class="n">no_patterns</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">Exists</span><span class="p">(</span><span class="n">vs</span><span class="p">,</span> <span class="n">body</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">qid</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">skid</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">patterns</span><span class="o">=</span><span class="p">[],</span> <span class="n">no_patterns</span><span class="o">=</span><span class="p">[]):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Create a Z3 exists formula.</span>

<span class="sd">    The parameters `weight`, `qif`, `skid`, `patterns` and `no_patterns` are optional annotations.</span>


<span class="sd">    &gt;&gt;&gt; f = Function(&#39;f&#39;, IntSort(), IntSort(), IntSort())</span>
<span class="sd">    &gt;&gt;&gt; x = Int(&#39;x&#39;)</span>
<span class="sd">    &gt;&gt;&gt; y = Int(&#39;y&#39;)</span>
<span class="sd">    &gt;&gt;&gt; q = Exists([x, y], f(x, y) &gt;= x, skid=&quot;foo&quot;)</span>
<span class="sd">    &gt;&gt;&gt; q</span>
<span class="sd">    Exists([x, y], f(x, y) &gt;= x)</span>
<span class="sd">    &gt;&gt;&gt; is_quantifier(q)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; r = Tactic(&#39;nnf&#39;)(q).as_expr()</span>
<span class="sd">    &gt;&gt;&gt; is_quantifier(r)</span>
<span class="sd">    False</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_mk_quantifier</span><span class="p">(</span><span class="kc">False</span><span class="p">,</span> <span class="n">vs</span><span class="p">,</span> <span class="n">body</span><span class="p">,</span> <span class="n">weight</span><span class="p">,</span> <span class="n">qid</span><span class="p">,</span> <span class="n">skid</span><span class="p">,</span> <span class="n">patterns</span><span class="p">,</span> <span class="n">no_patterns</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">Lambda</span><span class="p">(</span><span class="n">vs</span><span class="p">,</span> <span class="n">body</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Create a Z3 lambda expression.</span>

<span class="sd">    &gt;&gt;&gt; f = Function(&#39;f&#39;, IntSort(), IntSort(), IntSort())</span>
<span class="sd">    &gt;&gt;&gt; mem0 = Array(&#39;mem0&#39;, IntSort(), IntSort())</span>
<span class="sd">    &gt;&gt;&gt; lo, hi, e, i = Ints(&#39;lo hi e i&#39;)</span>
<span class="sd">    &gt;&gt;&gt; mem1 = Lambda([i], If(And(lo &lt;= i, i &lt;= hi), e, mem0[i]))</span>
<span class="sd">    &gt;&gt;&gt; mem1</span>
<span class="sd">    Lambda(i, If(And(lo &lt;= i, i &lt;= hi), e, mem0[i]))</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ctx</span> <span class="o">=</span> <span class="n">body</span><span class="o">.</span><span class="n">ctx</span>
    <span class="k">if</span> <span class="n">is_app</span><span class="p">(</span><span class="n">vs</span><span class="p">):</span>
        <span class="n">vs</span> <span class="o">=</span> <span class="p">[</span><span class="n">vs</span><span class="p">]</span>
    <span class="n">num_vars</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">vs</span><span class="p">)</span>
    <span class="n">_vs</span> <span class="o">=</span> <span class="p">(</span><span class="n">Ast</span> <span class="o">*</span> <span class="n">num_vars</span><span class="p">)()</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_vars</span><span class="p">):</span>
        <span class="c1"># TODO: Check if is constant</span>
        <span class="n">_vs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">vs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">as_ast</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">QuantifierRef</span><span class="p">(</span><span class="n">Z3_mk_lambda_const</span><span class="p">(</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="n">num_vars</span><span class="p">,</span> <span class="n">_vs</span><span class="p">,</span> <span class="n">body</span><span class="o">.</span><span class="n">as_ast</span><span class="p">()),</span> <span class="n">ctx</span><span class="p">)</span>

<span class="c1">#########################################</span>
<span class="c1">#</span>
<span class="c1"># Arithmetic</span>
<span class="c1">#</span>
<span class="c1">#########################################</span>


<span class="k">class</span> <span class="nc">ArithSortRef</span><span class="p">(</span><span class="n">SortRef</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Real and Integer sorts.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">is_real</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return `True` if `self` is of the sort Real.</span>

<span class="sd">        &gt;&gt;&gt; x = Real(&#39;x&#39;)</span>
<span class="sd">        &gt;&gt;&gt; x.is_real()</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; (x + 1).is_real()</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; x = Int(&#39;x&#39;)</span>
<span class="sd">        &gt;&gt;&gt; x.is_real()</span>
<span class="sd">        False</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">kind</span><span class="p">()</span> <span class="o">==</span> <span class="n">Z3_REAL_SORT</span>

    <span class="k">def</span> <span class="nf">is_int</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return `True` if `self` is of the sort Integer.</span>

<span class="sd">        &gt;&gt;&gt; x = Int(&#39;x&#39;)</span>
<span class="sd">        &gt;&gt;&gt; x.is_int()</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; (x + 1).is_int()</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; x = Real(&#39;x&#39;)</span>
<span class="sd">        &gt;&gt;&gt; x.is_int()</span>
<span class="sd">        False</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">kind</span><span class="p">()</span> <span class="o">==</span> <span class="n">Z3_INT_SORT</span>

    <span class="k">def</span> <span class="nf">is_bool</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">subsort</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return `True` if `self` is a subsort of `other`.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_int</span><span class="p">()</span> <span class="ow">and</span> <span class="n">is_arith_sort</span><span class="p">(</span><span class="n">other</span><span class="p">)</span> <span class="ow">and</span> <span class="n">other</span><span class="o">.</span><span class="n">is_real</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">cast</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Try to cast `val` as an Integer or Real.</span>

<span class="sd">        &gt;&gt;&gt; IntSort().cast(10)</span>
<span class="sd">        10</span>
<span class="sd">        &gt;&gt;&gt; is_int(IntSort().cast(10))</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; is_int(10)</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; RealSort().cast(10)</span>
<span class="sd">        10</span>
<span class="sd">        &gt;&gt;&gt; is_real(RealSort().cast(10))</span>
<span class="sd">        True</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">is_expr</span><span class="p">(</span><span class="n">val</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">z3_debug</span><span class="p">():</span>
                <span class="n">_z3_assert</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span> <span class="o">==</span> <span class="n">val</span><span class="o">.</span><span class="n">ctx</span><span class="p">,</span> <span class="s2">&quot;Context mismatch&quot;</span><span class="p">)</span>
            <span class="n">val_s</span> <span class="o">=</span> <span class="n">val</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">eq</span><span class="p">(</span><span class="n">val_s</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">val</span>
            <span class="k">if</span> <span class="n">val_s</span><span class="o">.</span><span class="n">is_int</span><span class="p">()</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_real</span><span class="p">():</span>
                <span class="k">return</span> <span class="n">ToReal</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">val_s</span><span class="o">.</span><span class="n">is_bool</span><span class="p">()</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_int</span><span class="p">():</span>
                <span class="k">return</span> <span class="n">If</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">val_s</span><span class="o">.</span><span class="n">is_bool</span><span class="p">()</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_real</span><span class="p">():</span>
                <span class="k">return</span> <span class="n">ToReal</span><span class="p">(</span><span class="n">If</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">z3_debug</span><span class="p">():</span>
                <span class="n">_z3_assert</span><span class="p">(</span><span class="kc">False</span><span class="p">,</span> <span class="s2">&quot;Z3 Integer/Real expression expected&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_int</span><span class="p">():</span>
                <span class="k">return</span> <span class="n">IntVal</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_real</span><span class="p">():</span>
                <span class="k">return</span> <span class="n">RealVal</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">z3_debug</span><span class="p">():</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;int, long, float, string (numeral), or Z3 Integer/Real expression expected. Got </span><span class="si">%s</span><span class="s2">&quot;</span>
                <span class="n">_z3_assert</span><span class="p">(</span><span class="kc">False</span><span class="p">,</span> <span class="n">msg</span> <span class="o">%</span> <span class="bp">self</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">is_arith_sort</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return `True` if s is an arithmetical sort (type).</span>

<span class="sd">    &gt;&gt;&gt; is_arith_sort(IntSort())</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; is_arith_sort(RealSort())</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; is_arith_sort(BoolSort())</span>
<span class="sd">    False</span>
<span class="sd">    &gt;&gt;&gt; n = Int(&#39;x&#39;) + 1</span>
<span class="sd">    &gt;&gt;&gt; is_arith_sort(n.sort())</span>
<span class="sd">    True</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">ArithSortRef</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">ArithRef</span><span class="p">(</span><span class="n">ExprRef</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Integer and Real expressions.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">sort</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the sort (type) of the arithmetical expression `self`.</span>

<span class="sd">        &gt;&gt;&gt; Int(&#39;x&#39;).sort()</span>
<span class="sd">        Int</span>
<span class="sd">        &gt;&gt;&gt; (Real(&#39;x&#39;) + 1).sort()</span>
<span class="sd">        Real</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">ArithSortRef</span><span class="p">(</span><span class="n">Z3_get_sort</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx_ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_ast</span><span class="p">()),</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">is_int</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return `True` if `self` is an integer expression.</span>

<span class="sd">        &gt;&gt;&gt; x = Int(&#39;x&#39;)</span>
<span class="sd">        &gt;&gt;&gt; x.is_int()</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; (x + 1).is_int()</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; y = Real(&#39;y&#39;)</span>
<span class="sd">        &gt;&gt;&gt; (x + y).is_int()</span>
<span class="sd">        False</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span><span class="o">.</span><span class="n">is_int</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">is_real</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return `True` if `self` is an real expression.</span>

<span class="sd">        &gt;&gt;&gt; x = Real(&#39;x&#39;)</span>
<span class="sd">        &gt;&gt;&gt; x.is_real()</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; (x + 1).is_real()</span>
<span class="sd">        True</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span><span class="o">.</span><span class="n">is_real</span><span class="p">()</span>

    <span class="k">def</span> <span class="fm">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create the Z3 expression `self + other`.</span>

<span class="sd">        &gt;&gt;&gt; x = Int(&#39;x&#39;)</span>
<span class="sd">        &gt;&gt;&gt; y = Int(&#39;y&#39;)</span>
<span class="sd">        &gt;&gt;&gt; x + y</span>
<span class="sd">        x + y</span>
<span class="sd">        &gt;&gt;&gt; (x + y).sort()</span>
<span class="sd">        Int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">_coerce_exprs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ArithRef</span><span class="p">(</span><span class="n">_mk_bin</span><span class="p">(</span><span class="n">Z3_mk_add</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__radd__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create the Z3 expression `other + self`.</span>

<span class="sd">        &gt;&gt;&gt; x = Int(&#39;x&#39;)</span>
<span class="sd">        &gt;&gt;&gt; 10 + x</span>
<span class="sd">        10 + x</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">_coerce_exprs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ArithRef</span><span class="p">(</span><span class="n">_mk_bin</span><span class="p">(</span><span class="n">Z3_mk_add</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__mul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create the Z3 expression `self * other`.</span>

<span class="sd">        &gt;&gt;&gt; x = Real(&#39;x&#39;)</span>
<span class="sd">        &gt;&gt;&gt; y = Real(&#39;y&#39;)</span>
<span class="sd">        &gt;&gt;&gt; x * y</span>
<span class="sd">        x*y</span>
<span class="sd">        &gt;&gt;&gt; (x * y).sort()</span>
<span class="sd">        Real</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">BoolRef</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">If</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">_coerce_exprs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ArithRef</span><span class="p">(</span><span class="n">_mk_bin</span><span class="p">(</span><span class="n">Z3_mk_mul</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__rmul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create the Z3 expression `other * self`.</span>

<span class="sd">        &gt;&gt;&gt; x = Real(&#39;x&#39;)</span>
<span class="sd">        &gt;&gt;&gt; 10 * x</span>
<span class="sd">        10*x</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">_coerce_exprs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ArithRef</span><span class="p">(</span><span class="n">_mk_bin</span><span class="p">(</span><span class="n">Z3_mk_mul</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__sub__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create the Z3 expression `self - other`.</span>

<span class="sd">        &gt;&gt;&gt; x = Int(&#39;x&#39;)</span>
<span class="sd">        &gt;&gt;&gt; y = Int(&#39;y&#39;)</span>
<span class="sd">        &gt;&gt;&gt; x - y</span>
<span class="sd">        x - y</span>
<span class="sd">        &gt;&gt;&gt; (x - y).sort()</span>
<span class="sd">        Int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">_coerce_exprs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ArithRef</span><span class="p">(</span><span class="n">_mk_bin</span><span class="p">(</span><span class="n">Z3_mk_sub</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__rsub__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create the Z3 expression `other - self`.</span>

<span class="sd">        &gt;&gt;&gt; x = Int(&#39;x&#39;)</span>
<span class="sd">        &gt;&gt;&gt; 10 - x</span>
<span class="sd">        10 - x</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">_coerce_exprs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ArithRef</span><span class="p">(</span><span class="n">_mk_bin</span><span class="p">(</span><span class="n">Z3_mk_sub</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__pow__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create the Z3 expression `self**other` (** is the power operator).</span>

<span class="sd">        &gt;&gt;&gt; x = Real(&#39;x&#39;)</span>
<span class="sd">        &gt;&gt;&gt; x**3</span>
<span class="sd">        x**3</span>
<span class="sd">        &gt;&gt;&gt; (x**3).sort()</span>
<span class="sd">        Real</span>
<span class="sd">        &gt;&gt;&gt; simplify(IntVal(2)**8)</span>
<span class="sd">        256</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">_coerce_exprs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ArithRef</span><span class="p">(</span><span class="n">Z3_mk_power</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx_ref</span><span class="p">(),</span> <span class="n">a</span><span class="o">.</span><span class="n">as_ast</span><span class="p">(),</span> <span class="n">b</span><span class="o">.</span><span class="n">as_ast</span><span class="p">()),</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__rpow__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create the Z3 expression `other**self` (** is the power operator).</span>

<span class="sd">        &gt;&gt;&gt; x = Real(&#39;x&#39;)</span>
<span class="sd">        &gt;&gt;&gt; 2**x</span>
<span class="sd">        2**x</span>
<span class="sd">        &gt;&gt;&gt; (2**x).sort()</span>
<span class="sd">        Real</span>
<span class="sd">        &gt;&gt;&gt; simplify(2**IntVal(8))</span>
<span class="sd">        256</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">_coerce_exprs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ArithRef</span><span class="p">(</span><span class="n">Z3_mk_power</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx_ref</span><span class="p">(),</span> <span class="n">b</span><span class="o">.</span><span class="n">as_ast</span><span class="p">(),</span> <span class="n">a</span><span class="o">.</span><span class="n">as_ast</span><span class="p">()),</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__div__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create the Z3 expression `other/self`.</span>

<span class="sd">        &gt;&gt;&gt; x = Int(&#39;x&#39;)</span>
<span class="sd">        &gt;&gt;&gt; y = Int(&#39;y&#39;)</span>
<span class="sd">        &gt;&gt;&gt; x/y</span>
<span class="sd">        x/y</span>
<span class="sd">        &gt;&gt;&gt; (x/y).sort()</span>
<span class="sd">        Int</span>
<span class="sd">        &gt;&gt;&gt; (x/y).sexpr()</span>
<span class="sd">        &#39;(div x y)&#39;</span>
<span class="sd">        &gt;&gt;&gt; x = Real(&#39;x&#39;)</span>
<span class="sd">        &gt;&gt;&gt; y = Real(&#39;y&#39;)</span>
<span class="sd">        &gt;&gt;&gt; x/y</span>
<span class="sd">        x/y</span>
<span class="sd">        &gt;&gt;&gt; (x/y).sort()</span>
<span class="sd">        Real</span>
<span class="sd">        &gt;&gt;&gt; (x/y).sexpr()</span>
<span class="sd">        &#39;(/ x y)&#39;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">_coerce_exprs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ArithRef</span><span class="p">(</span><span class="n">Z3_mk_div</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx_ref</span><span class="p">(),</span> <span class="n">a</span><span class="o">.</span><span class="n">as_ast</span><span class="p">(),</span> <span class="n">b</span><span class="o">.</span><span class="n">as_ast</span><span class="p">()),</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__truediv__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create the Z3 expression `other/self`.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__div__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__rdiv__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create the Z3 expression `other/self`.</span>

<span class="sd">        &gt;&gt;&gt; x = Int(&#39;x&#39;)</span>
<span class="sd">        &gt;&gt;&gt; 10/x</span>
<span class="sd">        10/x</span>
<span class="sd">        &gt;&gt;&gt; (10/x).sexpr()</span>
<span class="sd">        &#39;(div 10 x)&#39;</span>
<span class="sd">        &gt;&gt;&gt; x = Real(&#39;x&#39;)</span>
<span class="sd">        &gt;&gt;&gt; 10/x</span>
<span class="sd">        10/x</span>
<span class="sd">        &gt;&gt;&gt; (10/x).sexpr()</span>
<span class="sd">        &#39;(/ 10.0 x)&#39;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">_coerce_exprs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ArithRef</span><span class="p">(</span><span class="n">Z3_mk_div</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx_ref</span><span class="p">(),</span> <span class="n">b</span><span class="o">.</span><span class="n">as_ast</span><span class="p">(),</span> <span class="n">a</span><span class="o">.</span><span class="n">as_ast</span><span class="p">()),</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__rtruediv__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create the Z3 expression `other/self`.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__rdiv__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__mod__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create the Z3 expression `other%self`.</span>

<span class="sd">        &gt;&gt;&gt; x = Int(&#39;x&#39;)</span>
<span class="sd">        &gt;&gt;&gt; y = Int(&#39;y&#39;)</span>
<span class="sd">        &gt;&gt;&gt; x % y</span>
<span class="sd">        x%y</span>
<span class="sd">        &gt;&gt;&gt; simplify(IntVal(10) % IntVal(3))</span>
<span class="sd">        1</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">_coerce_exprs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">z3_debug</span><span class="p">():</span>
            <span class="n">_z3_assert</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">is_int</span><span class="p">(),</span> <span class="s2">&quot;Z3 integer expression expected&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ArithRef</span><span class="p">(</span><span class="n">Z3_mk_mod</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx_ref</span><span class="p">(),</span> <span class="n">a</span><span class="o">.</span><span class="n">as_ast</span><span class="p">(),</span> <span class="n">b</span><span class="o">.</span><span class="n">as_ast</span><span class="p">()),</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__rmod__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create the Z3 expression `other%self`.</span>

<span class="sd">        &gt;&gt;&gt; x = Int(&#39;x&#39;)</span>
<span class="sd">        &gt;&gt;&gt; 10 % x</span>
<span class="sd">        10%x</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">_coerce_exprs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">z3_debug</span><span class="p">():</span>
            <span class="n">_z3_assert</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">is_int</span><span class="p">(),</span> <span class="s2">&quot;Z3 integer expression expected&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ArithRef</span><span class="p">(</span><span class="n">Z3_mk_mod</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx_ref</span><span class="p">(),</span> <span class="n">b</span><span class="o">.</span><span class="n">as_ast</span><span class="p">(),</span> <span class="n">a</span><span class="o">.</span><span class="n">as_ast</span><span class="p">()),</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__neg__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return an expression representing `-self`.</span>

<span class="sd">        &gt;&gt;&gt; x = Int(&#39;x&#39;)</span>
<span class="sd">        &gt;&gt;&gt; -x</span>
<span class="sd">        -x</span>
<span class="sd">        &gt;&gt;&gt; simplify(-(-x))</span>
<span class="sd">        x</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">ArithRef</span><span class="p">(</span><span class="n">Z3_mk_unary_minus</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx_ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_ast</span><span class="p">()),</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__pos__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return `self`.</span>

<span class="sd">        &gt;&gt;&gt; x = Int(&#39;x&#39;)</span>
<span class="sd">        &gt;&gt;&gt; +x</span>
<span class="sd">        x</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="fm">__le__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create the Z3 expression `other &lt;= self`.</span>

<span class="sd">        &gt;&gt;&gt; x, y = Ints(&#39;x y&#39;)</span>
<span class="sd">        &gt;&gt;&gt; x &lt;= y</span>
<span class="sd">        x &lt;= y</span>
<span class="sd">        &gt;&gt;&gt; y = Real(&#39;y&#39;)</span>
<span class="sd">        &gt;&gt;&gt; x &lt;= y</span>
<span class="sd">        ToReal(x) &lt;= y</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">_coerce_exprs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">BoolRef</span><span class="p">(</span><span class="n">Z3_mk_le</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx_ref</span><span class="p">(),</span> <span class="n">a</span><span class="o">.</span><span class="n">as_ast</span><span class="p">(),</span> <span class="n">b</span><span class="o">.</span><span class="n">as_ast</span><span class="p">()),</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__lt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create the Z3 expression `other &lt; self`.</span>

<span class="sd">        &gt;&gt;&gt; x, y = Ints(&#39;x y&#39;)</span>
<span class="sd">        &gt;&gt;&gt; x &lt; y</span>
<span class="sd">        x &lt; y</span>
<span class="sd">        &gt;&gt;&gt; y = Real(&#39;y&#39;)</span>
<span class="sd">        &gt;&gt;&gt; x &lt; y</span>
<span class="sd">        ToReal(x) &lt; y</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">_coerce_exprs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">BoolRef</span><span class="p">(</span><span class="n">Z3_mk_lt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx_ref</span><span class="p">(),</span> <span class="n">a</span><span class="o">.</span><span class="n">as_ast</span><span class="p">(),</span> <span class="n">b</span><span class="o">.</span><span class="n">as_ast</span><span class="p">()),</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__gt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create the Z3 expression `other &gt; self`.</span>

<span class="sd">        &gt;&gt;&gt; x, y = Ints(&#39;x y&#39;)</span>
<span class="sd">        &gt;&gt;&gt; x &gt; y</span>
<span class="sd">        x &gt; y</span>
<span class="sd">        &gt;&gt;&gt; y = Real(&#39;y&#39;)</span>
<span class="sd">        &gt;&gt;&gt; x &gt; y</span>
<span class="sd">        ToReal(x) &gt; y</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">_coerce_exprs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">BoolRef</span><span class="p">(</span><span class="n">Z3_mk_gt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx_ref</span><span class="p">(),</span> <span class="n">a</span><span class="o">.</span><span class="n">as_ast</span><span class="p">(),</span> <span class="n">b</span><span class="o">.</span><span class="n">as_ast</span><span class="p">()),</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__ge__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create the Z3 expression `other &gt;= self`.</span>

<span class="sd">        &gt;&gt;&gt; x, y = Ints(&#39;x y&#39;)</span>
<span class="sd">        &gt;&gt;&gt; x &gt;= y</span>
<span class="sd">        x &gt;= y</span>
<span class="sd">        &gt;&gt;&gt; y = Real(&#39;y&#39;)</span>
<span class="sd">        &gt;&gt;&gt; x &gt;= y</span>
<span class="sd">        ToReal(x) &gt;= y</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">_coerce_exprs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">BoolRef</span><span class="p">(</span><span class="n">Z3_mk_ge</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx_ref</span><span class="p">(),</span> <span class="n">a</span><span class="o">.</span><span class="n">as_ast</span><span class="p">(),</span> <span class="n">b</span><span class="o">.</span><span class="n">as_ast</span><span class="p">()),</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">is_arith</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return `True` if `a` is an arithmetical expression.</span>

<span class="sd">    &gt;&gt;&gt; x = Int(&#39;x&#39;)</span>
<span class="sd">    &gt;&gt;&gt; is_arith(x)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; is_arith(x + 1)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; is_arith(1)</span>
<span class="sd">    False</span>
<span class="sd">    &gt;&gt;&gt; is_arith(IntVal(1))</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; y = Real(&#39;y&#39;)</span>
<span class="sd">    &gt;&gt;&gt; is_arith(y)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; is_arith(y + 1)</span>
<span class="sd">    True</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">ArithRef</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">is_int</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return `True` if `a` is an integer expression.</span>

<span class="sd">    &gt;&gt;&gt; x = Int(&#39;x&#39;)</span>
<span class="sd">    &gt;&gt;&gt; is_int(x + 1)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; is_int(1)</span>
<span class="sd">    False</span>
<span class="sd">    &gt;&gt;&gt; is_int(IntVal(1))</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; y = Real(&#39;y&#39;)</span>
<span class="sd">    &gt;&gt;&gt; is_int(y)</span>
<span class="sd">    False</span>
<span class="sd">    &gt;&gt;&gt; is_int(y + 1)</span>
<span class="sd">    False</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">is_arith</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="ow">and</span> <span class="n">a</span><span class="o">.</span><span class="n">is_int</span><span class="p">()</span>


<span class="k">def</span> <span class="nf">is_real</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return `True` if `a` is a real expression.</span>

<span class="sd">    &gt;&gt;&gt; x = Int(&#39;x&#39;)</span>
<span class="sd">    &gt;&gt;&gt; is_real(x + 1)</span>
<span class="sd">    False</span>
<span class="sd">    &gt;&gt;&gt; y = Real(&#39;y&#39;)</span>
<span class="sd">    &gt;&gt;&gt; is_real(y)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; is_real(y + 1)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; is_real(1)</span>
<span class="sd">    False</span>
<span class="sd">    &gt;&gt;&gt; is_real(RealVal(1))</span>
<span class="sd">    True</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">is_arith</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="ow">and</span> <span class="n">a</span><span class="o">.</span><span class="n">is_real</span><span class="p">()</span>


<span class="k">def</span> <span class="nf">_is_numeral</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">a</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">Z3_is_numeral_ast</span><span class="p">(</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="n">a</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_is_algebraic</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">a</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">Z3_is_algebraic_number</span><span class="p">(</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="n">a</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">is_int_value</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return `True` if `a` is an integer value of sort Int.</span>

<span class="sd">    &gt;&gt;&gt; is_int_value(IntVal(1))</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; is_int_value(1)</span>
<span class="sd">    False</span>
<span class="sd">    &gt;&gt;&gt; is_int_value(Int(&#39;x&#39;))</span>
<span class="sd">    False</span>
<span class="sd">    &gt;&gt;&gt; n = Int(&#39;x&#39;) + 1</span>
<span class="sd">    &gt;&gt;&gt; n</span>
<span class="sd">    x + 1</span>
<span class="sd">    &gt;&gt;&gt; n.arg(1)</span>
<span class="sd">    1</span>
<span class="sd">    &gt;&gt;&gt; is_int_value(n.arg(1))</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; is_int_value(RealVal(&quot;1/3&quot;))</span>
<span class="sd">    False</span>
<span class="sd">    &gt;&gt;&gt; is_int_value(RealVal(1))</span>
<span class="sd">    False</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">is_arith</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="ow">and</span> <span class="n">a</span><span class="o">.</span><span class="n">is_int</span><span class="p">()</span> <span class="ow">and</span> <span class="n">_is_numeral</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">ctx</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">as_ast</span><span class="p">())</span>


<span class="k">def</span> <span class="nf">is_rational_value</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return `True` if `a` is rational value of sort Real.</span>

<span class="sd">    &gt;&gt;&gt; is_rational_value(RealVal(1))</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; is_rational_value(RealVal(&quot;3/5&quot;))</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; is_rational_value(IntVal(1))</span>
<span class="sd">    False</span>
<span class="sd">    &gt;&gt;&gt; is_rational_value(1)</span>
<span class="sd">    False</span>
<span class="sd">    &gt;&gt;&gt; n = Real(&#39;x&#39;) + 1</span>
<span class="sd">    &gt;&gt;&gt; n.arg(1)</span>
<span class="sd">    1</span>
<span class="sd">    &gt;&gt;&gt; is_rational_value(n.arg(1))</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; is_rational_value(Real(&#39;x&#39;))</span>
<span class="sd">    False</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">is_arith</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="ow">and</span> <span class="n">a</span><span class="o">.</span><span class="n">is_real</span><span class="p">()</span> <span class="ow">and</span> <span class="n">_is_numeral</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">ctx</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">as_ast</span><span class="p">())</span>


<span class="k">def</span> <span class="nf">is_algebraic_value</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return `True` if `a` is an algebraic value of sort Real.</span>

<span class="sd">    &gt;&gt;&gt; is_algebraic_value(RealVal(&quot;3/5&quot;))</span>
<span class="sd">    False</span>
<span class="sd">    &gt;&gt;&gt; n = simplify(Sqrt(2))</span>
<span class="sd">    &gt;&gt;&gt; n</span>
<span class="sd">    1.4142135623?</span>
<span class="sd">    &gt;&gt;&gt; is_algebraic_value(n)</span>
<span class="sd">    True</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">is_arith</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="ow">and</span> <span class="n">a</span><span class="o">.</span><span class="n">is_real</span><span class="p">()</span> <span class="ow">and</span> <span class="n">_is_algebraic</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">ctx</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">as_ast</span><span class="p">())</span>


<span class="k">def</span> <span class="nf">is_add</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return `True` if `a` is an expression of the form b + c.</span>

<span class="sd">    &gt;&gt;&gt; x, y = Ints(&#39;x y&#39;)</span>
<span class="sd">    &gt;&gt;&gt; is_add(x + y)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; is_add(x - y)</span>
<span class="sd">    False</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">is_app_of</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">Z3_OP_ADD</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">is_mul</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return `True` if `a` is an expression of the form b * c.</span>

<span class="sd">    &gt;&gt;&gt; x, y = Ints(&#39;x y&#39;)</span>
<span class="sd">    &gt;&gt;&gt; is_mul(x * y)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; is_mul(x - y)</span>
<span class="sd">    False</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">is_app_of</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">Z3_OP_MUL</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">is_sub</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return `True` if `a` is an expression of the form b - c.</span>

<span class="sd">    &gt;&gt;&gt; x, y = Ints(&#39;x y&#39;)</span>
<span class="sd">    &gt;&gt;&gt; is_sub(x - y)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; is_sub(x + y)</span>
<span class="sd">    False</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">is_app_of</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">Z3_OP_SUB</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">is_div</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return `True` if `a` is an expression of the form b / c.</span>

<span class="sd">    &gt;&gt;&gt; x, y = Reals(&#39;x y&#39;)</span>
<span class="sd">    &gt;&gt;&gt; is_div(x / y)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; is_div(x + y)</span>
<span class="sd">    False</span>
<span class="sd">    &gt;&gt;&gt; x, y = Ints(&#39;x y&#39;)</span>
<span class="sd">    &gt;&gt;&gt; is_div(x / y)</span>
<span class="sd">    False</span>
<span class="sd">    &gt;&gt;&gt; is_idiv(x / y)</span>
<span class="sd">    True</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">is_app_of</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">Z3_OP_DIV</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">is_idiv</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return `True` if `a` is an expression of the form b div c.</span>

<span class="sd">    &gt;&gt;&gt; x, y = Ints(&#39;x y&#39;)</span>
<span class="sd">    &gt;&gt;&gt; is_idiv(x / y)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; is_idiv(x + y)</span>
<span class="sd">    False</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">is_app_of</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">Z3_OP_IDIV</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">is_mod</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return `True` if `a` is an expression of the form b % c.</span>

<span class="sd">    &gt;&gt;&gt; x, y = Ints(&#39;x y&#39;)</span>
<span class="sd">    &gt;&gt;&gt; is_mod(x % y)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; is_mod(x + y)</span>
<span class="sd">    False</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">is_app_of</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">Z3_OP_MOD</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">is_le</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return `True` if `a` is an expression of the form b &lt;= c.</span>

<span class="sd">    &gt;&gt;&gt; x, y = Ints(&#39;x y&#39;)</span>
<span class="sd">    &gt;&gt;&gt; is_le(x &lt;= y)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; is_le(x &lt; y)</span>
<span class="sd">    False</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">is_app_of</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">Z3_OP_LE</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">is_lt</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return `True` if `a` is an expression of the form b &lt; c.</span>

<span class="sd">    &gt;&gt;&gt; x, y = Ints(&#39;x y&#39;)</span>
<span class="sd">    &gt;&gt;&gt; is_lt(x &lt; y)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; is_lt(x == y)</span>
<span class="sd">    False</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">is_app_of</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">Z3_OP_LT</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">is_ge</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return `True` if `a` is an expression of the form b &gt;= c.</span>

<span class="sd">    &gt;&gt;&gt; x, y = Ints(&#39;x y&#39;)</span>
<span class="sd">    &gt;&gt;&gt; is_ge(x &gt;= y)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; is_ge(x == y)</span>
<span class="sd">    False</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">is_app_of</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">Z3_OP_GE</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">is_gt</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return `True` if `a` is an expression of the form b &gt; c.</span>

<span class="sd">    &gt;&gt;&gt; x, y = Ints(&#39;x y&#39;)</span>
<span class="sd">    &gt;&gt;&gt; is_gt(x &gt; y)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; is_gt(x == y)</span>
<span class="sd">    False</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">is_app_of</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">Z3_OP_GT</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">is_is_int</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return `True` if `a` is an expression of the form IsInt(b).</span>

<span class="sd">    &gt;&gt;&gt; x = Real(&#39;x&#39;)</span>
<span class="sd">    &gt;&gt;&gt; is_is_int(IsInt(x))</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; is_is_int(x)</span>
<span class="sd">    False</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">is_app_of</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">Z3_OP_IS_INT</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">is_to_real</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return `True` if `a` is an expression of the form ToReal(b).</span>

<span class="sd">    &gt;&gt;&gt; x = Int(&#39;x&#39;)</span>
<span class="sd">    &gt;&gt;&gt; n = ToReal(x)</span>
<span class="sd">    &gt;&gt;&gt; n</span>
<span class="sd">    ToReal(x)</span>
<span class="sd">    &gt;&gt;&gt; is_to_real(n)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; is_to_real(x)</span>
<span class="sd">    False</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">is_app_of</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">Z3_OP_TO_REAL</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">is_to_int</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return `True` if `a` is an expression of the form ToInt(b).</span>

<span class="sd">    &gt;&gt;&gt; x = Real(&#39;x&#39;)</span>
<span class="sd">    &gt;&gt;&gt; n = ToInt(x)</span>
<span class="sd">    &gt;&gt;&gt; n</span>
<span class="sd">    ToInt(x)</span>
<span class="sd">    &gt;&gt;&gt; is_to_int(n)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; is_to_int(x)</span>
<span class="sd">    False</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">is_app_of</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">Z3_OP_TO_INT</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">IntNumRef</span><span class="p">(</span><span class="n">ArithRef</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Integer values.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">as_long</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a Z3 integer numeral as a Python long (bignum) numeral.</span>

<span class="sd">        &gt;&gt;&gt; v = IntVal(1)</span>
<span class="sd">        &gt;&gt;&gt; v + 1</span>
<span class="sd">        1 + 1</span>
<span class="sd">        &gt;&gt;&gt; v.as_long() + 1</span>
<span class="sd">        2</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">z3_debug</span><span class="p">():</span>
            <span class="n">_z3_assert</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">is_int</span><span class="p">(),</span> <span class="s2">&quot;Integer value expected&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">as_string</span><span class="p">())</span>

    <span class="k">def</span> <span class="nf">as_string</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a Z3 integer numeral as a Python string.</span>
<span class="sd">        &gt;&gt;&gt; v = IntVal(100)</span>
<span class="sd">        &gt;&gt;&gt; v.as_string()</span>
<span class="sd">        &#39;100&#39;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Z3_get_numeral_string</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx_ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_ast</span><span class="p">())</span>

    <span class="k">def</span> <span class="nf">as_binary_string</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a Z3 integer numeral as a Python binary string.</span>
<span class="sd">        &gt;&gt;&gt; v = IntVal(10)</span>
<span class="sd">        &gt;&gt;&gt; v.as_binary_string()</span>
<span class="sd">        &#39;1010&#39;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Z3_get_numeral_binary_string</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx_ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_ast</span><span class="p">())</span>


<span class="k">class</span> <span class="nc">RatNumRef</span><span class="p">(</span><span class="n">ArithRef</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Rational values.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">numerator</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Return the numerator of a Z3 rational numeral.</span>

<span class="sd">        &gt;&gt;&gt; is_rational_value(RealVal(&quot;3/5&quot;))</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; n = RealVal(&quot;3/5&quot;)</span>
<span class="sd">        &gt;&gt;&gt; n.numerator()</span>
<span class="sd">        3</span>
<span class="sd">        &gt;&gt;&gt; is_rational_value(Q(3,5))</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; Q(3,5).numerator()</span>
<span class="sd">        3</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">IntNumRef</span><span class="p">(</span><span class="n">Z3_get_numerator</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx_ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_ast</span><span class="p">()),</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">denominator</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Return the denominator of a Z3 rational numeral.</span>

<span class="sd">        &gt;&gt;&gt; is_rational_value(Q(3,5))</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; n = Q(3,5)</span>
<span class="sd">        &gt;&gt;&gt; n.denominator()</span>
<span class="sd">        5</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">IntNumRef</span><span class="p">(</span><span class="n">Z3_get_denominator</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx_ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_ast</span><span class="p">()),</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">numerator_as_long</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Return the numerator as a Python long.</span>

<span class="sd">        &gt;&gt;&gt; v = RealVal(10000000000)</span>
<span class="sd">        &gt;&gt;&gt; v</span>
<span class="sd">        10000000000</span>
<span class="sd">        &gt;&gt;&gt; v + 1</span>
<span class="sd">        10000000000 + 1</span>
<span class="sd">        &gt;&gt;&gt; v.numerator_as_long() + 1 == 10000000001</span>
<span class="sd">        True</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">numerator</span><span class="p">()</span><span class="o">.</span><span class="n">as_long</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">denominator_as_long</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Return the denominator as a Python long.</span>

<span class="sd">        &gt;&gt;&gt; v = RealVal(&quot;1/3&quot;)</span>
<span class="sd">        &gt;&gt;&gt; v</span>
<span class="sd">        1/3</span>
<span class="sd">        &gt;&gt;&gt; v.denominator_as_long()</span>
<span class="sd">        3</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">denominator</span><span class="p">()</span><span class="o">.</span><span class="n">as_long</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">is_int</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">is_real</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">is_int_value</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">denominator</span><span class="p">()</span><span class="o">.</span><span class="n">is_int</span><span class="p">()</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">denominator_as_long</span><span class="p">()</span> <span class="o">==</span> <span class="mi">1</span>

    <span class="k">def</span> <span class="nf">as_long</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">_z3_assert</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">is_int_value</span><span class="p">(),</span> <span class="s2">&quot;Expected integer fraction&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">numerator_as_long</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">as_decimal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prec</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Return a Z3 rational value as a string in decimal notation using at most `prec` decimal places.</span>

<span class="sd">        &gt;&gt;&gt; v = RealVal(&quot;1/5&quot;)</span>
<span class="sd">        &gt;&gt;&gt; v.as_decimal(3)</span>
<span class="sd">        &#39;0.2&#39;</span>
<span class="sd">        &gt;&gt;&gt; v = RealVal(&quot;1/3&quot;)</span>
<span class="sd">        &gt;&gt;&gt; v.as_decimal(3)</span>
<span class="sd">        &#39;0.333?&#39;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Z3_get_numeral_decimal_string</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx_ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_ast</span><span class="p">(),</span> <span class="n">prec</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">as_string</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a Z3 rational numeral as a Python string.</span>

<span class="sd">        &gt;&gt;&gt; v = Q(3,6)</span>
<span class="sd">        &gt;&gt;&gt; v.as_string()</span>
<span class="sd">        &#39;1/2&#39;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Z3_get_numeral_string</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx_ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_ast</span><span class="p">())</span>

    <span class="k">def</span> <span class="nf">as_fraction</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a Z3 rational as a Python Fraction object.</span>

<span class="sd">        &gt;&gt;&gt; v = RealVal(&quot;1/5&quot;)</span>
<span class="sd">        &gt;&gt;&gt; v.as_fraction()</span>
<span class="sd">        Fraction(1, 5)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Fraction</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">numerator_as_long</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">denominator_as_long</span><span class="p">())</span>


<span class="k">class</span> <span class="nc">AlgebraicNumRef</span><span class="p">(</span><span class="n">ArithRef</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Algebraic irrational values.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">approx</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">precision</span><span class="o">=</span><span class="mi">10</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a Z3 rational number that approximates the algebraic number `self`.</span>
<span class="sd">        The result `r` is such that |r - self| &lt;= 1/10^precision</span>

<span class="sd">        &gt;&gt;&gt; x = simplify(Sqrt(2))</span>
<span class="sd">        &gt;&gt;&gt; x.approx(20)</span>
<span class="sd">        6838717160008073720548335/4835703278458516698824704</span>
<span class="sd">        &gt;&gt;&gt; x.approx(5)</span>
<span class="sd">        2965821/2097152</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">RatNumRef</span><span class="p">(</span><span class="n">Z3_get_algebraic_number_upper</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx_ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_ast</span><span class="p">(),</span> <span class="n">precision</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">as_decimal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prec</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a string representation of the algebraic number `self` in decimal notation</span>
<span class="sd">        using `prec` decimal places.</span>

<span class="sd">        &gt;&gt;&gt; x = simplify(Sqrt(2))</span>
<span class="sd">        &gt;&gt;&gt; x.as_decimal(10)</span>
<span class="sd">        &#39;1.4142135623?&#39;</span>
<span class="sd">        &gt;&gt;&gt; x.as_decimal(20)</span>
<span class="sd">        &#39;1.41421356237309504880?&#39;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Z3_get_numeral_decimal_string</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx_ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_ast</span><span class="p">(),</span> <span class="n">prec</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">poly</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">AstVector</span><span class="p">(</span><span class="n">Z3_algebraic_get_poly</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx_ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_ast</span><span class="p">()),</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">index</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Z3_algebraic_get_i</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx_ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_ast</span><span class="p">())</span>


<span class="k">def</span> <span class="nf">_py2expr</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">ctx</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">BoolVal</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">ctx</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">_is_int</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">IntVal</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">ctx</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="nb">float</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">RealVal</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">ctx</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">StringVal</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">ctx</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">is_expr</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">a</span>
    <span class="k">if</span> <span class="n">z3_debug</span><span class="p">():</span>
        <span class="n">_z3_assert</span><span class="p">(</span><span class="kc">False</span><span class="p">,</span> <span class="s2">&quot;Python bool, int, long or float expected&quot;</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">IntSort</span><span class="p">(</span><span class="n">ctx</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return the integer sort in the given context. If `ctx=None`, then the global context is used.</span>

<span class="sd">    &gt;&gt;&gt; IntSort()</span>
<span class="sd">    Int</span>
<span class="sd">    &gt;&gt;&gt; x = Const(&#39;x&#39;, IntSort())</span>
<span class="sd">    &gt;&gt;&gt; is_int(x)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; x.sort() == IntSort()</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; x.sort() == BoolSort()</span>
<span class="sd">    False</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ctx</span> <span class="o">=</span> <span class="n">_get_ctx</span><span class="p">(</span><span class="n">ctx</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">ArithSortRef</span><span class="p">(</span><span class="n">Z3_mk_int_sort</span><span class="p">(</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">()),</span> <span class="n">ctx</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">RealSort</span><span class="p">(</span><span class="n">ctx</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return the real sort in the given context. If `ctx=None`, then the global context is used.</span>

<span class="sd">    &gt;&gt;&gt; RealSort()</span>
<span class="sd">    Real</span>
<span class="sd">    &gt;&gt;&gt; x = Const(&#39;x&#39;, RealSort())</span>
<span class="sd">    &gt;&gt;&gt; is_real(x)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; is_int(x)</span>
<span class="sd">    False</span>
<span class="sd">    &gt;&gt;&gt; x.sort() == RealSort()</span>
<span class="sd">    True</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ctx</span> <span class="o">=</span> <span class="n">_get_ctx</span><span class="p">(</span><span class="n">ctx</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">ArithSortRef</span><span class="p">(</span><span class="n">Z3_mk_real_sort</span><span class="p">(</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">()),</span> <span class="n">ctx</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_to_int_str</span><span class="p">(</span><span class="n">val</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="nb">float</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">val</span><span class="p">))</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">val</span><span class="p">:</span>
            <span class="k">return</span> <span class="s2">&quot;1&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="s2">&quot;0&quot;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">IntVal</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">ctx</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return a Z3 integer value. If `ctx=None`, then the global context is used.</span>

<span class="sd">    &gt;&gt;&gt; IntVal(1)</span>
<span class="sd">    1</span>
<span class="sd">    &gt;&gt;&gt; IntVal(&quot;100&quot;)</span>
<span class="sd">    100</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ctx</span> <span class="o">=</span> <span class="n">_get_ctx</span><span class="p">(</span><span class="n">ctx</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">IntNumRef</span><span class="p">(</span><span class="n">Z3_mk_numeral</span><span class="p">(</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="n">_to_int_str</span><span class="p">(</span><span class="n">val</span><span class="p">),</span> <span class="n">IntSort</span><span class="p">(</span><span class="n">ctx</span><span class="p">)</span><span class="o">.</span><span class="n">ast</span><span class="p">),</span> <span class="n">ctx</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">RealVal</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">ctx</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return a Z3 real value.</span>

<span class="sd">    `val` may be a Python int, long, float or string representing a number in decimal or rational notation.</span>
<span class="sd">    If `ctx=None`, then the global context is used.</span>

<span class="sd">    &gt;&gt;&gt; RealVal(1)</span>
<span class="sd">    1</span>
<span class="sd">    &gt;&gt;&gt; RealVal(1).sort()</span>
<span class="sd">    Real</span>
<span class="sd">    &gt;&gt;&gt; RealVal(&quot;3/5&quot;)</span>
<span class="sd">    3/5</span>
<span class="sd">    &gt;&gt;&gt; RealVal(&quot;1.5&quot;)</span>
<span class="sd">    3/2</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ctx</span> <span class="o">=</span> <span class="n">_get_ctx</span><span class="p">(</span><span class="n">ctx</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">RatNumRef</span><span class="p">(</span><span class="n">Z3_mk_numeral</span><span class="p">(</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="nb">str</span><span class="p">(</span><span class="n">val</span><span class="p">),</span> <span class="n">RealSort</span><span class="p">(</span><span class="n">ctx</span><span class="p">)</span><span class="o">.</span><span class="n">ast</span><span class="p">),</span> <span class="n">ctx</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">RatVal</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">ctx</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return a Z3 rational a/b.</span>

<span class="sd">    If `ctx=None`, then the global context is used.</span>

<span class="sd">    &gt;&gt;&gt; RatVal(3,5)</span>
<span class="sd">    3/5</span>
<span class="sd">    &gt;&gt;&gt; RatVal(3,5).sort()</span>
<span class="sd">    Real</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">z3_debug</span><span class="p">():</span>
        <span class="n">_z3_assert</span><span class="p">(</span><span class="n">_is_int</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="nb">str</span><span class="p">),</span> <span class="s2">&quot;First argument cannot be converted into an integer&quot;</span><span class="p">)</span>
        <span class="n">_z3_assert</span><span class="p">(</span><span class="n">_is_int</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="nb">str</span><span class="p">),</span> <span class="s2">&quot;Second argument cannot be converted into an integer&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">simplify</span><span class="p">(</span><span class="n">RealVal</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">ctx</span><span class="p">)</span> <span class="o">/</span> <span class="n">RealVal</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">ctx</span><span class="p">))</span>


<span class="k">def</span> <span class="nf">Q</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">ctx</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return a Z3 rational a/b.</span>

<span class="sd">    If `ctx=None`, then the global context is used.</span>

<span class="sd">    &gt;&gt;&gt; Q(3,5)</span>
<span class="sd">    3/5</span>
<span class="sd">    &gt;&gt;&gt; Q(3,5).sort()</span>
<span class="sd">    Real</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">simplify</span><span class="p">(</span><span class="n">RatVal</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">ctx</span><span class="o">=</span><span class="n">ctx</span><span class="p">))</span>


<span class="k">def</span> <span class="nf">Int</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">ctx</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return an integer constant named `name`. If `ctx=None`, then the global context is used.</span>

<span class="sd">    &gt;&gt;&gt; x = Int(&#39;x&#39;)</span>
<span class="sd">    &gt;&gt;&gt; is_int(x)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; is_int(x + 1)</span>
<span class="sd">    True</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ctx</span> <span class="o">=</span> <span class="n">_get_ctx</span><span class="p">(</span><span class="n">ctx</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">ArithRef</span><span class="p">(</span><span class="n">Z3_mk_const</span><span class="p">(</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="n">to_symbol</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">ctx</span><span class="p">),</span> <span class="n">IntSort</span><span class="p">(</span><span class="n">ctx</span><span class="p">)</span><span class="o">.</span><span class="n">ast</span><span class="p">),</span> <span class="n">ctx</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">Ints</span><span class="p">(</span><span class="n">names</span><span class="p">,</span> <span class="n">ctx</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return a tuple of Integer constants.</span>

<span class="sd">    &gt;&gt;&gt; x, y, z = Ints(&#39;x y z&#39;)</span>
<span class="sd">    &gt;&gt;&gt; Sum(x, y, z)</span>
<span class="sd">    x + y + z</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ctx</span> <span class="o">=</span> <span class="n">_get_ctx</span><span class="p">(</span><span class="n">ctx</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">names</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="n">names</span> <span class="o">=</span> <span class="n">names</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot; &quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">Int</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">ctx</span><span class="p">)</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">names</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">IntVector</span><span class="p">(</span><span class="n">prefix</span><span class="p">,</span> <span class="n">sz</span><span class="p">,</span> <span class="n">ctx</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return a list of integer constants of size `sz`.</span>

<span class="sd">    &gt;&gt;&gt; X = IntVector(&#39;x&#39;, 3)</span>
<span class="sd">    &gt;&gt;&gt; X</span>
<span class="sd">    [x__0, x__1, x__2]</span>
<span class="sd">    &gt;&gt;&gt; Sum(X)</span>
<span class="sd">    x__0 + x__1 + x__2</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ctx</span> <span class="o">=</span> <span class="n">_get_ctx</span><span class="p">(</span><span class="n">ctx</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">Int</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">__</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">prefix</span><span class="p">,</span> <span class="n">i</span><span class="p">),</span> <span class="n">ctx</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">sz</span><span class="p">)]</span>


<span class="k">def</span> <span class="nf">FreshInt</span><span class="p">(</span><span class="n">prefix</span><span class="o">=</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="n">ctx</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return a fresh integer constant in the given context using the given prefix.</span>

<span class="sd">    &gt;&gt;&gt; x = FreshInt()</span>
<span class="sd">    &gt;&gt;&gt; y = FreshInt()</span>
<span class="sd">    &gt;&gt;&gt; eq(x, y)</span>
<span class="sd">    False</span>
<span class="sd">    &gt;&gt;&gt; x.sort()</span>
<span class="sd">    Int</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ctx</span> <span class="o">=</span> <span class="n">_get_ctx</span><span class="p">(</span><span class="n">ctx</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">ArithRef</span><span class="p">(</span><span class="n">Z3_mk_fresh_const</span><span class="p">(</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="n">prefix</span><span class="p">,</span> <span class="n">IntSort</span><span class="p">(</span><span class="n">ctx</span><span class="p">)</span><span class="o">.</span><span class="n">ast</span><span class="p">),</span> <span class="n">ctx</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">Real</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">ctx</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return a real constant named `name`. If `ctx=None`, then the global context is used.</span>

<span class="sd">    &gt;&gt;&gt; x = Real(&#39;x&#39;)</span>
<span class="sd">    &gt;&gt;&gt; is_real(x)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; is_real(x + 1)</span>
<span class="sd">    True</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ctx</span> <span class="o">=</span> <span class="n">_get_ctx</span><span class="p">(</span><span class="n">ctx</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">ArithRef</span><span class="p">(</span><span class="n">Z3_mk_const</span><span class="p">(</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="n">to_symbol</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">ctx</span><span class="p">),</span> <span class="n">RealSort</span><span class="p">(</span><span class="n">ctx</span><span class="p">)</span><span class="o">.</span><span class="n">ast</span><span class="p">),</span> <span class="n">ctx</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">Reals</span><span class="p">(</span><span class="n">names</span><span class="p">,</span> <span class="n">ctx</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return a tuple of real constants.</span>

<span class="sd">    &gt;&gt;&gt; x, y, z = Reals(&#39;x y z&#39;)</span>
<span class="sd">    &gt;&gt;&gt; Sum(x, y, z)</span>
<span class="sd">    x + y + z</span>
<span class="sd">    &gt;&gt;&gt; Sum(x, y, z).sort()</span>
<span class="sd">    Real</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ctx</span> <span class="o">=</span> <span class="n">_get_ctx</span><span class="p">(</span><span class="n">ctx</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">names</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="n">names</span> <span class="o">=</span> <span class="n">names</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot; &quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">Real</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">ctx</span><span class="p">)</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">names</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">RealVector</span><span class="p">(</span><span class="n">prefix</span><span class="p">,</span> <span class="n">sz</span><span class="p">,</span> <span class="n">ctx</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return a list of real constants of size `sz`.</span>

<span class="sd">    &gt;&gt;&gt; X = RealVector(&#39;x&#39;, 3)</span>
<span class="sd">    &gt;&gt;&gt; X</span>
<span class="sd">    [x__0, x__1, x__2]</span>
<span class="sd">    &gt;&gt;&gt; Sum(X)</span>
<span class="sd">    x__0 + x__1 + x__2</span>
<span class="sd">    &gt;&gt;&gt; Sum(X).sort()</span>
<span class="sd">    Real</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ctx</span> <span class="o">=</span> <span class="n">_get_ctx</span><span class="p">(</span><span class="n">ctx</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">Real</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">__</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">prefix</span><span class="p">,</span> <span class="n">i</span><span class="p">),</span> <span class="n">ctx</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">sz</span><span class="p">)]</span>


<span class="k">def</span> <span class="nf">FreshReal</span><span class="p">(</span><span class="n">prefix</span><span class="o">=</span><span class="s2">&quot;b&quot;</span><span class="p">,</span> <span class="n">ctx</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return a fresh real constant in the given context using the given prefix.</span>

<span class="sd">    &gt;&gt;&gt; x = FreshReal()</span>
<span class="sd">    &gt;&gt;&gt; y = FreshReal()</span>
<span class="sd">    &gt;&gt;&gt; eq(x, y)</span>
<span class="sd">    False</span>
<span class="sd">    &gt;&gt;&gt; x.sort()</span>
<span class="sd">    Real</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ctx</span> <span class="o">=</span> <span class="n">_get_ctx</span><span class="p">(</span><span class="n">ctx</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">ArithRef</span><span class="p">(</span><span class="n">Z3_mk_fresh_const</span><span class="p">(</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="n">prefix</span><span class="p">,</span> <span class="n">RealSort</span><span class="p">(</span><span class="n">ctx</span><span class="p">)</span><span class="o">.</span><span class="n">ast</span><span class="p">),</span> <span class="n">ctx</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">ToReal</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Return the Z3 expression ToReal(a).</span>

<span class="sd">    &gt;&gt;&gt; x = Int(&#39;x&#39;)</span>
<span class="sd">    &gt;&gt;&gt; x.sort()</span>
<span class="sd">    Int</span>
<span class="sd">    &gt;&gt;&gt; n = ToReal(x)</span>
<span class="sd">    &gt;&gt;&gt; n</span>
<span class="sd">    ToReal(x)</span>
<span class="sd">    &gt;&gt;&gt; n.sort()</span>
<span class="sd">    Real</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">z3_debug</span><span class="p">():</span>
        <span class="n">_z3_assert</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">is_int</span><span class="p">(),</span> <span class="s2">&quot;Z3 integer expression expected.&quot;</span><span class="p">)</span>
    <span class="n">ctx</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">ctx</span>
    <span class="k">return</span> <span class="n">ArithRef</span><span class="p">(</span><span class="n">Z3_mk_int2real</span><span class="p">(</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="n">a</span><span class="o">.</span><span class="n">as_ast</span><span class="p">()),</span> <span class="n">ctx</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">ToInt</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Return the Z3 expression ToInt(a).</span>

<span class="sd">    &gt;&gt;&gt; x = Real(&#39;x&#39;)</span>
<span class="sd">    &gt;&gt;&gt; x.sort()</span>
<span class="sd">    Real</span>
<span class="sd">    &gt;&gt;&gt; n = ToInt(x)</span>
<span class="sd">    &gt;&gt;&gt; n</span>
<span class="sd">    ToInt(x)</span>
<span class="sd">    &gt;&gt;&gt; n.sort()</span>
<span class="sd">    Int</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">z3_debug</span><span class="p">():</span>
        <span class="n">_z3_assert</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">is_real</span><span class="p">(),</span> <span class="s2">&quot;Z3 real expression expected.&quot;</span><span class="p">)</span>
    <span class="n">ctx</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">ctx</span>
    <span class="k">return</span> <span class="n">ArithRef</span><span class="p">(</span><span class="n">Z3_mk_real2int</span><span class="p">(</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="n">a</span><span class="o">.</span><span class="n">as_ast</span><span class="p">()),</span> <span class="n">ctx</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">IsInt</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Return the Z3 predicate IsInt(a).</span>

<span class="sd">    &gt;&gt;&gt; x = Real(&#39;x&#39;)</span>
<span class="sd">    &gt;&gt;&gt; IsInt(x + &quot;1/2&quot;)</span>
<span class="sd">    IsInt(x + 1/2)</span>
<span class="sd">    &gt;&gt;&gt; solve(IsInt(x + &quot;1/2&quot;), x &gt; 0, x &lt; 1)</span>
<span class="sd">    [x = 1/2]</span>
<span class="sd">    &gt;&gt;&gt; solve(IsInt(x + &quot;1/2&quot;), x &gt; 0, x &lt; 1, x != &quot;1/2&quot;)</span>
<span class="sd">    no solution</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">z3_debug</span><span class="p">():</span>
        <span class="n">_z3_assert</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">is_real</span><span class="p">(),</span> <span class="s2">&quot;Z3 real expression expected.&quot;</span><span class="p">)</span>
    <span class="n">ctx</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">ctx</span>
    <span class="k">return</span> <span class="n">BoolRef</span><span class="p">(</span><span class="n">Z3_mk_is_int</span><span class="p">(</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="n">a</span><span class="o">.</span><span class="n">as_ast</span><span class="p">()),</span> <span class="n">ctx</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">Sqrt</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">ctx</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Return a Z3 expression which represents the square root of a.</span>

<span class="sd">    &gt;&gt;&gt; x = Real(&#39;x&#39;)</span>
<span class="sd">    &gt;&gt;&gt; Sqrt(x)</span>
<span class="sd">    x**(1/2)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">is_expr</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
        <span class="n">ctx</span> <span class="o">=</span> <span class="n">_get_ctx</span><span class="p">(</span><span class="n">ctx</span><span class="p">)</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">RealVal</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">ctx</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">a</span> <span class="o">**</span> <span class="s2">&quot;1/2&quot;</span>


<span class="k">def</span> <span class="nf">Cbrt</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">ctx</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Return a Z3 expression which represents the cubic root of a.</span>

<span class="sd">    &gt;&gt;&gt; x = Real(&#39;x&#39;)</span>
<span class="sd">    &gt;&gt;&gt; Cbrt(x)</span>
<span class="sd">    x**(1/3)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">is_expr</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
        <span class="n">ctx</span> <span class="o">=</span> <span class="n">_get_ctx</span><span class="p">(</span><span class="n">ctx</span><span class="p">)</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">RealVal</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">ctx</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">a</span> <span class="o">**</span> <span class="s2">&quot;1/3&quot;</span>

<span class="c1">#########################################</span>
<span class="c1">#</span>
<span class="c1"># Bit-Vectors</span>
<span class="c1">#</span>
<span class="c1">#########################################</span>


<span class="k">class</span> <span class="nc">BitVecSortRef</span><span class="p">(</span><span class="n">SortRef</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Bit-vector sort.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">size</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the size (number of bits) of the bit-vector sort `self`.</span>

<span class="sd">        &gt;&gt;&gt; b = BitVecSort(32)</span>
<span class="sd">        &gt;&gt;&gt; b.size()</span>
<span class="sd">        32</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">Z3_get_bv_sort_size</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx_ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">ast</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">subsort</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">is_bv_sort</span><span class="p">(</span><span class="n">other</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">other</span><span class="o">.</span><span class="n">size</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">cast</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Try to cast `val` as a Bit-Vector.</span>

<span class="sd">        &gt;&gt;&gt; b = BitVecSort(32)</span>
<span class="sd">        &gt;&gt;&gt; b.cast(10)</span>
<span class="sd">        10</span>
<span class="sd">        &gt;&gt;&gt; b.cast(10).sexpr()</span>
<span class="sd">        &#39;#x0000000a&#39;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">is_expr</span><span class="p">(</span><span class="n">val</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">z3_debug</span><span class="p">():</span>
                <span class="n">_z3_assert</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span> <span class="o">==</span> <span class="n">val</span><span class="o">.</span><span class="n">ctx</span><span class="p">,</span> <span class="s2">&quot;Context mismatch&quot;</span><span class="p">)</span>
            <span class="c1"># Idea: use sign_extend if sort of val is a bitvector of smaller size</span>
            <span class="k">return</span> <span class="n">val</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">BitVecVal</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">is_bv_sort</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return True if `s` is a Z3 bit-vector sort.</span>

<span class="sd">    &gt;&gt;&gt; is_bv_sort(BitVecSort(32))</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; is_bv_sort(IntSort())</span>
<span class="sd">    False</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">BitVecSortRef</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">BitVecRef</span><span class="p">(</span><span class="n">ExprRef</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Bit-vector expressions.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">sort</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the sort of the bit-vector expression `self`.</span>

<span class="sd">        &gt;&gt;&gt; x = BitVec(&#39;x&#39;, 32)</span>
<span class="sd">        &gt;&gt;&gt; x.sort()</span>
<span class="sd">        BitVec(32)</span>
<span class="sd">        &gt;&gt;&gt; x.sort() == BitVecSort(32)</span>
<span class="sd">        True</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">BitVecSortRef</span><span class="p">(</span><span class="n">Z3_get_sort</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx_ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_ast</span><span class="p">()),</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">size</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the number of bits of the bit-vector expression `self`.</span>

<span class="sd">        &gt;&gt;&gt; x = BitVec(&#39;x&#39;, 32)</span>
<span class="sd">        &gt;&gt;&gt; (x + 1).size()</span>
<span class="sd">        32</span>
<span class="sd">        &gt;&gt;&gt; Concat(x, x).size()</span>
<span class="sd">        64</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span><span class="o">.</span><span class="n">size</span><span class="p">()</span>

    <span class="k">def</span> <span class="fm">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create the Z3 expression `self + other`.</span>

<span class="sd">        &gt;&gt;&gt; x = BitVec(&#39;x&#39;, 32)</span>
<span class="sd">        &gt;&gt;&gt; y = BitVec(&#39;y&#39;, 32)</span>
<span class="sd">        &gt;&gt;&gt; x + y</span>
<span class="sd">        x + y</span>
<span class="sd">        &gt;&gt;&gt; (x + y).sort()</span>
<span class="sd">        BitVec(32)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">_coerce_exprs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">BitVecRef</span><span class="p">(</span><span class="n">Z3_mk_bvadd</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx_ref</span><span class="p">(),</span> <span class="n">a</span><span class="o">.</span><span class="n">as_ast</span><span class="p">(),</span> <span class="n">b</span><span class="o">.</span><span class="n">as_ast</span><span class="p">()),</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__radd__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create the Z3 expression `other + self`.</span>

<span class="sd">        &gt;&gt;&gt; x = BitVec(&#39;x&#39;, 32)</span>
<span class="sd">        &gt;&gt;&gt; 10 + x</span>
<span class="sd">        10 + x</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">_coerce_exprs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">BitVecRef</span><span class="p">(</span><span class="n">Z3_mk_bvadd</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx_ref</span><span class="p">(),</span> <span class="n">b</span><span class="o">.</span><span class="n">as_ast</span><span class="p">(),</span> <span class="n">a</span><span class="o">.</span><span class="n">as_ast</span><span class="p">()),</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__mul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create the Z3 expression `self * other`.</span>

<span class="sd">        &gt;&gt;&gt; x = BitVec(&#39;x&#39;, 32)</span>
<span class="sd">        &gt;&gt;&gt; y = BitVec(&#39;y&#39;, 32)</span>
<span class="sd">        &gt;&gt;&gt; x * y</span>
<span class="sd">        x*y</span>
<span class="sd">        &gt;&gt;&gt; (x * y).sort()</span>
<span class="sd">        BitVec(32)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">_coerce_exprs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">BitVecRef</span><span class="p">(</span><span class="n">Z3_mk_bvmul</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx_ref</span><span class="p">(),</span> <span class="n">a</span><span class="o">.</span><span class="n">as_ast</span><span class="p">(),</span> <span class="n">b</span><span class="o">.</span><span class="n">as_ast</span><span class="p">()),</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__rmul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create the Z3 expression `other * self`.</span>

<span class="sd">        &gt;&gt;&gt; x = BitVec(&#39;x&#39;, 32)</span>
<span class="sd">        &gt;&gt;&gt; 10 * x</span>
<span class="sd">        10*x</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">_coerce_exprs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">BitVecRef</span><span class="p">(</span><span class="n">Z3_mk_bvmul</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx_ref</span><span class="p">(),</span> <span class="n">b</span><span class="o">.</span><span class="n">as_ast</span><span class="p">(),</span> <span class="n">a</span><span class="o">.</span><span class="n">as_ast</span><span class="p">()),</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__sub__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create the Z3 expression `self - other`.</span>

<span class="sd">        &gt;&gt;&gt; x = BitVec(&#39;x&#39;, 32)</span>
<span class="sd">        &gt;&gt;&gt; y = BitVec(&#39;y&#39;, 32)</span>
<span class="sd">        &gt;&gt;&gt; x - y</span>
<span class="sd">        x - y</span>
<span class="sd">        &gt;&gt;&gt; (x - y).sort()</span>
<span class="sd">        BitVec(32)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">_coerce_exprs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">BitVecRef</span><span class="p">(</span><span class="n">Z3_mk_bvsub</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx_ref</span><span class="p">(),</span> <span class="n">a</span><span class="o">.</span><span class="n">as_ast</span><span class="p">(),</span> <span class="n">b</span><span class="o">.</span><span class="n">as_ast</span><span class="p">()),</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__rsub__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create the Z3 expression `other - self`.</span>

<span class="sd">        &gt;&gt;&gt; x = BitVec(&#39;x&#39;, 32)</span>
<span class="sd">        &gt;&gt;&gt; 10 - x</span>
<span class="sd">        10 - x</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">_coerce_exprs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">BitVecRef</span><span class="p">(</span><span class="n">Z3_mk_bvsub</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx_ref</span><span class="p">(),</span> <span class="n">b</span><span class="o">.</span><span class="n">as_ast</span><span class="p">(),</span> <span class="n">a</span><span class="o">.</span><span class="n">as_ast</span><span class="p">()),</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__or__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create the Z3 expression bitwise-or `self | other`.</span>

<span class="sd">        &gt;&gt;&gt; x = BitVec(&#39;x&#39;, 32)</span>
<span class="sd">        &gt;&gt;&gt; y = BitVec(&#39;y&#39;, 32)</span>
<span class="sd">        &gt;&gt;&gt; x | y</span>
<span class="sd">        x | y</span>
<span class="sd">        &gt;&gt;&gt; (x | y).sort()</span>
<span class="sd">        BitVec(32)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">_coerce_exprs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">BitVecRef</span><span class="p">(</span><span class="n">Z3_mk_bvor</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx_ref</span><span class="p">(),</span> <span class="n">a</span><span class="o">.</span><span class="n">as_ast</span><span class="p">(),</span> <span class="n">b</span><span class="o">.</span><span class="n">as_ast</span><span class="p">()),</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__ror__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create the Z3 expression bitwise-or `other | self`.</span>

<span class="sd">        &gt;&gt;&gt; x = BitVec(&#39;x&#39;, 32)</span>
<span class="sd">        &gt;&gt;&gt; 10 | x</span>
<span class="sd">        10 | x</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">_coerce_exprs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">BitVecRef</span><span class="p">(</span><span class="n">Z3_mk_bvor</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx_ref</span><span class="p">(),</span> <span class="n">b</span><span class="o">.</span><span class="n">as_ast</span><span class="p">(),</span> <span class="n">a</span><span class="o">.</span><span class="n">as_ast</span><span class="p">()),</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__and__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create the Z3 expression bitwise-and `self &amp; other`.</span>

<span class="sd">        &gt;&gt;&gt; x = BitVec(&#39;x&#39;, 32)</span>
<span class="sd">        &gt;&gt;&gt; y = BitVec(&#39;y&#39;, 32)</span>
<span class="sd">        &gt;&gt;&gt; x &amp; y</span>
<span class="sd">        x &amp; y</span>
<span class="sd">        &gt;&gt;&gt; (x &amp; y).sort()</span>
<span class="sd">        BitVec(32)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">_coerce_exprs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">BitVecRef</span><span class="p">(</span><span class="n">Z3_mk_bvand</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx_ref</span><span class="p">(),</span> <span class="n">a</span><span class="o">.</span><span class="n">as_ast</span><span class="p">(),</span> <span class="n">b</span><span class="o">.</span><span class="n">as_ast</span><span class="p">()),</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__rand__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create the Z3 expression bitwise-or `other &amp; self`.</span>

<span class="sd">        &gt;&gt;&gt; x = BitVec(&#39;x&#39;, 32)</span>
<span class="sd">        &gt;&gt;&gt; 10 &amp; x</span>
<span class="sd">        10 &amp; x</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">_coerce_exprs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">BitVecRef</span><span class="p">(</span><span class="n">Z3_mk_bvand</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx_ref</span><span class="p">(),</span> <span class="n">b</span><span class="o">.</span><span class="n">as_ast</span><span class="p">(),</span> <span class="n">a</span><span class="o">.</span><span class="n">as_ast</span><span class="p">()),</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__xor__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create the Z3 expression bitwise-xor `self ^ other`.</span>

<span class="sd">        &gt;&gt;&gt; x = BitVec(&#39;x&#39;, 32)</span>
<span class="sd">        &gt;&gt;&gt; y = BitVec(&#39;y&#39;, 32)</span>
<span class="sd">        &gt;&gt;&gt; x ^ y</span>
<span class="sd">        x ^ y</span>
<span class="sd">        &gt;&gt;&gt; (x ^ y).sort()</span>
<span class="sd">        BitVec(32)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">_coerce_exprs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">BitVecRef</span><span class="p">(</span><span class="n">Z3_mk_bvxor</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx_ref</span><span class="p">(),</span> <span class="n">a</span><span class="o">.</span><span class="n">as_ast</span><span class="p">(),</span> <span class="n">b</span><span class="o">.</span><span class="n">as_ast</span><span class="p">()),</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__rxor__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create the Z3 expression bitwise-xor `other ^ self`.</span>

<span class="sd">        &gt;&gt;&gt; x = BitVec(&#39;x&#39;, 32)</span>
<span class="sd">        &gt;&gt;&gt; 10 ^ x</span>
<span class="sd">        10 ^ x</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">_coerce_exprs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">BitVecRef</span><span class="p">(</span><span class="n">Z3_mk_bvxor</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx_ref</span><span class="p">(),</span> <span class="n">b</span><span class="o">.</span><span class="n">as_ast</span><span class="p">(),</span> <span class="n">a</span><span class="o">.</span><span class="n">as_ast</span><span class="p">()),</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__pos__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return `self`.</span>

<span class="sd">        &gt;&gt;&gt; x = BitVec(&#39;x&#39;, 32)</span>
<span class="sd">        &gt;&gt;&gt; +x</span>
<span class="sd">        x</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="fm">__neg__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return an expression representing `-self`.</span>

<span class="sd">        &gt;&gt;&gt; x = BitVec(&#39;x&#39;, 32)</span>
<span class="sd">        &gt;&gt;&gt; -x</span>
<span class="sd">        -x</span>
<span class="sd">        &gt;&gt;&gt; simplify(-(-x))</span>
<span class="sd">        x</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">BitVecRef</span><span class="p">(</span><span class="n">Z3_mk_bvneg</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx_ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_ast</span><span class="p">()),</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__invert__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create the Z3 expression bitwise-not `~self`.</span>

<span class="sd">        &gt;&gt;&gt; x = BitVec(&#39;x&#39;, 32)</span>
<span class="sd">        &gt;&gt;&gt; ~x</span>
<span class="sd">        ~x</span>
<span class="sd">        &gt;&gt;&gt; simplify(~(~x))</span>
<span class="sd">        x</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">BitVecRef</span><span class="p">(</span><span class="n">Z3_mk_bvnot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx_ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_ast</span><span class="p">()),</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__div__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create the Z3 expression (signed) division `self / other`.</span>

<span class="sd">        Use the function UDiv() for unsigned division.</span>

<span class="sd">        &gt;&gt;&gt; x = BitVec(&#39;x&#39;, 32)</span>
<span class="sd">        &gt;&gt;&gt; y = BitVec(&#39;y&#39;, 32)</span>
<span class="sd">        &gt;&gt;&gt; x / y</span>
<span class="sd">        x/y</span>
<span class="sd">        &gt;&gt;&gt; (x / y).sort()</span>
<span class="sd">        BitVec(32)</span>
<span class="sd">        &gt;&gt;&gt; (x / y).sexpr()</span>
<span class="sd">        &#39;(bvsdiv x y)&#39;</span>
<span class="sd">        &gt;&gt;&gt; UDiv(x, y).sexpr()</span>
<span class="sd">        &#39;(bvudiv x y)&#39;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">_coerce_exprs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">BitVecRef</span><span class="p">(</span><span class="n">Z3_mk_bvsdiv</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx_ref</span><span class="p">(),</span> <span class="n">a</span><span class="o">.</span><span class="n">as_ast</span><span class="p">(),</span> <span class="n">b</span><span class="o">.</span><span class="n">as_ast</span><span class="p">()),</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__truediv__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create the Z3 expression (signed) division `self / other`.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__div__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__rdiv__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create the Z3 expression (signed) division `other / self`.</span>

<span class="sd">        Use the function UDiv() for unsigned division.</span>

<span class="sd">        &gt;&gt;&gt; x = BitVec(&#39;x&#39;, 32)</span>
<span class="sd">        &gt;&gt;&gt; 10 / x</span>
<span class="sd">        10/x</span>
<span class="sd">        &gt;&gt;&gt; (10 / x).sexpr()</span>
<span class="sd">        &#39;(bvsdiv #x0000000a x)&#39;</span>
<span class="sd">        &gt;&gt;&gt; UDiv(10, x).sexpr()</span>
<span class="sd">        &#39;(bvudiv #x0000000a x)&#39;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">_coerce_exprs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">BitVecRef</span><span class="p">(</span><span class="n">Z3_mk_bvsdiv</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx_ref</span><span class="p">(),</span> <span class="n">b</span><span class="o">.</span><span class="n">as_ast</span><span class="p">(),</span> <span class="n">a</span><span class="o">.</span><span class="n">as_ast</span><span class="p">()),</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__rtruediv__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create the Z3 expression (signed) division `other / self`.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__rdiv__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__mod__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create the Z3 expression (signed) mod `self % other`.</span>

<span class="sd">        Use the function URem() for unsigned remainder, and SRem() for signed remainder.</span>

<span class="sd">        &gt;&gt;&gt; x = BitVec(&#39;x&#39;, 32)</span>
<span class="sd">        &gt;&gt;&gt; y = BitVec(&#39;y&#39;, 32)</span>
<span class="sd">        &gt;&gt;&gt; x % y</span>
<span class="sd">        x%y</span>
<span class="sd">        &gt;&gt;&gt; (x % y).sort()</span>
<span class="sd">        BitVec(32)</span>
<span class="sd">        &gt;&gt;&gt; (x % y).sexpr()</span>
<span class="sd">        &#39;(bvsmod x y)&#39;</span>
<span class="sd">        &gt;&gt;&gt; URem(x, y).sexpr()</span>
<span class="sd">        &#39;(bvurem x y)&#39;</span>
<span class="sd">        &gt;&gt;&gt; SRem(x, y).sexpr()</span>
<span class="sd">        &#39;(bvsrem x y)&#39;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">_coerce_exprs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">BitVecRef</span><span class="p">(</span><span class="n">Z3_mk_bvsmod</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx_ref</span><span class="p">(),</span> <span class="n">a</span><span class="o">.</span><span class="n">as_ast</span><span class="p">(),</span> <span class="n">b</span><span class="o">.</span><span class="n">as_ast</span><span class="p">()),</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__rmod__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create the Z3 expression (signed) mod `other % self`.</span>

<span class="sd">        Use the function URem() for unsigned remainder, and SRem() for signed remainder.</span>

<span class="sd">        &gt;&gt;&gt; x = BitVec(&#39;x&#39;, 32)</span>
<span class="sd">        &gt;&gt;&gt; 10 % x</span>
<span class="sd">        10%x</span>
<span class="sd">        &gt;&gt;&gt; (10 % x).sexpr()</span>
<span class="sd">        &#39;(bvsmod #x0000000a x)&#39;</span>
<span class="sd">        &gt;&gt;&gt; URem(10, x).sexpr()</span>
<span class="sd">        &#39;(bvurem #x0000000a x)&#39;</span>
<span class="sd">        &gt;&gt;&gt; SRem(10, x).sexpr()</span>
<span class="sd">        &#39;(bvsrem #x0000000a x)&#39;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">_coerce_exprs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">BitVecRef</span><span class="p">(</span><span class="n">Z3_mk_bvsmod</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx_ref</span><span class="p">(),</span> <span class="n">b</span><span class="o">.</span><span class="n">as_ast</span><span class="p">(),</span> <span class="n">a</span><span class="o">.</span><span class="n">as_ast</span><span class="p">()),</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__le__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create the Z3 expression (signed) `other &lt;= self`.</span>

<span class="sd">        Use the function ULE() for unsigned less than or equal to.</span>

<span class="sd">        &gt;&gt;&gt; x, y = BitVecs(&#39;x y&#39;, 32)</span>
<span class="sd">        &gt;&gt;&gt; x &lt;= y</span>
<span class="sd">        x &lt;= y</span>
<span class="sd">        &gt;&gt;&gt; (x &lt;= y).sexpr()</span>
<span class="sd">        &#39;(bvsle x y)&#39;</span>
<span class="sd">        &gt;&gt;&gt; ULE(x, y).sexpr()</span>
<span class="sd">        &#39;(bvule x y)&#39;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">_coerce_exprs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">BoolRef</span><span class="p">(</span><span class="n">Z3_mk_bvsle</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx_ref</span><span class="p">(),</span> <span class="n">a</span><span class="o">.</span><span class="n">as_ast</span><span class="p">(),</span> <span class="n">b</span><span class="o">.</span><span class="n">as_ast</span><span class="p">()),</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__lt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create the Z3 expression (signed) `other &lt; self`.</span>

<span class="sd">        Use the function ULT() for unsigned less than.</span>

<span class="sd">        &gt;&gt;&gt; x, y = BitVecs(&#39;x y&#39;, 32)</span>
<span class="sd">        &gt;&gt;&gt; x &lt; y</span>
<span class="sd">        x &lt; y</span>
<span class="sd">        &gt;&gt;&gt; (x &lt; y).sexpr()</span>
<span class="sd">        &#39;(bvslt x y)&#39;</span>
<span class="sd">        &gt;&gt;&gt; ULT(x, y).sexpr()</span>
<span class="sd">        &#39;(bvult x y)&#39;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">_coerce_exprs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">BoolRef</span><span class="p">(</span><span class="n">Z3_mk_bvslt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx_ref</span><span class="p">(),</span> <span class="n">a</span><span class="o">.</span><span class="n">as_ast</span><span class="p">(),</span> <span class="n">b</span><span class="o">.</span><span class="n">as_ast</span><span class="p">()),</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__gt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create the Z3 expression (signed) `other &gt; self`.</span>

<span class="sd">        Use the function UGT() for unsigned greater than.</span>

<span class="sd">        &gt;&gt;&gt; x, y = BitVecs(&#39;x y&#39;, 32)</span>
<span class="sd">        &gt;&gt;&gt; x &gt; y</span>
<span class="sd">        x &gt; y</span>
<span class="sd">        &gt;&gt;&gt; (x &gt; y).sexpr()</span>
<span class="sd">        &#39;(bvsgt x y)&#39;</span>
<span class="sd">        &gt;&gt;&gt; UGT(x, y).sexpr()</span>
<span class="sd">        &#39;(bvugt x y)&#39;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">_coerce_exprs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">BoolRef</span><span class="p">(</span><span class="n">Z3_mk_bvsgt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx_ref</span><span class="p">(),</span> <span class="n">a</span><span class="o">.</span><span class="n">as_ast</span><span class="p">(),</span> <span class="n">b</span><span class="o">.</span><span class="n">as_ast</span><span class="p">()),</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__ge__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create the Z3 expression (signed) `other &gt;= self`.</span>

<span class="sd">        Use the function UGE() for unsigned greater than or equal to.</span>

<span class="sd">        &gt;&gt;&gt; x, y = BitVecs(&#39;x y&#39;, 32)</span>
<span class="sd">        &gt;&gt;&gt; x &gt;= y</span>
<span class="sd">        x &gt;= y</span>
<span class="sd">        &gt;&gt;&gt; (x &gt;= y).sexpr()</span>
<span class="sd">        &#39;(bvsge x y)&#39;</span>
<span class="sd">        &gt;&gt;&gt; UGE(x, y).sexpr()</span>
<span class="sd">        &#39;(bvuge x y)&#39;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">_coerce_exprs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">BoolRef</span><span class="p">(</span><span class="n">Z3_mk_bvsge</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx_ref</span><span class="p">(),</span> <span class="n">a</span><span class="o">.</span><span class="n">as_ast</span><span class="p">(),</span> <span class="n">b</span><span class="o">.</span><span class="n">as_ast</span><span class="p">()),</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__rshift__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create the Z3 expression (arithmetical) right shift `self &gt;&gt; other`</span>

<span class="sd">        Use the function LShR() for the right logical shift</span>

<span class="sd">        &gt;&gt;&gt; x, y = BitVecs(&#39;x y&#39;, 32)</span>
<span class="sd">        &gt;&gt;&gt; x &gt;&gt; y</span>
<span class="sd">        x &gt;&gt; y</span>
<span class="sd">        &gt;&gt;&gt; (x &gt;&gt; y).sexpr()</span>
<span class="sd">        &#39;(bvashr x y)&#39;</span>
<span class="sd">        &gt;&gt;&gt; LShR(x, y).sexpr()</span>
<span class="sd">        &#39;(bvlshr x y)&#39;</span>
<span class="sd">        &gt;&gt;&gt; BitVecVal(4, 3)</span>
<span class="sd">        4</span>
<span class="sd">        &gt;&gt;&gt; BitVecVal(4, 3).as_signed_long()</span>
<span class="sd">        -4</span>
<span class="sd">        &gt;&gt;&gt; simplify(BitVecVal(4, 3) &gt;&gt; 1).as_signed_long()</span>
<span class="sd">        -2</span>
<span class="sd">        &gt;&gt;&gt; simplify(BitVecVal(4, 3) &gt;&gt; 1)</span>
<span class="sd">        6</span>
<span class="sd">        &gt;&gt;&gt; simplify(LShR(BitVecVal(4, 3), 1))</span>
<span class="sd">        2</span>
<span class="sd">        &gt;&gt;&gt; simplify(BitVecVal(2, 3) &gt;&gt; 1)</span>
<span class="sd">        1</span>
<span class="sd">        &gt;&gt;&gt; simplify(LShR(BitVecVal(2, 3), 1))</span>
<span class="sd">        1</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">_coerce_exprs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">BitVecRef</span><span class="p">(</span><span class="n">Z3_mk_bvashr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx_ref</span><span class="p">(),</span> <span class="n">a</span><span class="o">.</span><span class="n">as_ast</span><span class="p">(),</span> <span class="n">b</span><span class="o">.</span><span class="n">as_ast</span><span class="p">()),</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__lshift__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create the Z3 expression left shift `self &lt;&lt; other`</span>

<span class="sd">        &gt;&gt;&gt; x, y = BitVecs(&#39;x y&#39;, 32)</span>
<span class="sd">        &gt;&gt;&gt; x &lt;&lt; y</span>
<span class="sd">        x &lt;&lt; y</span>
<span class="sd">        &gt;&gt;&gt; (x &lt;&lt; y).sexpr()</span>
<span class="sd">        &#39;(bvshl x y)&#39;</span>
<span class="sd">        &gt;&gt;&gt; simplify(BitVecVal(2, 3) &lt;&lt; 1)</span>
<span class="sd">        4</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">_coerce_exprs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">BitVecRef</span><span class="p">(</span><span class="n">Z3_mk_bvshl</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx_ref</span><span class="p">(),</span> <span class="n">a</span><span class="o">.</span><span class="n">as_ast</span><span class="p">(),</span> <span class="n">b</span><span class="o">.</span><span class="n">as_ast</span><span class="p">()),</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__rrshift__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create the Z3 expression (arithmetical) right shift `other` &gt;&gt; `self`.</span>

<span class="sd">        Use the function LShR() for the right logical shift</span>

<span class="sd">        &gt;&gt;&gt; x = BitVec(&#39;x&#39;, 32)</span>
<span class="sd">        &gt;&gt;&gt; 10 &gt;&gt; x</span>
<span class="sd">        10 &gt;&gt; x</span>
<span class="sd">        &gt;&gt;&gt; (10 &gt;&gt; x).sexpr()</span>
<span class="sd">        &#39;(bvashr #x0000000a x)&#39;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">_coerce_exprs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">BitVecRef</span><span class="p">(</span><span class="n">Z3_mk_bvashr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx_ref</span><span class="p">(),</span> <span class="n">b</span><span class="o">.</span><span class="n">as_ast</span><span class="p">(),</span> <span class="n">a</span><span class="o">.</span><span class="n">as_ast</span><span class="p">()),</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__rlshift__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create the Z3 expression left shift `other &lt;&lt; self`.</span>

<span class="sd">        Use the function LShR() for the right logical shift</span>

<span class="sd">        &gt;&gt;&gt; x = BitVec(&#39;x&#39;, 32)</span>
<span class="sd">        &gt;&gt;&gt; 10 &lt;&lt; x</span>
<span class="sd">        10 &lt;&lt; x</span>
<span class="sd">        &gt;&gt;&gt; (10 &lt;&lt; x).sexpr()</span>
<span class="sd">        &#39;(bvshl #x0000000a x)&#39;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">_coerce_exprs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">BitVecRef</span><span class="p">(</span><span class="n">Z3_mk_bvshl</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx_ref</span><span class="p">(),</span> <span class="n">b</span><span class="o">.</span><span class="n">as_ast</span><span class="p">(),</span> <span class="n">a</span><span class="o">.</span><span class="n">as_ast</span><span class="p">()),</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">BitVecNumRef</span><span class="p">(</span><span class="n">BitVecRef</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Bit-vector values.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">as_long</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a Z3 bit-vector numeral as a Python long (bignum) numeral.</span>

<span class="sd">        &gt;&gt;&gt; v = BitVecVal(0xbadc0de, 32)</span>
<span class="sd">        &gt;&gt;&gt; v</span>
<span class="sd">        195936478</span>
<span class="sd">        &gt;&gt;&gt; print(&quot;0x%.8x&quot; % v.as_long())</span>
<span class="sd">        0x0badc0de</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">as_string</span><span class="p">())</span>

    <span class="k">def</span> <span class="nf">as_signed_long</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a Z3 bit-vector numeral as a Python long (bignum) numeral.</span>
<span class="sd">        The most significant bit is assumed to be the sign.</span>

<span class="sd">        &gt;&gt;&gt; BitVecVal(4, 3).as_signed_long()</span>
<span class="sd">        -4</span>
<span class="sd">        &gt;&gt;&gt; BitVecVal(7, 3).as_signed_long()</span>
<span class="sd">        -1</span>
<span class="sd">        &gt;&gt;&gt; BitVecVal(3, 3).as_signed_long()</span>
<span class="sd">        3</span>
<span class="sd">        &gt;&gt;&gt; BitVecVal(2**32 - 1, 32).as_signed_long()</span>
<span class="sd">        -1</span>
<span class="sd">        &gt;&gt;&gt; BitVecVal(2**64 - 1, 64).as_signed_long()</span>
<span class="sd">        -1</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">sz</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">()</span>
        <span class="n">val</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_long</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">val</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="o">**</span><span class="p">(</span><span class="n">sz</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">val</span> <span class="o">=</span> <span class="n">val</span> <span class="o">-</span> <span class="mi">2</span><span class="o">**</span><span class="n">sz</span>
        <span class="k">if</span> <span class="n">val</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">2</span><span class="o">**</span><span class="p">(</span><span class="n">sz</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">val</span> <span class="o">=</span> <span class="n">val</span> <span class="o">+</span> <span class="mi">2</span><span class="o">**</span><span class="n">sz</span>
        <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">as_string</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Z3_get_numeral_string</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx_ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_ast</span><span class="p">())</span>

    <span class="k">def</span> <span class="nf">as_binary_string</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Z3_get_numeral_binary_string</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx_ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_ast</span><span class="p">())</span>


<span class="k">def</span> <span class="nf">is_bv</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return `True` if `a` is a Z3 bit-vector expression.</span>

<span class="sd">    &gt;&gt;&gt; b = BitVec(&#39;b&#39;, 32)</span>
<span class="sd">    &gt;&gt;&gt; is_bv(b)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; is_bv(b + 10)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; is_bv(Int(&#39;x&#39;))</span>
<span class="sd">    False</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">BitVecRef</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">is_bv_value</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return `True` if `a` is a Z3 bit-vector numeral value.</span>

<span class="sd">    &gt;&gt;&gt; b = BitVec(&#39;b&#39;, 32)</span>
<span class="sd">    &gt;&gt;&gt; is_bv_value(b)</span>
<span class="sd">    False</span>
<span class="sd">    &gt;&gt;&gt; b = BitVecVal(10, 32)</span>
<span class="sd">    &gt;&gt;&gt; b</span>
<span class="sd">    10</span>
<span class="sd">    &gt;&gt;&gt; is_bv_value(b)</span>
<span class="sd">    True</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">is_bv</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="ow">and</span> <span class="n">_is_numeral</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">ctx</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">as_ast</span><span class="p">())</span>


<span class="k">def</span> <span class="nf">BV2Int</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">is_signed</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return the Z3 expression BV2Int(a).</span>

<span class="sd">    &gt;&gt;&gt; b = BitVec(&#39;b&#39;, 3)</span>
<span class="sd">    &gt;&gt;&gt; BV2Int(b).sort()</span>
<span class="sd">    Int</span>
<span class="sd">    &gt;&gt;&gt; x = Int(&#39;x&#39;)</span>
<span class="sd">    &gt;&gt;&gt; x &gt; BV2Int(b)</span>
<span class="sd">    x &gt; BV2Int(b)</span>
<span class="sd">    &gt;&gt;&gt; x &gt; BV2Int(b, is_signed=False)</span>
<span class="sd">    x &gt; BV2Int(b)</span>
<span class="sd">    &gt;&gt;&gt; x &gt; BV2Int(b, is_signed=True)</span>
<span class="sd">    x &gt; If(b &lt; 0, BV2Int(b) - 8, BV2Int(b))</span>
<span class="sd">    &gt;&gt;&gt; solve(x &gt; BV2Int(b), b == 1, x &lt; 3)</span>
<span class="sd">    [x = 2, b = 1]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">z3_debug</span><span class="p">():</span>
        <span class="n">_z3_assert</span><span class="p">(</span><span class="n">is_bv</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="s2">&quot;First argument must be a Z3 bit-vector expression&quot;</span><span class="p">)</span>
    <span class="n">ctx</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">ctx</span>
    <span class="c1"># investigate problem with bv2int</span>
    <span class="k">return</span> <span class="n">ArithRef</span><span class="p">(</span><span class="n">Z3_mk_bv2int</span><span class="p">(</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="n">a</span><span class="o">.</span><span class="n">as_ast</span><span class="p">(),</span> <span class="n">is_signed</span><span class="p">),</span> <span class="n">ctx</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">Int2BV</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">num_bits</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return the z3 expression Int2BV(a, num_bits).</span>
<span class="sd">    It is a bit-vector of width num_bits and represents the</span>
<span class="sd">    modulo of a by 2^num_bits</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ctx</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">ctx</span>
    <span class="k">return</span> <span class="n">BitVecRef</span><span class="p">(</span><span class="n">Z3_mk_int2bv</span><span class="p">(</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="n">num_bits</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">as_ast</span><span class="p">()),</span> <span class="n">ctx</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">BitVecSort</span><span class="p">(</span><span class="n">sz</span><span class="p">,</span> <span class="n">ctx</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return a Z3 bit-vector sort of the given size. If `ctx=None`, then the global context is used.</span>

<span class="sd">    &gt;&gt;&gt; Byte = BitVecSort(8)</span>
<span class="sd">    &gt;&gt;&gt; Word = BitVecSort(16)</span>
<span class="sd">    &gt;&gt;&gt; Byte</span>
<span class="sd">    BitVec(8)</span>
<span class="sd">    &gt;&gt;&gt; x = Const(&#39;x&#39;, Byte)</span>
<span class="sd">    &gt;&gt;&gt; eq(x, BitVec(&#39;x&#39;, 8))</span>
<span class="sd">    True</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ctx</span> <span class="o">=</span> <span class="n">_get_ctx</span><span class="p">(</span><span class="n">ctx</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">BitVecSortRef</span><span class="p">(</span><span class="n">Z3_mk_bv_sort</span><span class="p">(</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="n">sz</span><span class="p">),</span> <span class="n">ctx</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">BitVecVal</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">bv</span><span class="p">,</span> <span class="n">ctx</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return a bit-vector value with the given number of bits. If `ctx=None`, then the global context is used.</span>

<span class="sd">    &gt;&gt;&gt; v = BitVecVal(10, 32)</span>
<span class="sd">    &gt;&gt;&gt; v</span>
<span class="sd">    10</span>
<span class="sd">    &gt;&gt;&gt; print(&quot;0x%.8x&quot; % v.as_long())</span>
<span class="sd">    0x0000000a</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">is_bv_sort</span><span class="p">(</span><span class="n">bv</span><span class="p">):</span>
        <span class="n">ctx</span> <span class="o">=</span> <span class="n">bv</span><span class="o">.</span><span class="n">ctx</span>
        <span class="k">return</span> <span class="n">BitVecNumRef</span><span class="p">(</span><span class="n">Z3_mk_numeral</span><span class="p">(</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="n">_to_int_str</span><span class="p">(</span><span class="n">val</span><span class="p">),</span> <span class="n">bv</span><span class="o">.</span><span class="n">ast</span><span class="p">),</span> <span class="n">ctx</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">ctx</span> <span class="o">=</span> <span class="n">_get_ctx</span><span class="p">(</span><span class="n">ctx</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">BitVecNumRef</span><span class="p">(</span><span class="n">Z3_mk_numeral</span><span class="p">(</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="n">_to_int_str</span><span class="p">(</span><span class="n">val</span><span class="p">),</span> <span class="n">BitVecSort</span><span class="p">(</span><span class="n">bv</span><span class="p">,</span> <span class="n">ctx</span><span class="p">)</span><span class="o">.</span><span class="n">ast</span><span class="p">),</span> <span class="n">ctx</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">BitVec</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">bv</span><span class="p">,</span> <span class="n">ctx</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return a bit-vector constant named `name`. `bv` may be the number of bits of a bit-vector sort.</span>
<span class="sd">    If `ctx=None`, then the global context is used.</span>

<span class="sd">    &gt;&gt;&gt; x  = BitVec(&#39;x&#39;, 16)</span>
<span class="sd">    &gt;&gt;&gt; is_bv(x)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; x.size()</span>
<span class="sd">    16</span>
<span class="sd">    &gt;&gt;&gt; x.sort()</span>
<span class="sd">    BitVec(16)</span>
<span class="sd">    &gt;&gt;&gt; word = BitVecSort(16)</span>
<span class="sd">    &gt;&gt;&gt; x2 = BitVec(&#39;x&#39;, word)</span>
<span class="sd">    &gt;&gt;&gt; eq(x, x2)</span>
<span class="sd">    True</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">bv</span><span class="p">,</span> <span class="n">BitVecSortRef</span><span class="p">):</span>
        <span class="n">ctx</span> <span class="o">=</span> <span class="n">bv</span><span class="o">.</span><span class="n">ctx</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">ctx</span> <span class="o">=</span> <span class="n">_get_ctx</span><span class="p">(</span><span class="n">ctx</span><span class="p">)</span>
        <span class="n">bv</span> <span class="o">=</span> <span class="n">BitVecSort</span><span class="p">(</span><span class="n">bv</span><span class="p">,</span> <span class="n">ctx</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">BitVecRef</span><span class="p">(</span><span class="n">Z3_mk_const</span><span class="p">(</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="n">to_symbol</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">ctx</span><span class="p">),</span> <span class="n">bv</span><span class="o">.</span><span class="n">ast</span><span class="p">),</span> <span class="n">ctx</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">BitVecs</span><span class="p">(</span><span class="n">names</span><span class="p">,</span> <span class="n">bv</span><span class="p">,</span> <span class="n">ctx</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return a tuple of bit-vector constants of size bv.</span>

<span class="sd">    &gt;&gt;&gt; x, y, z = BitVecs(&#39;x y z&#39;, 16)</span>
<span class="sd">    &gt;&gt;&gt; x.size()</span>
<span class="sd">    16</span>
<span class="sd">    &gt;&gt;&gt; x.sort()</span>
<span class="sd">    BitVec(16)</span>
<span class="sd">    &gt;&gt;&gt; Sum(x, y, z)</span>
<span class="sd">    0 + x + y + z</span>
<span class="sd">    &gt;&gt;&gt; Product(x, y, z)</span>
<span class="sd">    1*x*y*z</span>
<span class="sd">    &gt;&gt;&gt; simplify(Product(x, y, z))</span>
<span class="sd">    x*y*z</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ctx</span> <span class="o">=</span> <span class="n">_get_ctx</span><span class="p">(</span><span class="n">ctx</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">names</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="n">names</span> <span class="o">=</span> <span class="n">names</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot; &quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">BitVec</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">bv</span><span class="p">,</span> <span class="n">ctx</span><span class="p">)</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">names</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">Concat</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Create a Z3 bit-vector concatenation expression.</span>

<span class="sd">    &gt;&gt;&gt; v = BitVecVal(1, 4)</span>
<span class="sd">    &gt;&gt;&gt; Concat(v, v+1, v)</span>
<span class="sd">    Concat(Concat(1, 1 + 1), 1)</span>
<span class="sd">    &gt;&gt;&gt; simplify(Concat(v, v+1, v))</span>
<span class="sd">    289</span>
<span class="sd">    &gt;&gt;&gt; print(&quot;%.3x&quot; % simplify(Concat(v, v+1, v)).as_long())</span>
<span class="sd">    121</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">args</span> <span class="o">=</span> <span class="n">_get_args</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
    <span class="n">sz</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">z3_debug</span><span class="p">():</span>
        <span class="n">_z3_assert</span><span class="p">(</span><span class="n">sz</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">,</span> <span class="s2">&quot;At least two arguments expected.&quot;</span><span class="p">)</span>

    <span class="n">ctx</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">args</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">is_expr</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
            <span class="n">ctx</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">ctx</span>
            <span class="k">break</span>
    <span class="k">if</span> <span class="n">is_seq</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">str</span><span class="p">):</span>
        <span class="n">args</span> <span class="o">=</span> <span class="p">[</span><span class="n">_coerce_seq</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">ctx</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">args</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">z3_debug</span><span class="p">():</span>
            <span class="n">_z3_assert</span><span class="p">(</span><span class="nb">all</span><span class="p">([</span><span class="n">is_seq</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">args</span><span class="p">]),</span> <span class="s2">&quot;All arguments must be sequence expressions.&quot;</span><span class="p">)</span>
        <span class="n">v</span> <span class="o">=</span> <span class="p">(</span><span class="n">Ast</span> <span class="o">*</span> <span class="n">sz</span><span class="p">)()</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">sz</span><span class="p">):</span>
            <span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">as_ast</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">SeqRef</span><span class="p">(</span><span class="n">Z3_mk_seq_concat</span><span class="p">(</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="n">sz</span><span class="p">,</span> <span class="n">v</span><span class="p">),</span> <span class="n">ctx</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">is_re</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
        <span class="k">if</span> <span class="n">z3_debug</span><span class="p">():</span>
            <span class="n">_z3_assert</span><span class="p">(</span><span class="nb">all</span><span class="p">([</span><span class="n">is_re</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">args</span><span class="p">]),</span> <span class="s2">&quot;All arguments must be regular expressions.&quot;</span><span class="p">)</span>
        <span class="n">v</span> <span class="o">=</span> <span class="p">(</span><span class="n">Ast</span> <span class="o">*</span> <span class="n">sz</span><span class="p">)()</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">sz</span><span class="p">):</span>
            <span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">as_ast</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">ReRef</span><span class="p">(</span><span class="n">Z3_mk_re_concat</span><span class="p">(</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="n">sz</span><span class="p">,</span> <span class="n">v</span><span class="p">),</span> <span class="n">ctx</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">z3_debug</span><span class="p">():</span>
        <span class="n">_z3_assert</span><span class="p">(</span><span class="nb">all</span><span class="p">([</span><span class="n">is_bv</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">args</span><span class="p">]),</span> <span class="s2">&quot;All arguments must be Z3 bit-vector expressions.&quot;</span><span class="p">)</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">sz</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">BitVecRef</span><span class="p">(</span><span class="n">Z3_mk_concat</span><span class="p">(</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="n">r</span><span class="o">.</span><span class="n">as_ast</span><span class="p">(),</span> <span class="n">args</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">as_ast</span><span class="p">()),</span> <span class="n">ctx</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">r</span>


<span class="k">def</span> <span class="nf">Extract</span><span class="p">(</span><span class="n">high</span><span class="p">,</span> <span class="n">low</span><span class="p">,</span> <span class="n">a</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Create a Z3 bit-vector extraction expression.</span>
<span class="sd">    Extract is overloaded to also work on sequence extraction.</span>
<span class="sd">    The functions SubString and SubSeq are redirected to Extract.</span>
<span class="sd">    For this case, the arguments are reinterpreted as:</span>
<span class="sd">        high - is a sequence (string)</span>
<span class="sd">        low  - is an offset</span>
<span class="sd">        a    - is the length to be extracted</span>

<span class="sd">    &gt;&gt;&gt; x = BitVec(&#39;x&#39;, 8)</span>
<span class="sd">    &gt;&gt;&gt; Extract(6, 2, x)</span>
<span class="sd">    Extract(6, 2, x)</span>
<span class="sd">    &gt;&gt;&gt; Extract(6, 2, x).sort()</span>
<span class="sd">    BitVec(5)</span>
<span class="sd">    &gt;&gt;&gt; simplify(Extract(StringVal(&quot;abcd&quot;),2,1))</span>
<span class="sd">    &quot;c&quot;</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">high</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="n">high</span> <span class="o">=</span> <span class="n">StringVal</span><span class="p">(</span><span class="n">high</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">is_seq</span><span class="p">(</span><span class="n">high</span><span class="p">):</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">high</span>
        <span class="n">offset</span><span class="p">,</span> <span class="n">length</span> <span class="o">=</span> <span class="n">_coerce_exprs</span><span class="p">(</span><span class="n">low</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">s</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">SeqRef</span><span class="p">(</span><span class="n">Z3_mk_seq_extract</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">ctx_ref</span><span class="p">(),</span> <span class="n">s</span><span class="o">.</span><span class="n">as_ast</span><span class="p">(),</span> <span class="n">offset</span><span class="o">.</span><span class="n">as_ast</span><span class="p">(),</span> <span class="n">length</span><span class="o">.</span><span class="n">as_ast</span><span class="p">()),</span> <span class="n">s</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">z3_debug</span><span class="p">():</span>
        <span class="n">_z3_assert</span><span class="p">(</span><span class="n">low</span> <span class="o">&lt;=</span> <span class="n">high</span><span class="p">,</span> <span class="s2">&quot;First argument must be greater than or equal to second argument&quot;</span><span class="p">)</span>
        <span class="n">_z3_assert</span><span class="p">(</span><span class="n">_is_int</span><span class="p">(</span><span class="n">high</span><span class="p">)</span> <span class="ow">and</span> <span class="n">high</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">_is_int</span><span class="p">(</span><span class="n">low</span><span class="p">)</span> <span class="ow">and</span> <span class="n">low</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">,</span>
                   <span class="s2">&quot;First and second arguments must be non negative integers&quot;</span><span class="p">)</span>
        <span class="n">_z3_assert</span><span class="p">(</span><span class="n">is_bv</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="s2">&quot;Third argument must be a Z3 bit-vector expression&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">BitVecRef</span><span class="p">(</span><span class="n">Z3_mk_extract</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">ctx_ref</span><span class="p">(),</span> <span class="n">high</span><span class="p">,</span> <span class="n">low</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">as_ast</span><span class="p">()),</span> <span class="n">a</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_check_bv_args</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">z3_debug</span><span class="p">():</span>
        <span class="n">_z3_assert</span><span class="p">(</span><span class="n">is_bv</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="ow">or</span> <span class="n">is_bv</span><span class="p">(</span><span class="n">b</span><span class="p">),</span> <span class="s2">&quot;First or second argument must be a Z3 bit-vector expression&quot;</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">ULE</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Create the Z3 expression (unsigned) `other &lt;= self`.</span>

<span class="sd">    Use the operator &lt;= for signed less than or equal to.</span>

<span class="sd">    &gt;&gt;&gt; x, y = BitVecs(&#39;x y&#39;, 32)</span>
<span class="sd">    &gt;&gt;&gt; ULE(x, y)</span>
<span class="sd">    ULE(x, y)</span>
<span class="sd">    &gt;&gt;&gt; (x &lt;= y).sexpr()</span>
<span class="sd">    &#39;(bvsle x y)&#39;</span>
<span class="sd">    &gt;&gt;&gt; ULE(x, y).sexpr()</span>
<span class="sd">    &#39;(bvule x y)&#39;</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_check_bv_args</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
    <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">_coerce_exprs</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">BoolRef</span><span class="p">(</span><span class="n">Z3_mk_bvule</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">ctx_ref</span><span class="p">(),</span> <span class="n">a</span><span class="o">.</span><span class="n">as_ast</span><span class="p">(),</span> <span class="n">b</span><span class="o">.</span><span class="n">as_ast</span><span class="p">()),</span> <span class="n">a</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">ULT</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Create the Z3 expression (unsigned) `other &lt; self`.</span>

<span class="sd">    Use the operator &lt; for signed less than.</span>

<span class="sd">    &gt;&gt;&gt; x, y = BitVecs(&#39;x y&#39;, 32)</span>
<span class="sd">    &gt;&gt;&gt; ULT(x, y)</span>
<span class="sd">    ULT(x, y)</span>
<span class="sd">    &gt;&gt;&gt; (x &lt; y).sexpr()</span>
<span class="sd">    &#39;(bvslt x y)&#39;</span>
<span class="sd">    &gt;&gt;&gt; ULT(x, y).sexpr()</span>
<span class="sd">    &#39;(bvult x y)&#39;</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_check_bv_args</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
    <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">_coerce_exprs</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">BoolRef</span><span class="p">(</span><span class="n">Z3_mk_bvult</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">ctx_ref</span><span class="p">(),</span> <span class="n">a</span><span class="o">.</span><span class="n">as_ast</span><span class="p">(),</span> <span class="n">b</span><span class="o">.</span><span class="n">as_ast</span><span class="p">()),</span> <span class="n">a</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">UGE</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Create the Z3 expression (unsigned) `other &gt;= self`.</span>

<span class="sd">    Use the operator &gt;= for signed greater than or equal to.</span>

<span class="sd">    &gt;&gt;&gt; x, y = BitVecs(&#39;x y&#39;, 32)</span>
<span class="sd">    &gt;&gt;&gt; UGE(x, y)</span>
<span class="sd">    UGE(x, y)</span>
<span class="sd">    &gt;&gt;&gt; (x &gt;= y).sexpr()</span>
<span class="sd">    &#39;(bvsge x y)&#39;</span>
<span class="sd">    &gt;&gt;&gt; UGE(x, y).sexpr()</span>
<span class="sd">    &#39;(bvuge x y)&#39;</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_check_bv_args</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
    <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">_coerce_exprs</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">BoolRef</span><span class="p">(</span><span class="n">Z3_mk_bvuge</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">ctx_ref</span><span class="p">(),</span> <span class="n">a</span><span class="o">.</span><span class="n">as_ast</span><span class="p">(),</span> <span class="n">b</span><span class="o">.</span><span class="n">as_ast</span><span class="p">()),</span> <span class="n">a</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">UGT</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Create the Z3 expression (unsigned) `other &gt; self`.</span>

<span class="sd">    Use the operator &gt; for signed greater than.</span>

<span class="sd">    &gt;&gt;&gt; x, y = BitVecs(&#39;x y&#39;, 32)</span>
<span class="sd">    &gt;&gt;&gt; UGT(x, y)</span>
<span class="sd">    UGT(x, y)</span>
<span class="sd">    &gt;&gt;&gt; (x &gt; y).sexpr()</span>
<span class="sd">    &#39;(bvsgt x y)&#39;</span>
<span class="sd">    &gt;&gt;&gt; UGT(x, y).sexpr()</span>
<span class="sd">    &#39;(bvugt x y)&#39;</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_check_bv_args</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
    <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">_coerce_exprs</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">BoolRef</span><span class="p">(</span><span class="n">Z3_mk_bvugt</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">ctx_ref</span><span class="p">(),</span> <span class="n">a</span><span class="o">.</span><span class="n">as_ast</span><span class="p">(),</span> <span class="n">b</span><span class="o">.</span><span class="n">as_ast</span><span class="p">()),</span> <span class="n">a</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">UDiv</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Create the Z3 expression (unsigned) division `self / other`.</span>

<span class="sd">    Use the operator / for signed division.</span>

<span class="sd">    &gt;&gt;&gt; x = BitVec(&#39;x&#39;, 32)</span>
<span class="sd">    &gt;&gt;&gt; y = BitVec(&#39;y&#39;, 32)</span>
<span class="sd">    &gt;&gt;&gt; UDiv(x, y)</span>
<span class="sd">    UDiv(x, y)</span>
<span class="sd">    &gt;&gt;&gt; UDiv(x, y).sort()</span>
<span class="sd">    BitVec(32)</span>
<span class="sd">    &gt;&gt;&gt; (x / y).sexpr()</span>
<span class="sd">    &#39;(bvsdiv x y)&#39;</span>
<span class="sd">    &gt;&gt;&gt; UDiv(x, y).sexpr()</span>
<span class="sd">    &#39;(bvudiv x y)&#39;</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_check_bv_args</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
    <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">_coerce_exprs</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">BitVecRef</span><span class="p">(</span><span class="n">Z3_mk_bvudiv</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">ctx_ref</span><span class="p">(),</span> <span class="n">a</span><span class="o">.</span><span class="n">as_ast</span><span class="p">(),</span> <span class="n">b</span><span class="o">.</span><span class="n">as_ast</span><span class="p">()),</span> <span class="n">a</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">URem</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Create the Z3 expression (unsigned) remainder `self % other`.</span>

<span class="sd">    Use the operator % for signed modulus, and SRem() for signed remainder.</span>

<span class="sd">    &gt;&gt;&gt; x = BitVec(&#39;x&#39;, 32)</span>
<span class="sd">    &gt;&gt;&gt; y = BitVec(&#39;y&#39;, 32)</span>
<span class="sd">    &gt;&gt;&gt; URem(x, y)</span>
<span class="sd">    URem(x, y)</span>
<span class="sd">    &gt;&gt;&gt; URem(x, y).sort()</span>
<span class="sd">    BitVec(32)</span>
<span class="sd">    &gt;&gt;&gt; (x % y).sexpr()</span>
<span class="sd">    &#39;(bvsmod x y)&#39;</span>
<span class="sd">    &gt;&gt;&gt; URem(x, y).sexpr()</span>
<span class="sd">    &#39;(bvurem x y)&#39;</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_check_bv_args</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
    <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">_coerce_exprs</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">BitVecRef</span><span class="p">(</span><span class="n">Z3_mk_bvurem</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">ctx_ref</span><span class="p">(),</span> <span class="n">a</span><span class="o">.</span><span class="n">as_ast</span><span class="p">(),</span> <span class="n">b</span><span class="o">.</span><span class="n">as_ast</span><span class="p">()),</span> <span class="n">a</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">SRem</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Create the Z3 expression signed remainder.</span>

<span class="sd">    Use the operator % for signed modulus, and URem() for unsigned remainder.</span>

<span class="sd">    &gt;&gt;&gt; x = BitVec(&#39;x&#39;, 32)</span>
<span class="sd">    &gt;&gt;&gt; y = BitVec(&#39;y&#39;, 32)</span>
<span class="sd">    &gt;&gt;&gt; SRem(x, y)</span>
<span class="sd">    SRem(x, y)</span>
<span class="sd">    &gt;&gt;&gt; SRem(x, y).sort()</span>
<span class="sd">    BitVec(32)</span>
<span class="sd">    &gt;&gt;&gt; (x % y).sexpr()</span>
<span class="sd">    &#39;(bvsmod x y)&#39;</span>
<span class="sd">    &gt;&gt;&gt; SRem(x, y).sexpr()</span>
<span class="sd">    &#39;(bvsrem x y)&#39;</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_check_bv_args</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
    <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">_coerce_exprs</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">BitVecRef</span><span class="p">(</span><span class="n">Z3_mk_bvsrem</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">ctx_ref</span><span class="p">(),</span> <span class="n">a</span><span class="o">.</span><span class="n">as_ast</span><span class="p">(),</span> <span class="n">b</span><span class="o">.</span><span class="n">as_ast</span><span class="p">()),</span> <span class="n">a</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">LShR</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Create the Z3 expression logical right shift.</span>

<span class="sd">    Use the operator &gt;&gt; for the arithmetical right shift.</span>

<span class="sd">    &gt;&gt;&gt; x, y = BitVecs(&#39;x y&#39;, 32)</span>
<span class="sd">    &gt;&gt;&gt; LShR(x, y)</span>
<span class="sd">    LShR(x, y)</span>
<span class="sd">    &gt;&gt;&gt; (x &gt;&gt; y).sexpr()</span>
<span class="sd">    &#39;(bvashr x y)&#39;</span>
<span class="sd">    &gt;&gt;&gt; LShR(x, y).sexpr()</span>
<span class="sd">    &#39;(bvlshr x y)&#39;</span>
<span class="sd">    &gt;&gt;&gt; BitVecVal(4, 3)</span>
<span class="sd">    4</span>
<span class="sd">    &gt;&gt;&gt; BitVecVal(4, 3).as_signed_long()</span>
<span class="sd">    -4</span>
<span class="sd">    &gt;&gt;&gt; simplify(BitVecVal(4, 3) &gt;&gt; 1).as_signed_long()</span>
<span class="sd">    -2</span>
<span class="sd">    &gt;&gt;&gt; simplify(BitVecVal(4, 3) &gt;&gt; 1)</span>
<span class="sd">    6</span>
<span class="sd">    &gt;&gt;&gt; simplify(LShR(BitVecVal(4, 3), 1))</span>
<span class="sd">    2</span>
<span class="sd">    &gt;&gt;&gt; simplify(BitVecVal(2, 3) &gt;&gt; 1)</span>
<span class="sd">    1</span>
<span class="sd">    &gt;&gt;&gt; simplify(LShR(BitVecVal(2, 3), 1))</span>
<span class="sd">    1</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_check_bv_args</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
    <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">_coerce_exprs</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">BitVecRef</span><span class="p">(</span><span class="n">Z3_mk_bvlshr</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">ctx_ref</span><span class="p">(),</span> <span class="n">a</span><span class="o">.</span><span class="n">as_ast</span><span class="p">(),</span> <span class="n">b</span><span class="o">.</span><span class="n">as_ast</span><span class="p">()),</span> <span class="n">a</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">RotateLeft</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return an expression representing `a` rotated to the left `b` times.</span>

<span class="sd">    &gt;&gt;&gt; a, b = BitVecs(&#39;a b&#39;, 16)</span>
<span class="sd">    &gt;&gt;&gt; RotateLeft(a, b)</span>
<span class="sd">    RotateLeft(a, b)</span>
<span class="sd">    &gt;&gt;&gt; simplify(RotateLeft(a, 0))</span>
<span class="sd">    a</span>
<span class="sd">    &gt;&gt;&gt; simplify(RotateLeft(a, 16))</span>
<span class="sd">    a</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_check_bv_args</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
    <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">_coerce_exprs</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">BitVecRef</span><span class="p">(</span><span class="n">Z3_mk_ext_rotate_left</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">ctx_ref</span><span class="p">(),</span> <span class="n">a</span><span class="o">.</span><span class="n">as_ast</span><span class="p">(),</span> <span class="n">b</span><span class="o">.</span><span class="n">as_ast</span><span class="p">()),</span> <span class="n">a</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">RotateRight</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return an expression representing `a` rotated to the right `b` times.</span>

<span class="sd">    &gt;&gt;&gt; a, b = BitVecs(&#39;a b&#39;, 16)</span>
<span class="sd">    &gt;&gt;&gt; RotateRight(a, b)</span>
<span class="sd">    RotateRight(a, b)</span>
<span class="sd">    &gt;&gt;&gt; simplify(RotateRight(a, 0))</span>
<span class="sd">    a</span>
<span class="sd">    &gt;&gt;&gt; simplify(RotateRight(a, 16))</span>
<span class="sd">    a</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_check_bv_args</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
    <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">_coerce_exprs</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">BitVecRef</span><span class="p">(</span><span class="n">Z3_mk_ext_rotate_right</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">ctx_ref</span><span class="p">(),</span> <span class="n">a</span><span class="o">.</span><span class="n">as_ast</span><span class="p">(),</span> <span class="n">b</span><span class="o">.</span><span class="n">as_ast</span><span class="p">()),</span> <span class="n">a</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">SignExt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">a</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return a bit-vector expression with `n` extra sign-bits.</span>

<span class="sd">    &gt;&gt;&gt; x = BitVec(&#39;x&#39;, 16)</span>
<span class="sd">    &gt;&gt;&gt; n = SignExt(8, x)</span>
<span class="sd">    &gt;&gt;&gt; n.size()</span>
<span class="sd">    24</span>
<span class="sd">    &gt;&gt;&gt; n</span>
<span class="sd">    SignExt(8, x)</span>
<span class="sd">    &gt;&gt;&gt; n.sort()</span>
<span class="sd">    BitVec(24)</span>
<span class="sd">    &gt;&gt;&gt; v0 = BitVecVal(2, 2)</span>
<span class="sd">    &gt;&gt;&gt; v0</span>
<span class="sd">    2</span>
<span class="sd">    &gt;&gt;&gt; v0.size()</span>
<span class="sd">    2</span>
<span class="sd">    &gt;&gt;&gt; v  = simplify(SignExt(6, v0))</span>
<span class="sd">    &gt;&gt;&gt; v</span>
<span class="sd">    254</span>
<span class="sd">    &gt;&gt;&gt; v.size()</span>
<span class="sd">    8</span>
<span class="sd">    &gt;&gt;&gt; print(&quot;%.x&quot; % v.as_long())</span>
<span class="sd">    fe</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">z3_debug</span><span class="p">():</span>
        <span class="n">_z3_assert</span><span class="p">(</span><span class="n">_is_int</span><span class="p">(</span><span class="n">n</span><span class="p">),</span> <span class="s2">&quot;First argument must be an integer&quot;</span><span class="p">)</span>
        <span class="n">_z3_assert</span><span class="p">(</span><span class="n">is_bv</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="s2">&quot;Second argument must be a Z3 bit-vector expression&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">BitVecRef</span><span class="p">(</span><span class="n">Z3_mk_sign_ext</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">ctx_ref</span><span class="p">(),</span> <span class="n">n</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">as_ast</span><span class="p">()),</span> <span class="n">a</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">ZeroExt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">a</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return a bit-vector expression with `n` extra zero-bits.</span>

<span class="sd">    &gt;&gt;&gt; x = BitVec(&#39;x&#39;, 16)</span>
<span class="sd">    &gt;&gt;&gt; n = ZeroExt(8, x)</span>
<span class="sd">    &gt;&gt;&gt; n.size()</span>
<span class="sd">    24</span>
<span class="sd">    &gt;&gt;&gt; n</span>
<span class="sd">    ZeroExt(8, x)</span>
<span class="sd">    &gt;&gt;&gt; n.sort()</span>
<span class="sd">    BitVec(24)</span>
<span class="sd">    &gt;&gt;&gt; v0 = BitVecVal(2, 2)</span>
<span class="sd">    &gt;&gt;&gt; v0</span>
<span class="sd">    2</span>
<span class="sd">    &gt;&gt;&gt; v0.size()</span>
<span class="sd">    2</span>
<span class="sd">    &gt;&gt;&gt; v  = simplify(ZeroExt(6, v0))</span>
<span class="sd">    &gt;&gt;&gt; v</span>
<span class="sd">    2</span>
<span class="sd">    &gt;&gt;&gt; v.size()</span>
<span class="sd">    8</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">z3_debug</span><span class="p">():</span>
        <span class="n">_z3_assert</span><span class="p">(</span><span class="n">_is_int</span><span class="p">(</span><span class="n">n</span><span class="p">),</span> <span class="s2">&quot;First argument must be an integer&quot;</span><span class="p">)</span>
        <span class="n">_z3_assert</span><span class="p">(</span><span class="n">is_bv</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="s2">&quot;Second argument must be a Z3 bit-vector expression&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">BitVecRef</span><span class="p">(</span><span class="n">Z3_mk_zero_ext</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">ctx_ref</span><span class="p">(),</span> <span class="n">n</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">as_ast</span><span class="p">()),</span> <span class="n">a</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">RepeatBitVec</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">a</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return an expression representing `n` copies of `a`.</span>

<span class="sd">    &gt;&gt;&gt; x = BitVec(&#39;x&#39;, 8)</span>
<span class="sd">    &gt;&gt;&gt; n = RepeatBitVec(4, x)</span>
<span class="sd">    &gt;&gt;&gt; n</span>
<span class="sd">    RepeatBitVec(4, x)</span>
<span class="sd">    &gt;&gt;&gt; n.size()</span>
<span class="sd">    32</span>
<span class="sd">    &gt;&gt;&gt; v0 = BitVecVal(10, 4)</span>
<span class="sd">    &gt;&gt;&gt; print(&quot;%.x&quot; % v0.as_long())</span>
<span class="sd">    a</span>
<span class="sd">    &gt;&gt;&gt; v = simplify(RepeatBitVec(4, v0))</span>
<span class="sd">    &gt;&gt;&gt; v.size()</span>
<span class="sd">    16</span>
<span class="sd">    &gt;&gt;&gt; print(&quot;%.x&quot; % v.as_long())</span>
<span class="sd">    aaaa</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">z3_debug</span><span class="p">():</span>
        <span class="n">_z3_assert</span><span class="p">(</span><span class="n">_is_int</span><span class="p">(</span><span class="n">n</span><span class="p">),</span> <span class="s2">&quot;First argument must be an integer&quot;</span><span class="p">)</span>
        <span class="n">_z3_assert</span><span class="p">(</span><span class="n">is_bv</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="s2">&quot;Second argument must be a Z3 bit-vector expression&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">BitVecRef</span><span class="p">(</span><span class="n">Z3_mk_repeat</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">ctx_ref</span><span class="p">(),</span> <span class="n">n</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">as_ast</span><span class="p">()),</span> <span class="n">a</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">BVRedAnd</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return the reduction-and expression of `a`.&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">z3_debug</span><span class="p">():</span>
        <span class="n">_z3_assert</span><span class="p">(</span><span class="n">is_bv</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="s2">&quot;First argument must be a Z3 bit-vector expression&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">BitVecRef</span><span class="p">(</span><span class="n">Z3_mk_bvredand</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">ctx_ref</span><span class="p">(),</span> <span class="n">a</span><span class="o">.</span><span class="n">as_ast</span><span class="p">()),</span> <span class="n">a</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">BVRedOr</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return the reduction-or expression of `a`.&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">z3_debug</span><span class="p">():</span>
        <span class="n">_z3_assert</span><span class="p">(</span><span class="n">is_bv</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="s2">&quot;First argument must be a Z3 bit-vector expression&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">BitVecRef</span><span class="p">(</span><span class="n">Z3_mk_bvredor</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">ctx_ref</span><span class="p">(),</span> <span class="n">a</span><span class="o">.</span><span class="n">as_ast</span><span class="p">()),</span> <span class="n">a</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">BVAddNoOverflow</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">signed</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;A predicate the determines that bit-vector addition does not overflow&quot;&quot;&quot;</span>
    <span class="n">_check_bv_args</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
    <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">_coerce_exprs</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">BoolRef</span><span class="p">(</span><span class="n">Z3_mk_bvadd_no_overflow</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">ctx_ref</span><span class="p">(),</span> <span class="n">a</span><span class="o">.</span><span class="n">as_ast</span><span class="p">(),</span> <span class="n">b</span><span class="o">.</span><span class="n">as_ast</span><span class="p">(),</span> <span class="n">signed</span><span class="p">),</span> <span class="n">a</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">BVAddNoUnderflow</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;A predicate the determines that signed bit-vector addition does not underflow&quot;&quot;&quot;</span>
    <span class="n">_check_bv_args</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
    <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">_coerce_exprs</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">BoolRef</span><span class="p">(</span><span class="n">Z3_mk_bvadd_no_underflow</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">ctx_ref</span><span class="p">(),</span> <span class="n">a</span><span class="o">.</span><span class="n">as_ast</span><span class="p">(),</span> <span class="n">b</span><span class="o">.</span><span class="n">as_ast</span><span class="p">()),</span> <span class="n">a</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">BVSubNoOverflow</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;A predicate the determines that bit-vector subtraction does not overflow&quot;&quot;&quot;</span>
    <span class="n">_check_bv_args</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
    <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">_coerce_exprs</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">BoolRef</span><span class="p">(</span><span class="n">Z3_mk_bvsub_no_overflow</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">ctx_ref</span><span class="p">(),</span> <span class="n">a</span><span class="o">.</span><span class="n">as_ast</span><span class="p">(),</span> <span class="n">b</span><span class="o">.</span><span class="n">as_ast</span><span class="p">()),</span> <span class="n">a</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">BVSubNoUnderflow</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">signed</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;A predicate the determines that bit-vector subtraction does not underflow&quot;&quot;&quot;</span>
    <span class="n">_check_bv_args</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
    <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">_coerce_exprs</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">BoolRef</span><span class="p">(</span><span class="n">Z3_mk_bvsub_no_underflow</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">ctx_ref</span><span class="p">(),</span> <span class="n">a</span><span class="o">.</span><span class="n">as_ast</span><span class="p">(),</span> <span class="n">b</span><span class="o">.</span><span class="n">as_ast</span><span class="p">(),</span> <span class="n">signed</span><span class="p">),</span> <span class="n">a</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">BVSDivNoOverflow</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;A predicate the determines that bit-vector signed division does not overflow&quot;&quot;&quot;</span>
    <span class="n">_check_bv_args</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
    <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">_coerce_exprs</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">BoolRef</span><span class="p">(</span><span class="n">Z3_mk_bvsdiv_no_overflow</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">ctx_ref</span><span class="p">(),</span> <span class="n">a</span><span class="o">.</span><span class="n">as_ast</span><span class="p">(),</span> <span class="n">b</span><span class="o">.</span><span class="n">as_ast</span><span class="p">()),</span> <span class="n">a</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">BVSNegNoOverflow</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;A predicate the determines that bit-vector unary negation does not overflow&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">z3_debug</span><span class="p">():</span>
        <span class="n">_z3_assert</span><span class="p">(</span><span class="n">is_bv</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="s2">&quot;First argument must be a Z3 bit-vector expression&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">BoolRef</span><span class="p">(</span><span class="n">Z3_mk_bvneg_no_overflow</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">ctx_ref</span><span class="p">(),</span> <span class="n">a</span><span class="o">.</span><span class="n">as_ast</span><span class="p">()),</span> <span class="n">a</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">BVMulNoOverflow</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">signed</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;A predicate the determines that bit-vector multiplication does not overflow&quot;&quot;&quot;</span>
    <span class="n">_check_bv_args</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
    <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">_coerce_exprs</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">BoolRef</span><span class="p">(</span><span class="n">Z3_mk_bvmul_no_overflow</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">ctx_ref</span><span class="p">(),</span> <span class="n">a</span><span class="o">.</span><span class="n">as_ast</span><span class="p">(),</span> <span class="n">b</span><span class="o">.</span><span class="n">as_ast</span><span class="p">(),</span> <span class="n">signed</span><span class="p">),</span> <span class="n">a</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">BVMulNoUnderflow</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;A predicate the determines that bit-vector signed multiplication does not underflow&quot;&quot;&quot;</span>
    <span class="n">_check_bv_args</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
    <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">_coerce_exprs</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">BoolRef</span><span class="p">(</span><span class="n">Z3_mk_bvmul_no_underflow</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">ctx_ref</span><span class="p">(),</span> <span class="n">a</span><span class="o">.</span><span class="n">as_ast</span><span class="p">(),</span> <span class="n">b</span><span class="o">.</span><span class="n">as_ast</span><span class="p">()),</span> <span class="n">a</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>


<span class="c1">#########################################</span>
<span class="c1">#</span>
<span class="c1"># Arrays</span>
<span class="c1">#</span>
<span class="c1">#########################################</span>

<span class="k">class</span> <span class="nc">ArraySortRef</span><span class="p">(</span><span class="n">SortRef</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Array sorts.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">domain</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the domain of the array sort `self`.</span>

<span class="sd">        &gt;&gt;&gt; A = ArraySort(IntSort(), BoolSort())</span>
<span class="sd">        &gt;&gt;&gt; A.domain()</span>
<span class="sd">        Int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_to_sort_ref</span><span class="p">(</span><span class="n">Z3_get_array_sort_domain</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx_ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">ast</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">domain_n</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the domain of the array sort `self`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_to_sort_ref</span><span class="p">(</span><span class="n">Z3_get_array_sort_domain_n</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx_ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">ast</span><span class="p">,</span> <span class="n">i</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>
    
    <span class="k">def</span> <span class="nf">range</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the range of the array sort `self`.</span>

<span class="sd">        &gt;&gt;&gt; A = ArraySort(IntSort(), BoolSort())</span>
<span class="sd">        &gt;&gt;&gt; A.range()</span>
<span class="sd">        Bool</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_to_sort_ref</span><span class="p">(</span><span class="n">Z3_get_array_sort_range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx_ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">ast</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">ArrayRef</span><span class="p">(</span><span class="n">ExprRef</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Array expressions. &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">sort</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the array sort of the array expression `self`.</span>

<span class="sd">        &gt;&gt;&gt; a = Array(&#39;a&#39;, IntSort(), BoolSort())</span>
<span class="sd">        &gt;&gt;&gt; a.sort()</span>
<span class="sd">        Array(Int, Bool)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">ArraySortRef</span><span class="p">(</span><span class="n">Z3_get_sort</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx_ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_ast</span><span class="p">()),</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">domain</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Shorthand for `self.sort().domain()`.</span>

<span class="sd">        &gt;&gt;&gt; a = Array(&#39;a&#39;, IntSort(), BoolSort())</span>
<span class="sd">        &gt;&gt;&gt; a.domain()</span>
<span class="sd">        Int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span><span class="o">.</span><span class="n">domain</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">domain_n</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Shorthand for self.sort().domain_n(i)`.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span><span class="o">.</span><span class="n">domain_n</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">range</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Shorthand for `self.sort().range()`.</span>

<span class="sd">        &gt;&gt;&gt; a = Array(&#39;a&#39;, IntSort(), BoolSort())</span>
<span class="sd">        &gt;&gt;&gt; a.range()</span>
<span class="sd">        Bool</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span><span class="o">.</span><span class="n">range</span><span class="p">()</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arg</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the Z3 expression `self[arg]`.</span>

<span class="sd">        &gt;&gt;&gt; a = Array(&#39;a&#39;, IntSort(), BoolSort())</span>
<span class="sd">        &gt;&gt;&gt; i = Int(&#39;i&#39;)</span>
<span class="sd">        &gt;&gt;&gt; a[i]</span>
<span class="sd">        a[i]</span>
<span class="sd">        &gt;&gt;&gt; a[i].sexpr()</span>
<span class="sd">        &#39;(select a i)&#39;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_array_select</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arg</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">default</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">_to_expr_ref</span><span class="p">(</span><span class="n">Z3_mk_array_default</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx_ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_ast</span><span class="p">()),</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_array_select</span><span class="p">(</span><span class="n">ar</span><span class="p">,</span> <span class="n">arg</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
        <span class="n">args</span> <span class="o">=</span> <span class="p">[</span><span class="n">ar</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span><span class="o">.</span><span class="n">domain_n</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="n">arg</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">arg</span><span class="p">))]</span>
        <span class="n">_args</span><span class="p">,</span> <span class="n">sz</span> <span class="o">=</span> <span class="n">_to_ast_array</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">_to_expr_ref</span><span class="p">(</span><span class="n">Z3_mk_select_n</span><span class="p">(</span><span class="n">ar</span><span class="o">.</span><span class="n">ctx_ref</span><span class="p">(),</span> <span class="n">ar</span><span class="o">.</span><span class="n">as_ast</span><span class="p">(),</span> <span class="n">sz</span><span class="p">,</span> <span class="n">_args</span><span class="p">),</span> <span class="n">ar</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>
    <span class="n">arg</span> <span class="o">=</span> <span class="n">ar</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span><span class="o">.</span><span class="n">domain</span><span class="p">()</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">_to_expr_ref</span><span class="p">(</span><span class="n">Z3_mk_select</span><span class="p">(</span><span class="n">ar</span><span class="o">.</span><span class="n">ctx_ref</span><span class="p">(),</span> <span class="n">ar</span><span class="o">.</span><span class="n">as_ast</span><span class="p">(),</span> <span class="n">arg</span><span class="o">.</span><span class="n">as_ast</span><span class="p">()),</span> <span class="n">ar</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>

    
<span class="k">def</span> <span class="nf">is_array_sort</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">Z3_get_sort_kind</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="n">Z3_get_sort</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="n">a</span><span class="o">.</span><span class="n">ast</span><span class="p">))</span> <span class="o">==</span> <span class="n">Z3_ARRAY_SORT</span>


<span class="k">def</span> <span class="nf">is_array</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return `True` if `a` is a Z3 array expression.</span>

<span class="sd">    &gt;&gt;&gt; a = Array(&#39;a&#39;, IntSort(), IntSort())</span>
<span class="sd">    &gt;&gt;&gt; is_array(a)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; is_array(Store(a, 0, 1))</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; is_array(a[0])</span>
<span class="sd">    False</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">ArrayRef</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">is_const_array</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return `True` if `a` is a Z3 constant array.</span>

<span class="sd">    &gt;&gt;&gt; a = K(IntSort(), 10)</span>
<span class="sd">    &gt;&gt;&gt; is_const_array(a)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; a = Array(&#39;a&#39;, IntSort(), IntSort())</span>
<span class="sd">    &gt;&gt;&gt; is_const_array(a)</span>
<span class="sd">    False</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">is_app_of</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">Z3_OP_CONST_ARRAY</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">is_K</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return `True` if `a` is a Z3 constant array.</span>

<span class="sd">    &gt;&gt;&gt; a = K(IntSort(), 10)</span>
<span class="sd">    &gt;&gt;&gt; is_K(a)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; a = Array(&#39;a&#39;, IntSort(), IntSort())</span>
<span class="sd">    &gt;&gt;&gt; is_K(a)</span>
<span class="sd">    False</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">is_app_of</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">Z3_OP_CONST_ARRAY</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">is_map</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return `True` if `a` is a Z3 map array expression.</span>

<span class="sd">    &gt;&gt;&gt; f = Function(&#39;f&#39;, IntSort(), IntSort())</span>
<span class="sd">    &gt;&gt;&gt; b = Array(&#39;b&#39;, IntSort(), IntSort())</span>
<span class="sd">    &gt;&gt;&gt; a  = Map(f, b)</span>
<span class="sd">    &gt;&gt;&gt; a</span>
<span class="sd">    Map(f, b)</span>
<span class="sd">    &gt;&gt;&gt; is_map(a)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; is_map(b)</span>
<span class="sd">    False</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">is_app_of</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">Z3_OP_ARRAY_MAP</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">is_default</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return `True` if `a` is a Z3 default array expression.</span>
<span class="sd">    &gt;&gt;&gt; d = Default(K(IntSort(), 10))</span>
<span class="sd">    &gt;&gt;&gt; is_default(d)</span>
<span class="sd">    True</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">is_app_of</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">Z3_OP_ARRAY_DEFAULT</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">get_map_func</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return the function declaration associated with a Z3 map array expression.</span>

<span class="sd">    &gt;&gt;&gt; f = Function(&#39;f&#39;, IntSort(), IntSort())</span>
<span class="sd">    &gt;&gt;&gt; b = Array(&#39;b&#39;, IntSort(), IntSort())</span>
<span class="sd">    &gt;&gt;&gt; a  = Map(f, b)</span>
<span class="sd">    &gt;&gt;&gt; eq(f, get_map_func(a))</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; get_map_func(a)</span>
<span class="sd">    f</span>
<span class="sd">    &gt;&gt;&gt; get_map_func(a)(0)</span>
<span class="sd">    f(0)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">z3_debug</span><span class="p">():</span>
        <span class="n">_z3_assert</span><span class="p">(</span><span class="n">is_map</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="s2">&quot;Z3 array map expression expected.&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">FuncDeclRef</span><span class="p">(</span>
        <span class="n">Z3_to_func_decl</span><span class="p">(</span>
            <span class="n">a</span><span class="o">.</span><span class="n">ctx_ref</span><span class="p">(),</span>
            <span class="n">Z3_get_decl_ast_parameter</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">ctx_ref</span><span class="p">(),</span> <span class="n">a</span><span class="o">.</span><span class="n">decl</span><span class="p">()</span><span class="o">.</span><span class="n">ast</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
        <span class="p">),</span>
        <span class="n">ctx</span><span class="o">=</span><span class="n">a</span><span class="o">.</span><span class="n">ctx</span><span class="p">,</span>
    <span class="p">)</span>


<span class="k">def</span> <span class="nf">ArraySort</span><span class="p">(</span><span class="o">*</span><span class="n">sig</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return the Z3 array sort with the given domain and range sorts.</span>

<span class="sd">    &gt;&gt;&gt; A = ArraySort(IntSort(), BoolSort())</span>
<span class="sd">    &gt;&gt;&gt; A</span>
<span class="sd">    Array(Int, Bool)</span>
<span class="sd">    &gt;&gt;&gt; A.domain()</span>
<span class="sd">    Int</span>
<span class="sd">    &gt;&gt;&gt; A.range()</span>
<span class="sd">    Bool</span>
<span class="sd">    &gt;&gt;&gt; AA = ArraySort(IntSort(), A)</span>
<span class="sd">    &gt;&gt;&gt; AA</span>
<span class="sd">    Array(Int, Array(Int, Bool))</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">sig</span> <span class="o">=</span> <span class="n">_get_args</span><span class="p">(</span><span class="n">sig</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">z3_debug</span><span class="p">():</span>
        <span class="n">_z3_assert</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sig</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;At least two arguments expected&quot;</span><span class="p">)</span>
    <span class="n">arity</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">sig</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">sig</span><span class="p">[</span><span class="n">arity</span><span class="p">]</span>
    <span class="n">d</span> <span class="o">=</span> <span class="n">sig</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">z3_debug</span><span class="p">():</span>
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">sig</span><span class="p">:</span>
            <span class="n">_z3_assert</span><span class="p">(</span><span class="n">is_sort</span><span class="p">(</span><span class="n">s</span><span class="p">),</span> <span class="s2">&quot;Z3 sort expected&quot;</span><span class="p">)</span>
            <span class="n">_z3_assert</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">ctx</span> <span class="o">==</span> <span class="n">r</span><span class="o">.</span><span class="n">ctx</span><span class="p">,</span> <span class="s2">&quot;Context mismatch&quot;</span><span class="p">)</span>
    <span class="n">ctx</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">ctx</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sig</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">ArraySortRef</span><span class="p">(</span><span class="n">Z3_mk_array_sort</span><span class="p">(</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="n">d</span><span class="o">.</span><span class="n">ast</span><span class="p">,</span> <span class="n">r</span><span class="o">.</span><span class="n">ast</span><span class="p">),</span> <span class="n">ctx</span><span class="p">)</span>
    <span class="n">dom</span> <span class="o">=</span> <span class="p">(</span><span class="n">Sort</span> <span class="o">*</span> <span class="n">arity</span><span class="p">)()</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">arity</span><span class="p">):</span>
        <span class="n">dom</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">sig</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">ast</span>
    <span class="k">return</span> <span class="n">ArraySortRef</span><span class="p">(</span><span class="n">Z3_mk_array_sort_n</span><span class="p">(</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="n">arity</span><span class="p">,</span> <span class="n">dom</span><span class="p">,</span> <span class="n">r</span><span class="o">.</span><span class="n">ast</span><span class="p">),</span> <span class="n">ctx</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">Array</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="o">*</span><span class="n">sorts</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return an array constant named `name` with the given domain and range sorts.</span>

<span class="sd">    &gt;&gt;&gt; a = Array(&#39;a&#39;, IntSort(), IntSort())</span>
<span class="sd">    &gt;&gt;&gt; a.sort()</span>
<span class="sd">    Array(Int, Int)</span>
<span class="sd">    &gt;&gt;&gt; a[0]</span>
<span class="sd">    a[0]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">ArraySort</span><span class="p">(</span><span class="n">sorts</span><span class="p">)</span>
    <span class="n">ctx</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">ctx</span>
    <span class="k">return</span> <span class="n">ArrayRef</span><span class="p">(</span><span class="n">Z3_mk_const</span><span class="p">(</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="n">to_symbol</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">ctx</span><span class="p">),</span> <span class="n">s</span><span class="o">.</span><span class="n">ast</span><span class="p">),</span> <span class="n">ctx</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">Update</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return a Z3 store array expression.</span>

<span class="sd">    &gt;&gt;&gt; a    = Array(&#39;a&#39;, IntSort(), IntSort())</span>
<span class="sd">    &gt;&gt;&gt; i, v = Ints(&#39;i v&#39;)</span>
<span class="sd">    &gt;&gt;&gt; s    = Update(a, i, v)</span>
<span class="sd">    &gt;&gt;&gt; s.sort()</span>
<span class="sd">    Array(Int, Int)</span>
<span class="sd">    &gt;&gt;&gt; prove(s[i] == v)</span>
<span class="sd">    proved</span>
<span class="sd">    &gt;&gt;&gt; j    = Int(&#39;j&#39;)</span>
<span class="sd">    &gt;&gt;&gt; prove(Implies(i != j, s[j] == a[j]))</span>
<span class="sd">    proved</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">z3_debug</span><span class="p">():</span>
        <span class="n">_z3_assert</span><span class="p">(</span><span class="n">is_array_sort</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="s2">&quot;First argument must be a Z3 array expression&quot;</span><span class="p">)</span>
    <span class="n">args</span> <span class="o">=</span> <span class="n">_get_args</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
    <span class="n">ctx</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">ctx</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">Z3Exception</span><span class="p">(</span><span class="s2">&quot;array update requires index and value arguments&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span><span class="o">.</span><span class="n">domain</span><span class="p">()</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span><span class="o">.</span><span class="n">range</span><span class="p">()</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">_to_expr_ref</span><span class="p">(</span><span class="n">Z3_mk_store</span><span class="p">(</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="n">a</span><span class="o">.</span><span class="n">as_ast</span><span class="p">(),</span> <span class="n">i</span><span class="o">.</span><span class="n">as_ast</span><span class="p">(),</span> <span class="n">v</span><span class="o">.</span><span class="n">as_ast</span><span class="p">()),</span> <span class="n">ctx</span><span class="p">)</span>
    <span class="n">v</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span><span class="o">.</span><span class="n">range</span><span class="p">()</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">idxs</span> <span class="o">=</span> <span class="p">[</span><span class="n">a</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span><span class="o">.</span><span class="n">domain_n</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)]</span>
    <span class="n">_args</span><span class="p">,</span> <span class="n">sz</span> <span class="o">=</span> <span class="n">_to_ast_array</span><span class="p">(</span><span class="n">idxs</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">_to_expr_ref</span><span class="p">(</span><span class="n">Z3_mk_store_n</span><span class="p">(</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="n">a</span><span class="o">.</span><span class="n">as_ast</span><span class="p">(),</span> <span class="n">sz</span><span class="p">,</span> <span class="n">_args</span><span class="p">,</span> <span class="n">v</span><span class="o">.</span><span class="n">as_ast</span><span class="p">()),</span> <span class="n">ctx</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">Default</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Return a default value for array expression.</span>
<span class="sd">    &gt;&gt;&gt; b = K(IntSort(), 1)</span>
<span class="sd">    &gt;&gt;&gt; prove(Default(b) == 1)</span>
<span class="sd">    proved</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">z3_debug</span><span class="p">():</span>
        <span class="n">_z3_assert</span><span class="p">(</span><span class="n">is_array_sort</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="s2">&quot;First argument must be a Z3 array expression&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">a</span><span class="o">.</span><span class="n">default</span><span class="p">()</span>


<span class="k">def</span> <span class="nf">Store</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return a Z3 store array expression.</span>

<span class="sd">    &gt;&gt;&gt; a    = Array(&#39;a&#39;, IntSort(), IntSort())</span>
<span class="sd">    &gt;&gt;&gt; i, v = Ints(&#39;i v&#39;)</span>
<span class="sd">    &gt;&gt;&gt; s    = Store(a, i, v)</span>
<span class="sd">    &gt;&gt;&gt; s.sort()</span>
<span class="sd">    Array(Int, Int)</span>
<span class="sd">    &gt;&gt;&gt; prove(s[i] == v)</span>
<span class="sd">    proved</span>
<span class="sd">    &gt;&gt;&gt; j    = Int(&#39;j&#39;)</span>
<span class="sd">    &gt;&gt;&gt; prove(Implies(i != j, s[j] == a[j]))</span>
<span class="sd">    proved</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">Update</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">Select</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return a Z3 select array expression.</span>

<span class="sd">    &gt;&gt;&gt; a = Array(&#39;a&#39;, IntSort(), IntSort())</span>
<span class="sd">    &gt;&gt;&gt; i = Int(&#39;i&#39;)</span>
<span class="sd">    &gt;&gt;&gt; Select(a, i)</span>
<span class="sd">    a[i]</span>
<span class="sd">    &gt;&gt;&gt; eq(Select(a, i), a[i])</span>
<span class="sd">    True</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">args</span> <span class="o">=</span> <span class="n">_get_args</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">z3_debug</span><span class="p">():</span>
        <span class="n">_z3_assert</span><span class="p">(</span><span class="n">is_array_sort</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="s2">&quot;First argument must be a Z3 array expression&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">a</span><span class="p">[</span><span class="n">args</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">Map</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return a Z3 map array expression.</span>

<span class="sd">    &gt;&gt;&gt; f = Function(&#39;f&#39;, IntSort(), IntSort(), IntSort())</span>
<span class="sd">    &gt;&gt;&gt; a1 = Array(&#39;a1&#39;, IntSort(), IntSort())</span>
<span class="sd">    &gt;&gt;&gt; a2 = Array(&#39;a2&#39;, IntSort(), IntSort())</span>
<span class="sd">    &gt;&gt;&gt; b  = Map(f, a1, a2)</span>
<span class="sd">    &gt;&gt;&gt; b</span>
<span class="sd">    Map(f, a1, a2)</span>
<span class="sd">    &gt;&gt;&gt; prove(b[0] == f(a1[0], a2[0]))</span>
<span class="sd">    proved</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">args</span> <span class="o">=</span> <span class="n">_get_args</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">z3_debug</span><span class="p">():</span>
        <span class="n">_z3_assert</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;At least one Z3 array expression expected&quot;</span><span class="p">)</span>
        <span class="n">_z3_assert</span><span class="p">(</span><span class="n">is_func_decl</span><span class="p">(</span><span class="n">f</span><span class="p">),</span> <span class="s2">&quot;First argument must be a Z3 function declaration&quot;</span><span class="p">)</span>
        <span class="n">_z3_assert</span><span class="p">(</span><span class="nb">all</span><span class="p">([</span><span class="n">is_array</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">args</span><span class="p">]),</span> <span class="s2">&quot;Z3 array expected expected&quot;</span><span class="p">)</span>
        <span class="n">_z3_assert</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="n">f</span><span class="o">.</span><span class="n">arity</span><span class="p">(),</span> <span class="s2">&quot;Number of arguments mismatch&quot;</span><span class="p">)</span>
    <span class="n">_args</span><span class="p">,</span> <span class="n">sz</span> <span class="o">=</span> <span class="n">_to_ast_array</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
    <span class="n">ctx</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">ctx</span>
    <span class="k">return</span> <span class="n">ArrayRef</span><span class="p">(</span><span class="n">Z3_mk_map</span><span class="p">(</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="n">f</span><span class="o">.</span><span class="n">ast</span><span class="p">,</span> <span class="n">sz</span><span class="p">,</span> <span class="n">_args</span><span class="p">),</span> <span class="n">ctx</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">K</span><span class="p">(</span><span class="n">dom</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return a Z3 constant array expression.</span>

<span class="sd">    &gt;&gt;&gt; a = K(IntSort(), 10)</span>
<span class="sd">    &gt;&gt;&gt; a</span>
<span class="sd">    K(Int, 10)</span>
<span class="sd">    &gt;&gt;&gt; a.sort()</span>
<span class="sd">    Array(Int, Int)</span>
<span class="sd">    &gt;&gt;&gt; i = Int(&#39;i&#39;)</span>
<span class="sd">    &gt;&gt;&gt; a[i]</span>
<span class="sd">    K(Int, 10)[i]</span>
<span class="sd">    &gt;&gt;&gt; simplify(a[i])</span>
<span class="sd">    10</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">z3_debug</span><span class="p">():</span>
        <span class="n">_z3_assert</span><span class="p">(</span><span class="n">is_sort</span><span class="p">(</span><span class="n">dom</span><span class="p">),</span> <span class="s2">&quot;Z3 sort expected&quot;</span><span class="p">)</span>
    <span class="n">ctx</span> <span class="o">=</span> <span class="n">dom</span><span class="o">.</span><span class="n">ctx</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">is_expr</span><span class="p">(</span><span class="n">v</span><span class="p">):</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">_py2expr</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">ctx</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">ArrayRef</span><span class="p">(</span><span class="n">Z3_mk_const_array</span><span class="p">(</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="n">dom</span><span class="o">.</span><span class="n">ast</span><span class="p">,</span> <span class="n">v</span><span class="o">.</span><span class="n">as_ast</span><span class="p">()),</span> <span class="n">ctx</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">Ext</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return extensionality index for one-dimensional arrays.</span>
<span class="sd">    &gt;&gt; a, b = Consts(&#39;a b&#39;, SetSort(IntSort()))</span>
<span class="sd">    &gt;&gt; Ext(a, b)</span>
<span class="sd">    Ext(a, b)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ctx</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">ctx</span>
    <span class="k">if</span> <span class="n">z3_debug</span><span class="p">():</span>
        <span class="n">_z3_assert</span><span class="p">(</span><span class="n">is_array_sort</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">is_array</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="ow">or</span> <span class="n">b</span><span class="o">.</span><span class="n">is_lambda</span><span class="p">()),</span> <span class="s2">&quot;arguments must be arrays&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">_to_expr_ref</span><span class="p">(</span><span class="n">Z3_mk_array_ext</span><span class="p">(</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="n">a</span><span class="o">.</span><span class="n">as_ast</span><span class="p">(),</span> <span class="n">b</span><span class="o">.</span><span class="n">as_ast</span><span class="p">()),</span> <span class="n">ctx</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">SetHasSize</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
    <span class="n">ctx</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">ctx</span>
    <span class="n">k</span> <span class="o">=</span> <span class="n">_py2expr</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">ctx</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">_to_expr_ref</span><span class="p">(</span><span class="n">Z3_mk_set_has_size</span><span class="p">(</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="n">a</span><span class="o">.</span><span class="n">as_ast</span><span class="p">(),</span> <span class="n">k</span><span class="o">.</span><span class="n">as_ast</span><span class="p">()),</span> <span class="n">ctx</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">is_select</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return `True` if `a` is a Z3 array select application.</span>

<span class="sd">    &gt;&gt;&gt; a = Array(&#39;a&#39;, IntSort(), IntSort())</span>
<span class="sd">    &gt;&gt;&gt; is_select(a)</span>
<span class="sd">    False</span>
<span class="sd">    &gt;&gt;&gt; i = Int(&#39;i&#39;)</span>
<span class="sd">    &gt;&gt;&gt; is_select(a[i])</span>
<span class="sd">    True</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">is_app_of</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">Z3_OP_SELECT</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">is_store</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return `True` if `a` is a Z3 array store application.</span>

<span class="sd">    &gt;&gt;&gt; a = Array(&#39;a&#39;, IntSort(), IntSort())</span>
<span class="sd">    &gt;&gt;&gt; is_store(a)</span>
<span class="sd">    False</span>
<span class="sd">    &gt;&gt;&gt; is_store(Store(a, 0, 1))</span>
<span class="sd">    True</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">is_app_of</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">Z3_OP_STORE</span><span class="p">)</span>

<span class="c1">#########################################</span>
<span class="c1">#</span>
<span class="c1"># Sets</span>
<span class="c1">#</span>
<span class="c1">#########################################</span>


<span class="k">def</span> <span class="nf">SetSort</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Create a set sort over element sort s&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ArraySort</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">BoolSort</span><span class="p">())</span>


<span class="k">def</span> <span class="nf">EmptySet</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Create the empty set</span>
<span class="sd">    &gt;&gt;&gt; EmptySet(IntSort())</span>
<span class="sd">    K(Int, False)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ctx</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">ctx</span>
    <span class="k">return</span> <span class="n">ArrayRef</span><span class="p">(</span><span class="n">Z3_mk_empty_set</span><span class="p">(</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="n">s</span><span class="o">.</span><span class="n">ast</span><span class="p">),</span> <span class="n">ctx</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">FullSet</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Create the full set</span>
<span class="sd">    &gt;&gt;&gt; FullSet(IntSort())</span>
<span class="sd">    K(Int, True)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ctx</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">ctx</span>
    <span class="k">return</span> <span class="n">ArrayRef</span><span class="p">(</span><span class="n">Z3_mk_full_set</span><span class="p">(</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="n">s</span><span class="o">.</span><span class="n">ast</span><span class="p">),</span> <span class="n">ctx</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">SetUnion</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Take the union of sets</span>
<span class="sd">    &gt;&gt;&gt; a = Const(&#39;a&#39;, SetSort(IntSort()))</span>
<span class="sd">    &gt;&gt;&gt; b = Const(&#39;b&#39;, SetSort(IntSort()))</span>
<span class="sd">    &gt;&gt;&gt; SetUnion(a, b)</span>
<span class="sd">    union(a, b)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">args</span> <span class="o">=</span> <span class="n">_get_args</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
    <span class="n">ctx</span> <span class="o">=</span> <span class="n">_ctx_from_ast_arg_list</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
    <span class="n">_args</span><span class="p">,</span> <span class="n">sz</span> <span class="o">=</span> <span class="n">_to_ast_array</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">ArrayRef</span><span class="p">(</span><span class="n">Z3_mk_set_union</span><span class="p">(</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="n">sz</span><span class="p">,</span> <span class="n">_args</span><span class="p">),</span> <span class="n">ctx</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">SetIntersect</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Take the union of sets</span>
<span class="sd">    &gt;&gt;&gt; a = Const(&#39;a&#39;, SetSort(IntSort()))</span>
<span class="sd">    &gt;&gt;&gt; b = Const(&#39;b&#39;, SetSort(IntSort()))</span>
<span class="sd">    &gt;&gt;&gt; SetIntersect(a, b)</span>
<span class="sd">    intersection(a, b)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">args</span> <span class="o">=</span> <span class="n">_get_args</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
    <span class="n">ctx</span> <span class="o">=</span> <span class="n">_ctx_from_ast_arg_list</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
    <span class="n">_args</span><span class="p">,</span> <span class="n">sz</span> <span class="o">=</span> <span class="n">_to_ast_array</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">ArrayRef</span><span class="p">(</span><span class="n">Z3_mk_set_intersect</span><span class="p">(</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="n">sz</span><span class="p">,</span> <span class="n">_args</span><span class="p">),</span> <span class="n">ctx</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">SetAdd</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">e</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Add element e to set s</span>
<span class="sd">    &gt;&gt;&gt; a = Const(&#39;a&#39;, SetSort(IntSort()))</span>
<span class="sd">    &gt;&gt;&gt; SetAdd(a, 1)</span>
<span class="sd">    Store(a, 1, True)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ctx</span> <span class="o">=</span> <span class="n">_ctx_from_ast_arg_list</span><span class="p">([</span><span class="n">s</span><span class="p">,</span> <span class="n">e</span><span class="p">])</span>
    <span class="n">e</span> <span class="o">=</span> <span class="n">_py2expr</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">ctx</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">ArrayRef</span><span class="p">(</span><span class="n">Z3_mk_set_add</span><span class="p">(</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="n">s</span><span class="o">.</span><span class="n">as_ast</span><span class="p">(),</span> <span class="n">e</span><span class="o">.</span><span class="n">as_ast</span><span class="p">()),</span> <span class="n">ctx</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">SetDel</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">e</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Remove element e to set s</span>
<span class="sd">    &gt;&gt;&gt; a = Const(&#39;a&#39;, SetSort(IntSort()))</span>
<span class="sd">    &gt;&gt;&gt; SetDel(a, 1)</span>
<span class="sd">    Store(a, 1, False)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ctx</span> <span class="o">=</span> <span class="n">_ctx_from_ast_arg_list</span><span class="p">([</span><span class="n">s</span><span class="p">,</span> <span class="n">e</span><span class="p">])</span>
    <span class="n">e</span> <span class="o">=</span> <span class="n">_py2expr</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">ctx</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">ArrayRef</span><span class="p">(</span><span class="n">Z3_mk_set_del</span><span class="p">(</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="n">s</span><span class="o">.</span><span class="n">as_ast</span><span class="p">(),</span> <span class="n">e</span><span class="o">.</span><span class="n">as_ast</span><span class="p">()),</span> <span class="n">ctx</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">SetComplement</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; The complement of set s</span>
<span class="sd">    &gt;&gt;&gt; a = Const(&#39;a&#39;, SetSort(IntSort()))</span>
<span class="sd">    &gt;&gt;&gt; SetComplement(a)</span>
<span class="sd">    complement(a)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ctx</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">ctx</span>
    <span class="k">return</span> <span class="n">ArrayRef</span><span class="p">(</span><span class="n">Z3_mk_set_complement</span><span class="p">(</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="n">s</span><span class="o">.</span><span class="n">as_ast</span><span class="p">()),</span> <span class="n">ctx</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">SetDifference</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; The set difference of a and b</span>
<span class="sd">    &gt;&gt;&gt; a = Const(&#39;a&#39;, SetSort(IntSort()))</span>
<span class="sd">    &gt;&gt;&gt; b = Const(&#39;b&#39;, SetSort(IntSort()))</span>
<span class="sd">    &gt;&gt;&gt; SetDifference(a, b)</span>
<span class="sd">    setminus(a, b)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ctx</span> <span class="o">=</span> <span class="n">_ctx_from_ast_arg_list</span><span class="p">([</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">ArrayRef</span><span class="p">(</span><span class="n">Z3_mk_set_difference</span><span class="p">(</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="n">a</span><span class="o">.</span><span class="n">as_ast</span><span class="p">(),</span> <span class="n">b</span><span class="o">.</span><span class="n">as_ast</span><span class="p">()),</span> <span class="n">ctx</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">IsMember</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">s</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Check if e is a member of set s</span>
<span class="sd">    &gt;&gt;&gt; a = Const(&#39;a&#39;, SetSort(IntSort()))</span>
<span class="sd">    &gt;&gt;&gt; IsMember(1, a)</span>
<span class="sd">    a[1]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ctx</span> <span class="o">=</span> <span class="n">_ctx_from_ast_arg_list</span><span class="p">([</span><span class="n">s</span><span class="p">,</span> <span class="n">e</span><span class="p">])</span>
    <span class="n">e</span> <span class="o">=</span> <span class="n">_py2expr</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">ctx</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">BoolRef</span><span class="p">(</span><span class="n">Z3_mk_set_member</span><span class="p">(</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="n">e</span><span class="o">.</span><span class="n">as_ast</span><span class="p">(),</span> <span class="n">s</span><span class="o">.</span><span class="n">as_ast</span><span class="p">()),</span> <span class="n">ctx</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">IsSubset</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Check if a is a subset of b</span>
<span class="sd">    &gt;&gt;&gt; a = Const(&#39;a&#39;, SetSort(IntSort()))</span>
<span class="sd">    &gt;&gt;&gt; b = Const(&#39;b&#39;, SetSort(IntSort()))</span>
<span class="sd">    &gt;&gt;&gt; IsSubset(a, b)</span>
<span class="sd">    subset(a, b)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ctx</span> <span class="o">=</span> <span class="n">_ctx_from_ast_arg_list</span><span class="p">([</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">BoolRef</span><span class="p">(</span><span class="n">Z3_mk_set_subset</span><span class="p">(</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="n">a</span><span class="o">.</span><span class="n">as_ast</span><span class="p">(),</span> <span class="n">b</span><span class="o">.</span><span class="n">as_ast</span><span class="p">()),</span> <span class="n">ctx</span><span class="p">)</span>


<span class="c1">#########################################</span>
<span class="c1">#</span>
<span class="c1"># Datatypes</span>
<span class="c1">#</span>
<span class="c1">#########################################</span>

<span class="k">def</span> <span class="nf">_valid_accessor</span><span class="p">(</span><span class="n">acc</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return `True` if acc is pair of the form (String, Datatype or Sort). &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">acc</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">False</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">acc</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">False</span>
    <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">acc</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">acc</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">Datatype</span><span class="p">)</span> <span class="ow">or</span> <span class="n">is_sort</span><span class="p">(</span><span class="n">acc</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>


<span class="k">class</span> <span class="nc">Datatype</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Helper class for declaring Z3 datatypes.</span>

<span class="sd">    &gt;&gt;&gt; List = Datatype(&#39;List&#39;)</span>
<span class="sd">    &gt;&gt;&gt; List.declare(&#39;cons&#39;, (&#39;car&#39;, IntSort()), (&#39;cdr&#39;, List))</span>
<span class="sd">    &gt;&gt;&gt; List.declare(&#39;nil&#39;)</span>
<span class="sd">    &gt;&gt;&gt; List = List.create()</span>
<span class="sd">    &gt;&gt;&gt; # List is now a Z3 declaration</span>
<span class="sd">    &gt;&gt;&gt; List.nil</span>
<span class="sd">    nil</span>
<span class="sd">    &gt;&gt;&gt; List.cons(10, List.nil)</span>
<span class="sd">    cons(10, nil)</span>
<span class="sd">    &gt;&gt;&gt; List.cons(10, List.nil).sort()</span>
<span class="sd">    List</span>
<span class="sd">    &gt;&gt;&gt; cons = List.cons</span>
<span class="sd">    &gt;&gt;&gt; nil  = List.nil</span>
<span class="sd">    &gt;&gt;&gt; car  = List.car</span>
<span class="sd">    &gt;&gt;&gt; cdr  = List.cdr</span>
<span class="sd">    &gt;&gt;&gt; n = cons(1, cons(0, nil))</span>
<span class="sd">    &gt;&gt;&gt; n</span>
<span class="sd">    cons(1, cons(0, nil))</span>
<span class="sd">    &gt;&gt;&gt; simplify(cdr(n))</span>
<span class="sd">    cons(0, nil)</span>
<span class="sd">    &gt;&gt;&gt; simplify(car(n))</span>
<span class="sd">    1</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">ctx</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span> <span class="o">=</span> <span class="n">_get_ctx</span><span class="p">(</span><span class="n">ctx</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">constructors</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">def</span> <span class="nf">__deepcopy__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">memo</span><span class="o">=</span><span class="p">{}):</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">Datatype</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>
        <span class="n">r</span><span class="o">.</span><span class="n">constructors</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">constructors</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">r</span>

    <span class="k">def</span> <span class="nf">declare_core</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">rec_name</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">z3_debug</span><span class="p">():</span>
            <span class="n">_z3_assert</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="nb">str</span><span class="p">),</span> <span class="s2">&quot;String expected&quot;</span><span class="p">)</span>
            <span class="n">_z3_assert</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">rec_name</span><span class="p">,</span> <span class="nb">str</span><span class="p">),</span> <span class="s2">&quot;String expected&quot;</span><span class="p">)</span>
            <span class="n">_z3_assert</span><span class="p">(</span>
                <span class="nb">all</span><span class="p">([</span><span class="n">_valid_accessor</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">args</span><span class="p">]),</span>
                <span class="s2">&quot;Valid list of accessors expected. An accessor is a pair of the form (String, Datatype|Sort)&quot;</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">constructors</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">name</span><span class="p">,</span> <span class="n">rec_name</span><span class="p">,</span> <span class="n">args</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">declare</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Declare constructor named `name` with the given accessors `args`.</span>
<span class="sd">        Each accessor is a pair `(name, sort)`, where `name` is a string and `sort` a Z3 sort</span>
<span class="sd">        or a reference to the datatypes being declared.</span>

<span class="sd">        In the following example `List.declare(&#39;cons&#39;, (&#39;car&#39;, IntSort()), (&#39;cdr&#39;, List))`</span>
<span class="sd">        declares the constructor named `cons` that builds a new List using an integer and a List.</span>
<span class="sd">        It also declares the accessors `car` and `cdr`. The accessor `car` extracts the integer</span>
<span class="sd">        of a `cons` cell, and `cdr` the list of a `cons` cell. After all constructors were declared,</span>
<span class="sd">        we use the method create() to create the actual datatype in Z3.</span>

<span class="sd">        &gt;&gt;&gt; List = Datatype(&#39;List&#39;)</span>
<span class="sd">        &gt;&gt;&gt; List.declare(&#39;cons&#39;, (&#39;car&#39;, IntSort()), (&#39;cdr&#39;, List))</span>
<span class="sd">        &gt;&gt;&gt; List.declare(&#39;nil&#39;)</span>
<span class="sd">        &gt;&gt;&gt; List = List.create()</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">z3_debug</span><span class="p">():</span>
            <span class="n">_z3_assert</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="nb">str</span><span class="p">),</span> <span class="s2">&quot;String expected&quot;</span><span class="p">)</span>
            <span class="n">_z3_assert</span><span class="p">(</span><span class="n">name</span> <span class="o">!=</span> <span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="s2">&quot;Constructor name cannot be empty&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">declare_core</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="s2">&quot;is-&quot;</span> <span class="o">+</span> <span class="n">name</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;Datatype(</span><span class="si">%s</span><span class="s2">, </span><span class="si">%s</span><span class="s2">)&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">constructors</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">create</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create a Z3 datatype based on the constructors declared using the method `declare()`.</span>

<span class="sd">        The function `CreateDatatypes()` must be used to define mutually recursive datatypes.</span>

<span class="sd">        &gt;&gt;&gt; List = Datatype(&#39;List&#39;)</span>
<span class="sd">        &gt;&gt;&gt; List.declare(&#39;cons&#39;, (&#39;car&#39;, IntSort()), (&#39;cdr&#39;, List))</span>
<span class="sd">        &gt;&gt;&gt; List.declare(&#39;nil&#39;)</span>
<span class="sd">        &gt;&gt;&gt; List = List.create()</span>
<span class="sd">        &gt;&gt;&gt; List.nil</span>
<span class="sd">        nil</span>
<span class="sd">        &gt;&gt;&gt; List.cons(10, List.nil)</span>
<span class="sd">        cons(10, nil)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">CreateDatatypes</span><span class="p">([</span><span class="bp">self</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>


<span class="k">class</span> <span class="nc">ScopedConstructor</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Auxiliary object used to create Z3 datatypes.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">ctx</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">c</span> <span class="o">=</span> <span class="n">c</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span> <span class="o">=</span> <span class="n">ctx</span>

    <span class="k">def</span> <span class="fm">__del__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">()</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">Z3_del_constructor</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">Z3_del_constructor</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">ScopedConstructorList</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Auxiliary object used to create Z3 datatypes.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">ctx</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">c</span> <span class="o">=</span> <span class="n">c</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span> <span class="o">=</span> <span class="n">ctx</span>

    <span class="k">def</span> <span class="fm">__del__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">()</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">Z3_del_constructor_list</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">Z3_del_constructor_list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">CreateDatatypes</span><span class="p">(</span><span class="o">*</span><span class="n">ds</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Create mutually recursive Z3 datatypes using 1 or more Datatype helper objects.</span>

<span class="sd">    In the following example we define a Tree-List using two mutually recursive datatypes.</span>

<span class="sd">    &gt;&gt;&gt; TreeList = Datatype(&#39;TreeList&#39;)</span>
<span class="sd">    &gt;&gt;&gt; Tree     = Datatype(&#39;Tree&#39;)</span>
<span class="sd">    &gt;&gt;&gt; # Tree has two constructors: leaf and node</span>
<span class="sd">    &gt;&gt;&gt; Tree.declare(&#39;leaf&#39;, (&#39;val&#39;, IntSort()))</span>
<span class="sd">    &gt;&gt;&gt; # a node contains a list of trees</span>
<span class="sd">    &gt;&gt;&gt; Tree.declare(&#39;node&#39;, (&#39;children&#39;, TreeList))</span>
<span class="sd">    &gt;&gt;&gt; TreeList.declare(&#39;nil&#39;)</span>
<span class="sd">    &gt;&gt;&gt; TreeList.declare(&#39;cons&#39;, (&#39;car&#39;, Tree), (&#39;cdr&#39;, TreeList))</span>
<span class="sd">    &gt;&gt;&gt; Tree, TreeList = CreateDatatypes(Tree, TreeList)</span>
<span class="sd">    &gt;&gt;&gt; Tree.val(Tree.leaf(10))</span>
<span class="sd">    val(leaf(10))</span>
<span class="sd">    &gt;&gt;&gt; simplify(Tree.val(Tree.leaf(10)))</span>
<span class="sd">    10</span>
<span class="sd">    &gt;&gt;&gt; n1 = Tree.node(TreeList.cons(Tree.leaf(10), TreeList.cons(Tree.leaf(20), TreeList.nil)))</span>
<span class="sd">    &gt;&gt;&gt; n1</span>
<span class="sd">    node(cons(leaf(10), cons(leaf(20), nil)))</span>
<span class="sd">    &gt;&gt;&gt; n2 = Tree.node(TreeList.cons(n1, TreeList.nil))</span>
<span class="sd">    &gt;&gt;&gt; simplify(n2 == n1)</span>
<span class="sd">    False</span>
<span class="sd">    &gt;&gt;&gt; simplify(TreeList.car(Tree.children(n2)) == n1)</span>
<span class="sd">    True</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ds</span> <span class="o">=</span> <span class="n">_get_args</span><span class="p">(</span><span class="n">ds</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">z3_debug</span><span class="p">():</span>
        <span class="n">_z3_assert</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ds</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;At least one Datatype must be specified&quot;</span><span class="p">)</span>
        <span class="n">_z3_assert</span><span class="p">(</span><span class="nb">all</span><span class="p">([</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">Datatype</span><span class="p">)</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">ds</span><span class="p">]),</span> <span class="s2">&quot;Arguments must be Datatypes&quot;</span><span class="p">)</span>
        <span class="n">_z3_assert</span><span class="p">(</span><span class="nb">all</span><span class="p">([</span><span class="n">d</span><span class="o">.</span><span class="n">ctx</span> <span class="o">==</span> <span class="n">ds</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">ctx</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">ds</span><span class="p">]),</span> <span class="s2">&quot;Context mismatch&quot;</span><span class="p">)</span>
        <span class="n">_z3_assert</span><span class="p">(</span><span class="nb">all</span><span class="p">([</span><span class="n">d</span><span class="o">.</span><span class="n">constructors</span> <span class="o">!=</span> <span class="p">[]</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">ds</span><span class="p">]),</span> <span class="s2">&quot;Non-empty Datatypes expected&quot;</span><span class="p">)</span>
    <span class="n">ctx</span> <span class="o">=</span> <span class="n">ds</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">ctx</span>
    <span class="n">num</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ds</span><span class="p">)</span>
    <span class="n">names</span> <span class="o">=</span> <span class="p">(</span><span class="n">Symbol</span> <span class="o">*</span> <span class="n">num</span><span class="p">)()</span>
    <span class="n">out</span> <span class="o">=</span> <span class="p">(</span><span class="n">Sort</span> <span class="o">*</span> <span class="n">num</span><span class="p">)()</span>
    <span class="n">clists</span> <span class="o">=</span> <span class="p">(</span><span class="n">ConstructorList</span> <span class="o">*</span> <span class="n">num</span><span class="p">)()</span>
    <span class="n">to_delete</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num</span><span class="p">):</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">ds</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">names</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">to_symbol</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">ctx</span><span class="p">)</span>
        <span class="n">num_cs</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">constructors</span><span class="p">)</span>
        <span class="n">cs</span> <span class="o">=</span> <span class="p">(</span><span class="n">Constructor</span> <span class="o">*</span> <span class="n">num_cs</span><span class="p">)()</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_cs</span><span class="p">):</span>
            <span class="n">c</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">constructors</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
            <span class="n">cname</span> <span class="o">=</span> <span class="n">to_symbol</span><span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ctx</span><span class="p">)</span>
            <span class="n">rname</span> <span class="o">=</span> <span class="n">to_symbol</span><span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">ctx</span><span class="p">)</span>
            <span class="n">fs</span> <span class="o">=</span> <span class="n">c</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
            <span class="n">num_fs</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">fs</span><span class="p">)</span>
            <span class="n">fnames</span> <span class="o">=</span> <span class="p">(</span><span class="n">Symbol</span> <span class="o">*</span> <span class="n">num_fs</span><span class="p">)()</span>
            <span class="n">sorts</span> <span class="o">=</span> <span class="p">(</span><span class="n">Sort</span> <span class="o">*</span> <span class="n">num_fs</span><span class="p">)()</span>
            <span class="n">refs</span> <span class="o">=</span> <span class="p">(</span><span class="n">ctypes</span><span class="o">.</span><span class="n">c_uint</span> <span class="o">*</span> <span class="n">num_fs</span><span class="p">)()</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_fs</span><span class="p">):</span>
                <span class="n">fname</span> <span class="o">=</span> <span class="n">fs</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">ftype</span> <span class="o">=</span> <span class="n">fs</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">fnames</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">to_symbol</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="n">ctx</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ftype</span><span class="p">,</span> <span class="n">Datatype</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">z3_debug</span><span class="p">():</span>
                        <span class="n">_z3_assert</span><span class="p">(</span>
                            <span class="n">ds</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">ftype</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span>
                            <span class="s2">&quot;One and only one occurrence of each datatype is expected&quot;</span><span class="p">,</span>
                        <span class="p">)</span>
                    <span class="n">sorts</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
                    <span class="n">refs</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">ds</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">ftype</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">z3_debug</span><span class="p">():</span>
                        <span class="n">_z3_assert</span><span class="p">(</span><span class="n">is_sort</span><span class="p">(</span><span class="n">ftype</span><span class="p">),</span> <span class="s2">&quot;Z3 sort expected&quot;</span><span class="p">)</span>
                    <span class="n">sorts</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">ftype</span><span class="o">.</span><span class="n">ast</span>
                    <span class="n">refs</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">cs</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">Z3_mk_constructor</span><span class="p">(</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="n">cname</span><span class="p">,</span> <span class="n">rname</span><span class="p">,</span> <span class="n">num_fs</span><span class="p">,</span> <span class="n">fnames</span><span class="p">,</span> <span class="n">sorts</span><span class="p">,</span> <span class="n">refs</span><span class="p">)</span>
            <span class="n">to_delete</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ScopedConstructor</span><span class="p">(</span><span class="n">cs</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">ctx</span><span class="p">))</span>
        <span class="n">clists</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">Z3_mk_constructor_list</span><span class="p">(</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="n">num_cs</span><span class="p">,</span> <span class="n">cs</span><span class="p">)</span>
        <span class="n">to_delete</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ScopedConstructorList</span><span class="p">(</span><span class="n">clists</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">ctx</span><span class="p">))</span>
    <span class="n">Z3_mk_datatypes</span><span class="p">(</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="n">num</span><span class="p">,</span> <span class="n">names</span><span class="p">,</span> <span class="n">out</span><span class="p">,</span> <span class="n">clists</span><span class="p">)</span>
    <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c1"># Create a field for every constructor, recognizer and accessor</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num</span><span class="p">):</span>
        <span class="n">dref</span> <span class="o">=</span> <span class="n">DatatypeSortRef</span><span class="p">(</span><span class="n">out</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">ctx</span><span class="p">)</span>
        <span class="n">num_cs</span> <span class="o">=</span> <span class="n">dref</span><span class="o">.</span><span class="n">num_constructors</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_cs</span><span class="p">):</span>
            <span class="n">cref</span> <span class="o">=</span> <span class="n">dref</span><span class="o">.</span><span class="n">constructor</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>
            <span class="n">cref_name</span> <span class="o">=</span> <span class="n">cref</span><span class="o">.</span><span class="n">name</span><span class="p">()</span>
            <span class="n">cref_arity</span> <span class="o">=</span> <span class="n">cref</span><span class="o">.</span><span class="n">arity</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">cref</span><span class="o">.</span><span class="n">arity</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">cref</span> <span class="o">=</span> <span class="n">cref</span><span class="p">()</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="n">dref</span><span class="p">,</span> <span class="n">cref_name</span><span class="p">,</span> <span class="n">cref</span><span class="p">)</span>
            <span class="n">rref</span> <span class="o">=</span> <span class="n">dref</span><span class="o">.</span><span class="n">recognizer</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="n">dref</span><span class="p">,</span> <span class="s2">&quot;is_&quot;</span> <span class="o">+</span> <span class="n">cref_name</span><span class="p">,</span> <span class="n">rref</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">cref_arity</span><span class="p">):</span>
                <span class="n">aref</span> <span class="o">=</span> <span class="n">dref</span><span class="o">.</span><span class="n">accessor</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="n">dref</span><span class="p">,</span> <span class="n">aref</span><span class="o">.</span><span class="n">name</span><span class="p">(),</span> <span class="n">aref</span><span class="p">)</span>
        <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dref</span><span class="p">)</span>
    <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">DatatypeSortRef</span><span class="p">(</span><span class="n">SortRef</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Datatype sorts.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">num_constructors</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the number of constructors in the given Z3 datatype.</span>

<span class="sd">        &gt;&gt;&gt; List = Datatype(&#39;List&#39;)</span>
<span class="sd">        &gt;&gt;&gt; List.declare(&#39;cons&#39;, (&#39;car&#39;, IntSort()), (&#39;cdr&#39;, List))</span>
<span class="sd">        &gt;&gt;&gt; List.declare(&#39;nil&#39;)</span>
<span class="sd">        &gt;&gt;&gt; List = List.create()</span>
<span class="sd">        &gt;&gt;&gt; # List is now a Z3 declaration</span>
<span class="sd">        &gt;&gt;&gt; List.num_constructors()</span>
<span class="sd">        2</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">Z3_get_datatype_sort_num_constructors</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx_ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">ast</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">constructor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a constructor of the datatype `self`.</span>

<span class="sd">        &gt;&gt;&gt; List = Datatype(&#39;List&#39;)</span>
<span class="sd">        &gt;&gt;&gt; List.declare(&#39;cons&#39;, (&#39;car&#39;, IntSort()), (&#39;cdr&#39;, List))</span>
<span class="sd">        &gt;&gt;&gt; List.declare(&#39;nil&#39;)</span>
<span class="sd">        &gt;&gt;&gt; List = List.create()</span>
<span class="sd">        &gt;&gt;&gt; # List is now a Z3 declaration</span>
<span class="sd">        &gt;&gt;&gt; List.num_constructors()</span>
<span class="sd">        2</span>
<span class="sd">        &gt;&gt;&gt; List.constructor(0)</span>
<span class="sd">        cons</span>
<span class="sd">        &gt;&gt;&gt; List.constructor(1)</span>
<span class="sd">        nil</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">z3_debug</span><span class="p">():</span>
            <span class="n">_z3_assert</span><span class="p">(</span><span class="n">idx</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_constructors</span><span class="p">(),</span> <span class="s2">&quot;Invalid constructor index&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">FuncDeclRef</span><span class="p">(</span><span class="n">Z3_get_datatype_sort_constructor</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx_ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">ast</span><span class="p">,</span> <span class="n">idx</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">recognizer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;In Z3, each constructor has an associated recognizer predicate.</span>

<span class="sd">        If the constructor is named `name`, then the recognizer `is_name`.</span>

<span class="sd">        &gt;&gt;&gt; List = Datatype(&#39;List&#39;)</span>
<span class="sd">        &gt;&gt;&gt; List.declare(&#39;cons&#39;, (&#39;car&#39;, IntSort()), (&#39;cdr&#39;, List))</span>
<span class="sd">        &gt;&gt;&gt; List.declare(&#39;nil&#39;)</span>
<span class="sd">        &gt;&gt;&gt; List = List.create()</span>
<span class="sd">        &gt;&gt;&gt; # List is now a Z3 declaration</span>
<span class="sd">        &gt;&gt;&gt; List.num_constructors()</span>
<span class="sd">        2</span>
<span class="sd">        &gt;&gt;&gt; List.recognizer(0)</span>
<span class="sd">        is(cons)</span>
<span class="sd">        &gt;&gt;&gt; List.recognizer(1)</span>
<span class="sd">        is(nil)</span>
<span class="sd">        &gt;&gt;&gt; simplify(List.is_nil(List.cons(10, List.nil)))</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; simplify(List.is_cons(List.cons(10, List.nil)))</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; l = Const(&#39;l&#39;, List)</span>
<span class="sd">        &gt;&gt;&gt; simplify(List.is_cons(l))</span>
<span class="sd">        is(cons, l)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">z3_debug</span><span class="p">():</span>
            <span class="n">_z3_assert</span><span class="p">(</span><span class="n">idx</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_constructors</span><span class="p">(),</span> <span class="s2">&quot;Invalid recognizer index&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">FuncDeclRef</span><span class="p">(</span><span class="n">Z3_get_datatype_sort_recognizer</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx_ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">ast</span><span class="p">,</span> <span class="n">idx</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">accessor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;In Z3, each constructor has 0 or more accessor.</span>
<span class="sd">        The number of accessors is equal to the arity of the constructor.</span>

<span class="sd">        &gt;&gt;&gt; List = Datatype(&#39;List&#39;)</span>
<span class="sd">        &gt;&gt;&gt; List.declare(&#39;cons&#39;, (&#39;car&#39;, IntSort()), (&#39;cdr&#39;, List))</span>
<span class="sd">        &gt;&gt;&gt; List.declare(&#39;nil&#39;)</span>
<span class="sd">        &gt;&gt;&gt; List = List.create()</span>
<span class="sd">        &gt;&gt;&gt; List.num_constructors()</span>
<span class="sd">        2</span>
<span class="sd">        &gt;&gt;&gt; List.constructor(0)</span>
<span class="sd">        cons</span>
<span class="sd">        &gt;&gt;&gt; num_accs = List.constructor(0).arity()</span>
<span class="sd">        &gt;&gt;&gt; num_accs</span>
<span class="sd">        2</span>
<span class="sd">        &gt;&gt;&gt; List.accessor(0, 0)</span>
<span class="sd">        car</span>
<span class="sd">        &gt;&gt;&gt; List.accessor(0, 1)</span>
<span class="sd">        cdr</span>
<span class="sd">        &gt;&gt;&gt; List.constructor(1)</span>
<span class="sd">        nil</span>
<span class="sd">        &gt;&gt;&gt; num_accs = List.constructor(1).arity()</span>
<span class="sd">        &gt;&gt;&gt; num_accs</span>
<span class="sd">        0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">z3_debug</span><span class="p">():</span>
            <span class="n">_z3_assert</span><span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_constructors</span><span class="p">(),</span> <span class="s2">&quot;Invalid constructor index&quot;</span><span class="p">)</span>
            <span class="n">_z3_assert</span><span class="p">(</span><span class="n">j</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">constructor</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">.</span><span class="n">arity</span><span class="p">(),</span> <span class="s2">&quot;Invalid accessor index&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">FuncDeclRef</span><span class="p">(</span>
            <span class="n">Z3_get_datatype_sort_constructor_accessor</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx_ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">ast</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">),</span>
            <span class="n">ctx</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">,</span>
        <span class="p">)</span>


<span class="k">class</span> <span class="nc">DatatypeRef</span><span class="p">(</span><span class="n">ExprRef</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Datatype expressions.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">sort</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the datatype sort of the datatype expression `self`.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">DatatypeSortRef</span><span class="p">(</span><span class="n">Z3_get_sort</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx_ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_ast</span><span class="p">()),</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">DatatypeSort</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">ctx</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Create a reference to a sort that was declared, or will be declared, as a recursive datatype&quot;&quot;&quot;</span>
    <span class="n">ctx</span> <span class="o">=</span> <span class="n">_get_ctx</span><span class="p">(</span><span class="n">ctx</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">DatatypeSortRef</span><span class="p">(</span><span class="n">Z3_mk_datatype_sort</span><span class="p">(</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="n">to_symbol</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">ctx</span><span class="p">)),</span> <span class="n">ctx</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">TupleSort</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">sorts</span><span class="p">,</span> <span class="n">ctx</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Create a named tuple sort base on a set of underlying sorts</span>
<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; pair, mk_pair, (first, second) = TupleSort(&quot;pair&quot;, [IntSort(), StringSort()])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="nb">tuple</span> <span class="o">=</span> <span class="n">Datatype</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">ctx</span><span class="p">)</span>
    <span class="n">projects</span> <span class="o">=</span> <span class="p">[(</span><span class="s2">&quot;project</span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">i</span><span class="p">,</span> <span class="n">sorts</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sorts</span><span class="p">))]</span>
    <span class="nb">tuple</span><span class="o">.</span><span class="n">declare</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="o">*</span><span class="n">projects</span><span class="p">)</span>
    <span class="nb">tuple</span> <span class="o">=</span> <span class="nb">tuple</span><span class="o">.</span><span class="n">create</span><span class="p">()</span>
    <span class="k">return</span> <span class="nb">tuple</span><span class="p">,</span> <span class="nb">tuple</span><span class="o">.</span><span class="n">constructor</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="p">[</span><span class="nb">tuple</span><span class="o">.</span><span class="n">accessor</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sorts</span><span class="p">))]</span>


<span class="k">def</span> <span class="nf">DisjointSum</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">sorts</span><span class="p">,</span> <span class="n">ctx</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Create a named tagged union sort base on a set of underlying sorts</span>
<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; sum, ((inject0, extract0), (inject1, extract1)) = DisjointSum(&quot;+&quot;, [IntSort(), StringSort()])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="nb">sum</span> <span class="o">=</span> <span class="n">Datatype</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">ctx</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sorts</span><span class="p">)):</span>
        <span class="nb">sum</span><span class="o">.</span><span class="n">declare</span><span class="p">(</span><span class="s2">&quot;inject</span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="s2">&quot;project</span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">i</span><span class="p">,</span> <span class="n">sorts</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
    <span class="nb">sum</span> <span class="o">=</span> <span class="nb">sum</span><span class="o">.</span><span class="n">create</span><span class="p">()</span>
    <span class="k">return</span> <span class="nb">sum</span><span class="p">,</span> <span class="p">[(</span><span class="nb">sum</span><span class="o">.</span><span class="n">constructor</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="nb">sum</span><span class="o">.</span><span class="n">accessor</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sorts</span><span class="p">))]</span>


<span class="k">def</span> <span class="nf">EnumSort</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">ctx</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return a new enumeration sort named `name` containing the given values.</span>

<span class="sd">    The result is a pair (sort, list of constants).</span>
<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; Color, (red, green, blue) = EnumSort(&#39;Color&#39;, [&#39;red&#39;, &#39;green&#39;, &#39;blue&#39;])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">z3_debug</span><span class="p">():</span>
        <span class="n">_z3_assert</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="nb">str</span><span class="p">),</span> <span class="s2">&quot;Name must be a string&quot;</span><span class="p">)</span>
        <span class="n">_z3_assert</span><span class="p">(</span><span class="nb">all</span><span class="p">([</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">values</span><span class="p">]),</span> <span class="s2">&quot;Enumeration sort values must be strings&quot;</span><span class="p">)</span>
        <span class="n">_z3_assert</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;At least one value expected&quot;</span><span class="p">)</span>
    <span class="n">ctx</span> <span class="o">=</span> <span class="n">_get_ctx</span><span class="p">(</span><span class="n">ctx</span><span class="p">)</span>
    <span class="n">num</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
    <span class="n">_val_names</span> <span class="o">=</span> <span class="p">(</span><span class="n">Symbol</span> <span class="o">*</span> <span class="n">num</span><span class="p">)()</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num</span><span class="p">):</span>
        <span class="n">_val_names</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">to_symbol</span><span class="p">(</span><span class="n">values</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
    <span class="n">_values</span> <span class="o">=</span> <span class="p">(</span><span class="n">FuncDecl</span> <span class="o">*</span> <span class="n">num</span><span class="p">)()</span>
    <span class="n">_testers</span> <span class="o">=</span> <span class="p">(</span><span class="n">FuncDecl</span> <span class="o">*</span> <span class="n">num</span><span class="p">)()</span>
    <span class="n">name</span> <span class="o">=</span> <span class="n">to_symbol</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
    <span class="n">S</span> <span class="o">=</span> <span class="n">DatatypeSortRef</span><span class="p">(</span><span class="n">Z3_mk_enumeration_sort</span><span class="p">(</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="n">name</span><span class="p">,</span> <span class="n">num</span><span class="p">,</span> <span class="n">_val_names</span><span class="p">,</span> <span class="n">_values</span><span class="p">,</span> <span class="n">_testers</span><span class="p">),</span> <span class="n">ctx</span><span class="p">)</span>
    <span class="n">V</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num</span><span class="p">):</span>
        <span class="n">V</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">FuncDeclRef</span><span class="p">(</span><span class="n">_values</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">ctx</span><span class="p">))</span>
    <span class="n">V</span> <span class="o">=</span> <span class="p">[</span><span class="n">a</span><span class="p">()</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">V</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">S</span><span class="p">,</span> <span class="n">V</span>

<span class="c1">#########################################</span>
<span class="c1">#</span>
<span class="c1"># Parameter Sets</span>
<span class="c1">#</span>
<span class="c1">#########################################</span>


<span class="k">class</span> <span class="nc">ParamsRef</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Set of parameters used to configure Solvers, Tactics and Simplifiers in Z3.</span>

<span class="sd">    Consider using the function `args2params` to create instances of this object.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ctx</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span> <span class="o">=</span> <span class="n">_get_ctx</span><span class="p">(</span><span class="n">ctx</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">params</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">params</span> <span class="o">=</span> <span class="n">Z3_mk_params</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">())</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">params</span> <span class="o">=</span> <span class="n">params</span>
        <span class="n">Z3_params_inc_ref</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__deepcopy__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">memo</span><span class="o">=</span><span class="p">{}):</span>
        <span class="k">return</span> <span class="n">ParamsRef</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__del__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">()</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">Z3_params_dec_ref</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">Z3_params_dec_ref</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">set</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Set parameter name with value val.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">z3_debug</span><span class="p">():</span>
            <span class="n">_z3_assert</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="nb">str</span><span class="p">),</span> <span class="s2">&quot;parameter name must be a string&quot;</span><span class="p">)</span>
        <span class="n">name_sym</span> <span class="o">=</span> <span class="n">to_symbol</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
            <span class="n">Z3_params_set_bool</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">,</span> <span class="n">name_sym</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">_is_int</span><span class="p">(</span><span class="n">val</span><span class="p">):</span>
            <span class="n">Z3_params_set_uint</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">,</span> <span class="n">name_sym</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="nb">float</span><span class="p">):</span>
            <span class="n">Z3_params_set_double</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">,</span> <span class="n">name_sym</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">Z3_params_set_symbol</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">,</span> <span class="n">name_sym</span><span class="p">,</span> <span class="n">to_symbol</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">z3_debug</span><span class="p">():</span>
                <span class="n">_z3_assert</span><span class="p">(</span><span class="kc">False</span><span class="p">,</span> <span class="s2">&quot;invalid parameter value&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Z3_params_to_string</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">validate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ds</span><span class="p">):</span>
        <span class="n">_z3_assert</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">ds</span><span class="p">,</span> <span class="n">ParamDescrsRef</span><span class="p">),</span> <span class="s2">&quot;parameter description set expected&quot;</span><span class="p">)</span>
        <span class="n">Z3_params_validate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">,</span> <span class="n">ds</span><span class="o">.</span><span class="n">descr</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">args2params</span><span class="p">(</span><span class="n">arguments</span><span class="p">,</span> <span class="n">keywords</span><span class="p">,</span> <span class="n">ctx</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Convert python arguments into a Z3_params object.</span>
<span class="sd">    A &#39;:&#39; is added to the keywords, and &#39;_&#39; is replaced with &#39;-&#39;</span>

<span class="sd">    &gt;&gt;&gt; args2params([&#39;model&#39;, True, &#39;relevancy&#39;, 2], {&#39;elim_and&#39; : True})</span>
<span class="sd">    (params model true relevancy 2 elim_and true)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">z3_debug</span><span class="p">():</span>
        <span class="n">_z3_assert</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">arguments</span><span class="p">)</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;Argument list must have an even number of elements.&quot;</span><span class="p">)</span>
    <span class="n">prev</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">ParamsRef</span><span class="p">(</span><span class="n">ctx</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">arguments</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">prev</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">prev</span> <span class="o">=</span> <span class="n">a</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">r</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">prev</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
            <span class="n">prev</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">keywords</span><span class="p">:</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">keywords</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
        <span class="n">r</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">r</span>


<span class="k">class</span> <span class="nc">ParamDescrsRef</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Set of parameter descriptions for Solvers, Tactics and Simplifiers in Z3.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">descr</span><span class="p">,</span> <span class="n">ctx</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">_z3_assert</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">descr</span><span class="p">,</span> <span class="n">ParamDescrs</span><span class="p">),</span> <span class="s2">&quot;parameter description object expected&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span> <span class="o">=</span> <span class="n">_get_ctx</span><span class="p">(</span><span class="n">ctx</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">descr</span> <span class="o">=</span> <span class="n">descr</span>
        <span class="n">Z3_param_descrs_inc_ref</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">descr</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__deepcopy__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">memo</span><span class="o">=</span><span class="p">{}):</span>
        <span class="k">return</span> <span class="n">ParamsDescrsRef</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">descr</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__del__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">()</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">Z3_param_descrs_dec_ref</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">Z3_param_descrs_dec_ref</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">descr</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">size</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the size of in the parameter description `self`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">Z3_param_descrs_size</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">descr</span><span class="p">))</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the size of in the parameter description `self`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">get_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the i-th parameter name in the parameter description `self`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_symbol2py</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">,</span> <span class="n">Z3_param_descrs_get_name</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">descr</span><span class="p">,</span> <span class="n">i</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">get_kind</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the kind of the parameter named `n`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Z3_param_descrs_get_kind</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">descr</span><span class="p">,</span> <span class="n">to_symbol</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">get_documentation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the documentation string of the parameter named `n`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Z3_param_descrs_get_documentation</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">descr</span><span class="p">,</span> <span class="n">to_symbol</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">))</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arg</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">_is_int</span><span class="p">(</span><span class="n">arg</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_name</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_kind</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Z3_param_descrs_to_string</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">descr</span><span class="p">)</span>

<span class="c1">#########################################</span>
<span class="c1">#</span>
<span class="c1"># Goals</span>
<span class="c1">#</span>
<span class="c1">#########################################</span>


<span class="k">class</span> <span class="nc">Goal</span><span class="p">(</span><span class="n">Z3PPObject</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Goal is a collection of constraints we want to find a solution or show to be unsatisfiable (infeasible).</span>

<span class="sd">    Goals are processed using Tactics. A Tactic transforms a goal into a set of subgoals.</span>
<span class="sd">    A goal has a solution if one of its subgoals has a solution.</span>
<span class="sd">    A goal is unsatisfiable if all subgoals are unsatisfiable.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">models</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">unsat_cores</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">proofs</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">ctx</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">goal</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">z3_debug</span><span class="p">():</span>
            <span class="n">_z3_assert</span><span class="p">(</span><span class="n">goal</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">ctx</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span>
                       <span class="s2">&quot;If goal is different from None, then ctx must be also different from None&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span> <span class="o">=</span> <span class="n">_get_ctx</span><span class="p">(</span><span class="n">ctx</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">goal</span> <span class="o">=</span> <span class="n">goal</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">goal</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">goal</span> <span class="o">=</span> <span class="n">Z3_mk_goal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="n">models</span><span class="p">,</span> <span class="n">unsat_cores</span><span class="p">,</span> <span class="n">proofs</span><span class="p">)</span>
        <span class="n">Z3_goal_inc_ref</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">goal</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__del__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">goal</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">()</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">Z3_goal_dec_ref</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">Z3_goal_dec_ref</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">goal</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">depth</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the depth of the goal `self`.</span>
<span class="sd">        The depth corresponds to the number of tactics applied to `self`.</span>

<span class="sd">        &gt;&gt;&gt; x, y = Ints(&#39;x y&#39;)</span>
<span class="sd">        &gt;&gt;&gt; g = Goal()</span>
<span class="sd">        &gt;&gt;&gt; g.add(x == 0, y &gt;= x + 1)</span>
<span class="sd">        &gt;&gt;&gt; g.depth()</span>
<span class="sd">        0</span>
<span class="sd">        &gt;&gt;&gt; r = Then(&#39;simplify&#39;, &#39;solve-eqs&#39;)(g)</span>
<span class="sd">        &gt;&gt;&gt; # r has 1 subgoal</span>
<span class="sd">        &gt;&gt;&gt; len(r)</span>
<span class="sd">        1</span>
<span class="sd">        &gt;&gt;&gt; r[0].depth()</span>
<span class="sd">        2</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">Z3_goal_depth</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">goal</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">inconsistent</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return `True` if `self` contains the `False` constraints.</span>

<span class="sd">        &gt;&gt;&gt; x, y = Ints(&#39;x y&#39;)</span>
<span class="sd">        &gt;&gt;&gt; g = Goal()</span>
<span class="sd">        &gt;&gt;&gt; g.inconsistent()</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; g.add(x == 0, x == 1)</span>
<span class="sd">        &gt;&gt;&gt; g</span>
<span class="sd">        [x == 0, x == 1]</span>
<span class="sd">        &gt;&gt;&gt; g.inconsistent()</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; g2 = Tactic(&#39;propagate-values&#39;)(g)[0]</span>
<span class="sd">        &gt;&gt;&gt; g2.inconsistent()</span>
<span class="sd">        True</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Z3_goal_inconsistent</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">goal</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">prec</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the precision (under-approximation, over-approximation, or precise) of the goal `self`.</span>

<span class="sd">        &gt;&gt;&gt; g = Goal()</span>
<span class="sd">        &gt;&gt;&gt; g.prec() == Z3_GOAL_PRECISE</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; x, y = Ints(&#39;x y&#39;)</span>
<span class="sd">        &gt;&gt;&gt; g.add(x == y + 1)</span>
<span class="sd">        &gt;&gt;&gt; g.prec() == Z3_GOAL_PRECISE</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; t  = With(Tactic(&#39;add-bounds&#39;), add_bound_lower=0, add_bound_upper=10)</span>
<span class="sd">        &gt;&gt;&gt; g2 = t(g)[0]</span>
<span class="sd">        &gt;&gt;&gt; g2</span>
<span class="sd">        [x == y + 1, x &lt;= 10, x &gt;= 0, y &lt;= 10, y &gt;= 0]</span>
<span class="sd">        &gt;&gt;&gt; g2.prec() == Z3_GOAL_PRECISE</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; g2.prec() == Z3_GOAL_UNDER</span>
<span class="sd">        True</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Z3_goal_precision</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">goal</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">precision</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Alias for `prec()`.</span>

<span class="sd">        &gt;&gt;&gt; g = Goal()</span>
<span class="sd">        &gt;&gt;&gt; g.precision() == Z3_GOAL_PRECISE</span>
<span class="sd">        True</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">prec</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">size</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the number of constraints in the goal `self`.</span>

<span class="sd">        &gt;&gt;&gt; g = Goal()</span>
<span class="sd">        &gt;&gt;&gt; g.size()</span>
<span class="sd">        0</span>
<span class="sd">        &gt;&gt;&gt; x, y = Ints(&#39;x y&#39;)</span>
<span class="sd">        &gt;&gt;&gt; g.add(x == 0, y &gt; x)</span>
<span class="sd">        &gt;&gt;&gt; g.size()</span>
<span class="sd">        2</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">Z3_goal_size</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">goal</span><span class="p">))</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the number of constraints in the goal `self`.</span>

<span class="sd">        &gt;&gt;&gt; g = Goal()</span>
<span class="sd">        &gt;&gt;&gt; len(g)</span>
<span class="sd">        0</span>
<span class="sd">        &gt;&gt;&gt; x, y = Ints(&#39;x y&#39;)</span>
<span class="sd">        &gt;&gt;&gt; g.add(x == 0, y &gt; x)</span>
<span class="sd">        &gt;&gt;&gt; len(g)</span>
<span class="sd">        2</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a constraint in the goal `self`.</span>

<span class="sd">        &gt;&gt;&gt; g = Goal()</span>
<span class="sd">        &gt;&gt;&gt; x, y = Ints(&#39;x y&#39;)</span>
<span class="sd">        &gt;&gt;&gt; g.add(x == 0, y &gt; x)</span>
<span class="sd">        &gt;&gt;&gt; g.get(0)</span>
<span class="sd">        x == 0</span>
<span class="sd">        &gt;&gt;&gt; g.get(1)</span>
<span class="sd">        y &gt; x</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_to_expr_ref</span><span class="p">(</span><span class="n">Z3_goal_formula</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">goal</span><span class="p">,</span> <span class="n">i</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arg</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a constraint in the goal `self`.</span>

<span class="sd">        &gt;&gt;&gt; g = Goal()</span>
<span class="sd">        &gt;&gt;&gt; x, y = Ints(&#39;x y&#39;)</span>
<span class="sd">        &gt;&gt;&gt; g.add(x == 0, y &gt; x)</span>
<span class="sd">        &gt;&gt;&gt; g[0]</span>
<span class="sd">        x == 0</span>
<span class="sd">        &gt;&gt;&gt; g[1]</span>
<span class="sd">        y &gt; x</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">arg</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">IndexError</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">assert_exprs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Assert constraints into the goal.</span>

<span class="sd">        &gt;&gt;&gt; x = Int(&#39;x&#39;)</span>
<span class="sd">        &gt;&gt;&gt; g = Goal()</span>
<span class="sd">        &gt;&gt;&gt; g.assert_exprs(x &gt; 0, x &lt; 2)</span>
<span class="sd">        &gt;&gt;&gt; g</span>
<span class="sd">        [x &gt; 0, x &lt; 2]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">args</span> <span class="o">=</span> <span class="n">_get_args</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">BoolSort</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">args</span><span class="p">:</span>
            <span class="n">arg</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>
            <span class="n">Z3_goal_assert</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">goal</span><span class="p">,</span> <span class="n">arg</span><span class="o">.</span><span class="n">as_ast</span><span class="p">())</span>

    <span class="k">def</span> <span class="nf">append</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Add constraints.</span>

<span class="sd">        &gt;&gt;&gt; x = Int(&#39;x&#39;)</span>
<span class="sd">        &gt;&gt;&gt; g = Goal()</span>
<span class="sd">        &gt;&gt;&gt; g.append(x &gt; 0, x &lt; 2)</span>
<span class="sd">        &gt;&gt;&gt; g</span>
<span class="sd">        [x &gt; 0, x &lt; 2]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">assert_exprs</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">insert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Add constraints.</span>

<span class="sd">        &gt;&gt;&gt; x = Int(&#39;x&#39;)</span>
<span class="sd">        &gt;&gt;&gt; g = Goal()</span>
<span class="sd">        &gt;&gt;&gt; g.insert(x &gt; 0, x &lt; 2)</span>
<span class="sd">        &gt;&gt;&gt; g</span>
<span class="sd">        [x &gt; 0, x &lt; 2]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">assert_exprs</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Add constraints.</span>

<span class="sd">        &gt;&gt;&gt; x = Int(&#39;x&#39;)</span>
<span class="sd">        &gt;&gt;&gt; g = Goal()</span>
<span class="sd">        &gt;&gt;&gt; g.add(x &gt; 0, x &lt; 2)</span>
<span class="sd">        &gt;&gt;&gt; g</span>
<span class="sd">        [x &gt; 0, x &lt; 2]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">assert_exprs</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">convert_model</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Retrieve model from a satisfiable goal</span>
<span class="sd">        &gt;&gt;&gt; a, b = Ints(&#39;a b&#39;)</span>
<span class="sd">        &gt;&gt;&gt; g = Goal()</span>
<span class="sd">        &gt;&gt;&gt; g.add(Or(a == 0, a == 1), Or(b == 0, b == 1), a &gt; b)</span>
<span class="sd">        &gt;&gt;&gt; t = Then(Tactic(&#39;split-clause&#39;), Tactic(&#39;solve-eqs&#39;))</span>
<span class="sd">        &gt;&gt;&gt; r = t(g)</span>
<span class="sd">        &gt;&gt;&gt; r[0]</span>
<span class="sd">        [Or(b == 0, b == 1), Not(0 &lt;= b)]</span>
<span class="sd">        &gt;&gt;&gt; r[1]</span>
<span class="sd">        [Or(b == 0, b == 1), Not(1 &lt;= b)]</span>
<span class="sd">        &gt;&gt;&gt; # Remark: the subgoal r[0] is unsatisfiable</span>
<span class="sd">        &gt;&gt;&gt; # Creating a solver for solving the second subgoal</span>
<span class="sd">        &gt;&gt;&gt; s = Solver()</span>
<span class="sd">        &gt;&gt;&gt; s.add(r[1])</span>
<span class="sd">        &gt;&gt;&gt; s.check()</span>
<span class="sd">        sat</span>
<span class="sd">        &gt;&gt;&gt; s.model()</span>
<span class="sd">        [b = 0]</span>
<span class="sd">        &gt;&gt;&gt; # Model s.model() does not assign a value to `a`</span>
<span class="sd">        &gt;&gt;&gt; # It is a model for subgoal `r[1]`, but not for goal `g`</span>
<span class="sd">        &gt;&gt;&gt; # The method convert_model creates a model for `g` from a model for `r[1]`.</span>
<span class="sd">        &gt;&gt;&gt; r[1].convert_model(s.model())</span>
<span class="sd">        [b = 0, a = 1]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">z3_debug</span><span class="p">():</span>
            <span class="n">_z3_assert</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">ModelRef</span><span class="p">),</span> <span class="s2">&quot;Z3 Model expected&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ModelRef</span><span class="p">(</span><span class="n">Z3_goal_convert_model</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">goal</span><span class="p">,</span> <span class="n">model</span><span class="o">.</span><span class="n">model</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">obj_to_string</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">sexpr</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a textual representation of the s-expression representing the goal.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Z3_goal_to_string</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">goal</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">dimacs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">include_names</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a textual representation of the goal in DIMACS format.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Z3_goal_to_dimacs_string</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">goal</span><span class="p">,</span> <span class="n">include_names</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">translate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Copy goal `self` to context `target`.</span>

<span class="sd">        &gt;&gt;&gt; x = Int(&#39;x&#39;)</span>
<span class="sd">        &gt;&gt;&gt; g = Goal()</span>
<span class="sd">        &gt;&gt;&gt; g.add(x &gt; 10)</span>
<span class="sd">        &gt;&gt;&gt; g</span>
<span class="sd">        [x &gt; 10]</span>
<span class="sd">        &gt;&gt;&gt; c2 = Context()</span>
<span class="sd">        &gt;&gt;&gt; g2 = g.translate(c2)</span>
<span class="sd">        &gt;&gt;&gt; g2</span>
<span class="sd">        [x &gt; 10]</span>
<span class="sd">        &gt;&gt;&gt; g.ctx == main_ctx()</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; g2.ctx == c2</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; g2.ctx == main_ctx()</span>
<span class="sd">        False</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">z3_debug</span><span class="p">():</span>
            <span class="n">_z3_assert</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">Context</span><span class="p">),</span> <span class="s2">&quot;target must be a context&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Goal</span><span class="p">(</span><span class="n">goal</span><span class="o">=</span><span class="n">Z3_goal_translate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">goal</span><span class="p">,</span> <span class="n">target</span><span class="o">.</span><span class="n">ref</span><span class="p">()),</span> <span class="n">ctx</span><span class="o">=</span><span class="n">target</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__copy__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">translate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__deepcopy__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">memo</span><span class="o">=</span><span class="p">{}):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">translate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">simplify</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">arguments</span><span class="p">,</span> <span class="o">**</span><span class="n">keywords</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a new simplified goal.</span>

<span class="sd">        This method is essentially invoking the simplify tactic.</span>

<span class="sd">        &gt;&gt;&gt; g = Goal()</span>
<span class="sd">        &gt;&gt;&gt; x = Int(&#39;x&#39;)</span>
<span class="sd">        &gt;&gt;&gt; g.add(x + 1 &gt;= 2)</span>
<span class="sd">        &gt;&gt;&gt; g</span>
<span class="sd">        [x + 1 &gt;= 2]</span>
<span class="sd">        &gt;&gt;&gt; g2 = g.simplify()</span>
<span class="sd">        &gt;&gt;&gt; g2</span>
<span class="sd">        [x &gt;= 1]</span>
<span class="sd">        &gt;&gt;&gt; # g was not modified</span>
<span class="sd">        &gt;&gt;&gt; g</span>
<span class="sd">        [x + 1 &gt;= 2]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">Tactic</span><span class="p">(</span><span class="s2">&quot;simplify&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">t</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">arguments</span><span class="p">,</span> <span class="o">**</span><span class="n">keywords</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">as_expr</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return goal `self` as a single Z3 expression.</span>

<span class="sd">        &gt;&gt;&gt; x = Int(&#39;x&#39;)</span>
<span class="sd">        &gt;&gt;&gt; g = Goal()</span>
<span class="sd">        &gt;&gt;&gt; g.as_expr()</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; g.add(x &gt; 1)</span>
<span class="sd">        &gt;&gt;&gt; g.as_expr()</span>
<span class="sd">        x &gt; 1</span>
<span class="sd">        &gt;&gt;&gt; g.add(x &lt; 10)</span>
<span class="sd">        &gt;&gt;&gt; g.as_expr()</span>
<span class="sd">        And(x &gt; 1, x &lt; 10)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">sz</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">sz</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">BoolVal</span><span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">sz</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">And</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">))],</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>

<span class="c1">#########################################</span>
<span class="c1">#</span>
<span class="c1"># AST Vector</span>
<span class="c1">#</span>
<span class="c1">#########################################</span>


<span class="k">class</span> <span class="nc">AstVector</span><span class="p">(</span><span class="n">Z3PPObject</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;A collection (vector) of ASTs.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ctx</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vector</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">v</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span> <span class="o">=</span> <span class="n">_get_ctx</span><span class="p">(</span><span class="n">ctx</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">vector</span> <span class="o">=</span> <span class="n">Z3_mk_ast_vector</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">())</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">vector</span> <span class="o">=</span> <span class="n">v</span>
            <span class="k">assert</span> <span class="n">ctx</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span> <span class="o">=</span> <span class="n">ctx</span>
        <span class="n">Z3_ast_vector_inc_ref</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">vector</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__del__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">vector</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">()</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">Z3_ast_vector_dec_ref</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">Z3_ast_vector_dec_ref</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">vector</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the size of the vector `self`.</span>

<span class="sd">        &gt;&gt;&gt; A = AstVector()</span>
<span class="sd">        &gt;&gt;&gt; len(A)</span>
<span class="sd">        0</span>
<span class="sd">        &gt;&gt;&gt; A.push(Int(&#39;x&#39;))</span>
<span class="sd">        &gt;&gt;&gt; A.push(Int(&#39;x&#39;))</span>
<span class="sd">        &gt;&gt;&gt; len(A)</span>
<span class="sd">        2</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">Z3_ast_vector_size</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">vector</span><span class="p">))</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the AST at position `i`.</span>

<span class="sd">        &gt;&gt;&gt; A = AstVector()</span>
<span class="sd">        &gt;&gt;&gt; A.push(Int(&#39;x&#39;) + 1)</span>
<span class="sd">        &gt;&gt;&gt; A.push(Int(&#39;y&#39;))</span>
<span class="sd">        &gt;&gt;&gt; A[0]</span>
<span class="sd">        x + 1</span>
<span class="sd">        &gt;&gt;&gt; A[1]</span>
<span class="sd">        y</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">i</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__len__</span><span class="p">()</span>

            <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__len__</span><span class="p">():</span>
                <span class="k">raise</span> <span class="ne">IndexError</span>
            <span class="k">return</span> <span class="n">_to_ast_ref</span><span class="p">(</span><span class="n">Z3_ast_vector_get</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">vector</span><span class="p">,</span> <span class="n">i</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="nb">slice</span><span class="p">):</span>
            <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="o">*</span><span class="n">i</span><span class="o">.</span><span class="n">indices</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="fm">__len__</span><span class="p">())):</span>
                <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">_to_ast_ref</span><span class="p">(</span>
                    <span class="n">Z3_ast_vector_get</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">vector</span><span class="p">,</span> <span class="n">ii</span><span class="p">),</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">,</span>
                <span class="p">))</span>
            <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="fm">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Update AST at position `i`.</span>

<span class="sd">        &gt;&gt;&gt; A = AstVector()</span>
<span class="sd">        &gt;&gt;&gt; A.push(Int(&#39;x&#39;) + 1)</span>
<span class="sd">        &gt;&gt;&gt; A.push(Int(&#39;y&#39;))</span>
<span class="sd">        &gt;&gt;&gt; A[0]</span>
<span class="sd">        x + 1</span>
<span class="sd">        &gt;&gt;&gt; A[0] = Int(&#39;x&#39;)</span>
<span class="sd">        &gt;&gt;&gt; A[0]</span>
<span class="sd">        x</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__len__</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">IndexError</span>
        <span class="n">Z3_ast_vector_set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">vector</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">v</span><span class="o">.</span><span class="n">as_ast</span><span class="p">())</span>

    <span class="k">def</span> <span class="nf">push</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Add `v` in the end of the vector.</span>

<span class="sd">        &gt;&gt;&gt; A = AstVector()</span>
<span class="sd">        &gt;&gt;&gt; len(A)</span>
<span class="sd">        0</span>
<span class="sd">        &gt;&gt;&gt; A.push(Int(&#39;x&#39;))</span>
<span class="sd">        &gt;&gt;&gt; len(A)</span>
<span class="sd">        1</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">Z3_ast_vector_push</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">vector</span><span class="p">,</span> <span class="n">v</span><span class="o">.</span><span class="n">as_ast</span><span class="p">())</span>

    <span class="k">def</span> <span class="nf">resize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sz</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Resize the vector to `sz` elements.</span>

<span class="sd">        &gt;&gt;&gt; A = AstVector()</span>
<span class="sd">        &gt;&gt;&gt; A.resize(10)</span>
<span class="sd">        &gt;&gt;&gt; len(A)</span>
<span class="sd">        10</span>
<span class="sd">        &gt;&gt;&gt; for i in range(10): A[i] = Int(&#39;x&#39;)</span>
<span class="sd">        &gt;&gt;&gt; A[5]</span>
<span class="sd">        x</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">Z3_ast_vector_resize</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">vector</span><span class="p">,</span> <span class="n">sz</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__contains__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return `True` if the vector contains `item`.</span>

<span class="sd">        &gt;&gt;&gt; x = Int(&#39;x&#39;)</span>
<span class="sd">        &gt;&gt;&gt; A = AstVector()</span>
<span class="sd">        &gt;&gt;&gt; x in A</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; A.push(x)</span>
<span class="sd">        &gt;&gt;&gt; x in A</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; (x+1) in A</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; A.push(x+1)</span>
<span class="sd">        &gt;&gt;&gt; (x+1) in A</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; A</span>
<span class="sd">        [x, x + 1]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">elem</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">elem</span><span class="o">.</span><span class="n">eq</span><span class="p">(</span><span class="n">item</span><span class="p">):</span>
                <span class="k">return</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">translate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other_ctx</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Copy vector `self` to context `other_ctx`.</span>

<span class="sd">        &gt;&gt;&gt; x = Int(&#39;x&#39;)</span>
<span class="sd">        &gt;&gt;&gt; A = AstVector()</span>
<span class="sd">        &gt;&gt;&gt; A.push(x)</span>
<span class="sd">        &gt;&gt;&gt; c2 = Context()</span>
<span class="sd">        &gt;&gt;&gt; B = A.translate(c2)</span>
<span class="sd">        &gt;&gt;&gt; B</span>
<span class="sd">        [x]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">AstVector</span><span class="p">(</span>
            <span class="n">Z3_ast_vector_translate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">vector</span><span class="p">,</span> <span class="n">other_ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">()),</span>
            <span class="n">ctx</span><span class="o">=</span><span class="n">other_ctx</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">__copy__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">translate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__deepcopy__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">memo</span><span class="o">=</span><span class="p">{}):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">translate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">obj_to_string</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">sexpr</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a textual representation of the s-expression representing the vector.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Z3_ast_vector_to_string</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">vector</span><span class="p">)</span>

<span class="c1">#########################################</span>
<span class="c1">#</span>
<span class="c1"># AST Map</span>
<span class="c1">#</span>
<span class="c1">#########################################</span>


<span class="k">class</span> <span class="nc">AstMap</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;A mapping from ASTs to ASTs.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">m</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ctx</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">map</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">m</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span> <span class="o">=</span> <span class="n">_get_ctx</span><span class="p">(</span><span class="n">ctx</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">map</span> <span class="o">=</span> <span class="n">Z3_mk_ast_map</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">())</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">map</span> <span class="o">=</span> <span class="n">m</span>
            <span class="k">assert</span> <span class="n">ctx</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span> <span class="o">=</span> <span class="n">ctx</span>
        <span class="n">Z3_ast_map_inc_ref</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">map</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__deepcopy__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">memo</span><span class="o">=</span><span class="p">{}):</span>
        <span class="k">return</span> <span class="n">AstMap</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">map</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__del__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">map</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">()</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">Z3_ast_map_dec_ref</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">Z3_ast_map_dec_ref</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">map</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the size of the map.</span>

<span class="sd">        &gt;&gt;&gt; M = AstMap()</span>
<span class="sd">        &gt;&gt;&gt; len(M)</span>
<span class="sd">        0</span>
<span class="sd">        &gt;&gt;&gt; x = Int(&#39;x&#39;)</span>
<span class="sd">        &gt;&gt;&gt; M[x] = IntVal(1)</span>
<span class="sd">        &gt;&gt;&gt; len(M)</span>
<span class="sd">        1</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">Z3_ast_map_size</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">map</span><span class="p">))</span>

    <span class="k">def</span> <span class="fm">__contains__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return `True` if the map contains key `key`.</span>

<span class="sd">        &gt;&gt;&gt; M = AstMap()</span>
<span class="sd">        &gt;&gt;&gt; x = Int(&#39;x&#39;)</span>
<span class="sd">        &gt;&gt;&gt; M[x] = x + 1</span>
<span class="sd">        &gt;&gt;&gt; x in M</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; x+1 in M</span>
<span class="sd">        False</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Z3_ast_map_contains</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">map</span><span class="p">,</span> <span class="n">key</span><span class="o">.</span><span class="n">as_ast</span><span class="p">())</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Retrieve the value associated with key `key`.</span>

<span class="sd">        &gt;&gt;&gt; M = AstMap()</span>
<span class="sd">        &gt;&gt;&gt; x = Int(&#39;x&#39;)</span>
<span class="sd">        &gt;&gt;&gt; M[x] = x + 1</span>
<span class="sd">        &gt;&gt;&gt; M[x]</span>
<span class="sd">        x + 1</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_to_ast_ref</span><span class="p">(</span><span class="n">Z3_ast_map_find</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">map</span><span class="p">,</span> <span class="n">key</span><span class="o">.</span><span class="n">as_ast</span><span class="p">()),</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Add/Update key `k` with value `v`.</span>

<span class="sd">        &gt;&gt;&gt; M = AstMap()</span>
<span class="sd">        &gt;&gt;&gt; x = Int(&#39;x&#39;)</span>
<span class="sd">        &gt;&gt;&gt; M[x] = x + 1</span>
<span class="sd">        &gt;&gt;&gt; len(M)</span>
<span class="sd">        1</span>
<span class="sd">        &gt;&gt;&gt; M[x]</span>
<span class="sd">        x + 1</span>
<span class="sd">        &gt;&gt;&gt; M[x] = IntVal(1)</span>
<span class="sd">        &gt;&gt;&gt; M[x]</span>
<span class="sd">        1</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">Z3_ast_map_insert</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">map</span><span class="p">,</span> <span class="n">k</span><span class="o">.</span><span class="n">as_ast</span><span class="p">(),</span> <span class="n">v</span><span class="o">.</span><span class="n">as_ast</span><span class="p">())</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Z3_ast_map_to_string</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">map</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">erase</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Remove the entry associated with key `k`.</span>

<span class="sd">        &gt;&gt;&gt; M = AstMap()</span>
<span class="sd">        &gt;&gt;&gt; x = Int(&#39;x&#39;)</span>
<span class="sd">        &gt;&gt;&gt; M[x] = x + 1</span>
<span class="sd">        &gt;&gt;&gt; len(M)</span>
<span class="sd">        1</span>
<span class="sd">        &gt;&gt;&gt; M.erase(x)</span>
<span class="sd">        &gt;&gt;&gt; len(M)</span>
<span class="sd">        0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">Z3_ast_map_erase</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">map</span><span class="p">,</span> <span class="n">k</span><span class="o">.</span><span class="n">as_ast</span><span class="p">())</span>

    <span class="k">def</span> <span class="nf">reset</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Remove all entries from the map.</span>

<span class="sd">        &gt;&gt;&gt; M = AstMap()</span>
<span class="sd">        &gt;&gt;&gt; x = Int(&#39;x&#39;)</span>
<span class="sd">        &gt;&gt;&gt; M[x]   = x + 1</span>
<span class="sd">        &gt;&gt;&gt; M[x+x] = IntVal(1)</span>
<span class="sd">        &gt;&gt;&gt; len(M)</span>
<span class="sd">        2</span>
<span class="sd">        &gt;&gt;&gt; M.reset()</span>
<span class="sd">        &gt;&gt;&gt; len(M)</span>
<span class="sd">        0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">Z3_ast_map_reset</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">map</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">keys</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return an AstVector containing all keys in the map.</span>

<span class="sd">        &gt;&gt;&gt; M = AstMap()</span>
<span class="sd">        &gt;&gt;&gt; x = Int(&#39;x&#39;)</span>
<span class="sd">        &gt;&gt;&gt; M[x]   = x + 1</span>
<span class="sd">        &gt;&gt;&gt; M[x+x] = IntVal(1)</span>
<span class="sd">        &gt;&gt;&gt; M.keys()</span>
<span class="sd">        [x, x + x]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">AstVector</span><span class="p">(</span><span class="n">Z3_ast_map_keys</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">map</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>

<span class="c1">#########################################</span>
<span class="c1">#</span>
<span class="c1"># Model</span>
<span class="c1">#</span>
<span class="c1">#########################################</span>


<span class="k">class</span> <span class="nc">FuncEntry</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Store the value of the interpretation of a function in a particular point.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">entry</span><span class="p">,</span> <span class="n">ctx</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">entry</span> <span class="o">=</span> <span class="n">entry</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span> <span class="o">=</span> <span class="n">ctx</span>
        <span class="n">Z3_func_entry_inc_ref</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">entry</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__deepcopy__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">memo</span><span class="o">=</span><span class="p">{}):</span>
        <span class="k">return</span> <span class="n">FuncEntry</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">entry</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__del__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">()</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">Z3_func_entry_dec_ref</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">Z3_func_entry_dec_ref</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">entry</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">num_args</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the number of arguments in the given entry.</span>

<span class="sd">        &gt;&gt;&gt; f = Function(&#39;f&#39;, IntSort(), IntSort(), IntSort())</span>
<span class="sd">        &gt;&gt;&gt; s = Solver()</span>
<span class="sd">        &gt;&gt;&gt; s.add(f(0, 1) == 10, f(1, 2) == 20, f(1, 0) == 10)</span>
<span class="sd">        &gt;&gt;&gt; s.check()</span>
<span class="sd">        sat</span>
<span class="sd">        &gt;&gt;&gt; m = s.model()</span>
<span class="sd">        &gt;&gt;&gt; f_i = m[f]</span>
<span class="sd">        &gt;&gt;&gt; f_i.num_entries()</span>
<span class="sd">        1</span>
<span class="sd">        &gt;&gt;&gt; e = f_i.entry(0)</span>
<span class="sd">        &gt;&gt;&gt; e.num_args()</span>
<span class="sd">        2</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">Z3_func_entry_get_num_args</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">entry</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">arg_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the value of argument `idx`.</span>

<span class="sd">        &gt;&gt;&gt; f = Function(&#39;f&#39;, IntSort(), IntSort(), IntSort())</span>
<span class="sd">        &gt;&gt;&gt; s = Solver()</span>
<span class="sd">        &gt;&gt;&gt; s.add(f(0, 1) == 10, f(1, 2) == 20, f(1, 0) == 10)</span>
<span class="sd">        &gt;&gt;&gt; s.check()</span>
<span class="sd">        sat</span>
<span class="sd">        &gt;&gt;&gt; m = s.model()</span>
<span class="sd">        &gt;&gt;&gt; f_i = m[f]</span>
<span class="sd">        &gt;&gt;&gt; f_i.num_entries()</span>
<span class="sd">        1</span>
<span class="sd">        &gt;&gt;&gt; e = f_i.entry(0)</span>
<span class="sd">        &gt;&gt;&gt; e</span>
<span class="sd">        [1, 2, 20]</span>
<span class="sd">        &gt;&gt;&gt; e.num_args()</span>
<span class="sd">        2</span>
<span class="sd">        &gt;&gt;&gt; e.arg_value(0)</span>
<span class="sd">        1</span>
<span class="sd">        &gt;&gt;&gt; e.arg_value(1)</span>
<span class="sd">        2</span>
<span class="sd">        &gt;&gt;&gt; try:</span>
<span class="sd">        ...   e.arg_value(2)</span>
<span class="sd">        ... except IndexError:</span>
<span class="sd">        ...   print(&quot;index error&quot;)</span>
<span class="sd">        index error</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">idx</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_args</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">IndexError</span>
        <span class="k">return</span> <span class="n">_to_expr_ref</span><span class="p">(</span><span class="n">Z3_func_entry_get_arg</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">entry</span><span class="p">,</span> <span class="n">idx</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">value</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the value of the function at point `self`.</span>

<span class="sd">        &gt;&gt;&gt; f = Function(&#39;f&#39;, IntSort(), IntSort(), IntSort())</span>
<span class="sd">        &gt;&gt;&gt; s = Solver()</span>
<span class="sd">        &gt;&gt;&gt; s.add(f(0, 1) == 10, f(1, 2) == 20, f(1, 0) == 10)</span>
<span class="sd">        &gt;&gt;&gt; s.check()</span>
<span class="sd">        sat</span>
<span class="sd">        &gt;&gt;&gt; m = s.model()</span>
<span class="sd">        &gt;&gt;&gt; f_i = m[f]</span>
<span class="sd">        &gt;&gt;&gt; f_i.num_entries()</span>
<span class="sd">        1</span>
<span class="sd">        &gt;&gt;&gt; e = f_i.entry(0)</span>
<span class="sd">        &gt;&gt;&gt; e</span>
<span class="sd">        [1, 2, 20]</span>
<span class="sd">        &gt;&gt;&gt; e.num_args()</span>
<span class="sd">        2</span>
<span class="sd">        &gt;&gt;&gt; e.value()</span>
<span class="sd">        20</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_to_expr_ref</span><span class="p">(</span><span class="n">Z3_func_entry_get_value</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">entry</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">as_list</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return entry `self` as a Python list.</span>
<span class="sd">        &gt;&gt;&gt; f = Function(&#39;f&#39;, IntSort(), IntSort(), IntSort())</span>
<span class="sd">        &gt;&gt;&gt; s = Solver()</span>
<span class="sd">        &gt;&gt;&gt; s.add(f(0, 1) == 10, f(1, 2) == 20, f(1, 0) == 10)</span>
<span class="sd">        &gt;&gt;&gt; s.check()</span>
<span class="sd">        sat</span>
<span class="sd">        &gt;&gt;&gt; m = s.model()</span>
<span class="sd">        &gt;&gt;&gt; f_i = m[f]</span>
<span class="sd">        &gt;&gt;&gt; f_i.num_entries()</span>
<span class="sd">        1</span>
<span class="sd">        &gt;&gt;&gt; e = f_i.entry(0)</span>
<span class="sd">        &gt;&gt;&gt; e.as_list()</span>
<span class="sd">        [1, 2, 20]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">args</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">arg_value</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_args</span><span class="p">())]</span>
        <span class="n">args</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">())</span>
        <span class="k">return</span> <span class="n">args</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">as_list</span><span class="p">())</span>


<span class="k">class</span> <span class="nc">FuncInterp</span><span class="p">(</span><span class="n">Z3PPObject</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Stores the interpretation of a function in a Z3 model.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">ctx</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">f</span> <span class="o">=</span> <span class="n">f</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span> <span class="o">=</span> <span class="n">ctx</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">f</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">Z3_func_interp_inc_ref</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__del__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">f</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">()</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">Z3_func_interp_dec_ref</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">Z3_func_interp_dec_ref</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">else_value</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the `else` value for a function interpretation.</span>
<span class="sd">        Return None if Z3 did not specify the `else` value for</span>
<span class="sd">        this object.</span>

<span class="sd">        &gt;&gt;&gt; f = Function(&#39;f&#39;, IntSort(), IntSort())</span>
<span class="sd">        &gt;&gt;&gt; s = Solver()</span>
<span class="sd">        &gt;&gt;&gt; s.add(f(0) == 1, f(1) == 1, f(2) == 0)</span>
<span class="sd">        &gt;&gt;&gt; s.check()</span>
<span class="sd">        sat</span>
<span class="sd">        &gt;&gt;&gt; m = s.model()</span>
<span class="sd">        &gt;&gt;&gt; m[f]</span>
<span class="sd">        [2 -&gt; 0, else -&gt; 1]</span>
<span class="sd">        &gt;&gt;&gt; m[f].else_value()</span>
<span class="sd">        1</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">Z3_func_interp_get_else</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">r</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">_to_expr_ref</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">num_entries</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the number of entries/points in the function interpretation `self`.</span>

<span class="sd">        &gt;&gt;&gt; f = Function(&#39;f&#39;, IntSort(), IntSort())</span>
<span class="sd">        &gt;&gt;&gt; s = Solver()</span>
<span class="sd">        &gt;&gt;&gt; s.add(f(0) == 1, f(1) == 1, f(2) == 0)</span>
<span class="sd">        &gt;&gt;&gt; s.check()</span>
<span class="sd">        sat</span>
<span class="sd">        &gt;&gt;&gt; m = s.model()</span>
<span class="sd">        &gt;&gt;&gt; m[f]</span>
<span class="sd">        [2 -&gt; 0, else -&gt; 1]</span>
<span class="sd">        &gt;&gt;&gt; m[f].num_entries()</span>
<span class="sd">        1</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">Z3_func_interp_get_num_entries</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">arity</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the number of arguments for each entry in the function interpretation `self`.</span>

<span class="sd">        &gt;&gt;&gt; f = Function(&#39;f&#39;, IntSort(), IntSort())</span>
<span class="sd">        &gt;&gt;&gt; s = Solver()</span>
<span class="sd">        &gt;&gt;&gt; s.add(f(0) == 1, f(1) == 1, f(2) == 0)</span>
<span class="sd">        &gt;&gt;&gt; s.check()</span>
<span class="sd">        sat</span>
<span class="sd">        &gt;&gt;&gt; m = s.model()</span>
<span class="sd">        &gt;&gt;&gt; m[f].arity()</span>
<span class="sd">        1</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">Z3_func_interp_get_arity</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">entry</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return an entry at position `idx &lt; self.num_entries()` in the function interpretation `self`.</span>

<span class="sd">        &gt;&gt;&gt; f = Function(&#39;f&#39;, IntSort(), IntSort())</span>
<span class="sd">        &gt;&gt;&gt; s = Solver()</span>
<span class="sd">        &gt;&gt;&gt; s.add(f(0) == 1, f(1) == 1, f(2) == 0)</span>
<span class="sd">        &gt;&gt;&gt; s.check()</span>
<span class="sd">        sat</span>
<span class="sd">        &gt;&gt;&gt; m = s.model()</span>
<span class="sd">        &gt;&gt;&gt; m[f]</span>
<span class="sd">        [2 -&gt; 0, else -&gt; 1]</span>
<span class="sd">        &gt;&gt;&gt; m[f].num_entries()</span>
<span class="sd">        1</span>
<span class="sd">        &gt;&gt;&gt; m[f].entry(0)</span>
<span class="sd">        [2, 0]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">idx</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_entries</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">IndexError</span>
        <span class="k">return</span> <span class="n">FuncEntry</span><span class="p">(</span><span class="n">Z3_func_interp_get_entry</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="p">,</span> <span class="n">idx</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">translate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other_ctx</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Copy model &#39;self&#39; to context &#39;other_ctx&#39;.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">ModelRef</span><span class="p">(</span><span class="n">Z3_model_translate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">,</span> <span class="n">other_ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">()),</span> <span class="n">other_ctx</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__copy__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">translate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__deepcopy__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">memo</span><span class="o">=</span><span class="p">{}):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">translate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">as_list</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the function interpretation as a Python list.</span>
<span class="sd">        &gt;&gt;&gt; f = Function(&#39;f&#39;, IntSort(), IntSort())</span>
<span class="sd">        &gt;&gt;&gt; s = Solver()</span>
<span class="sd">        &gt;&gt;&gt; s.add(f(0) == 1, f(1) == 1, f(2) == 0)</span>
<span class="sd">        &gt;&gt;&gt; s.check()</span>
<span class="sd">        sat</span>
<span class="sd">        &gt;&gt;&gt; m = s.model()</span>
<span class="sd">        &gt;&gt;&gt; m[f]</span>
<span class="sd">        [2 -&gt; 0, else -&gt; 1]</span>
<span class="sd">        &gt;&gt;&gt; m[f].as_list()</span>
<span class="sd">        [[2, 0], 1]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">r</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">entry</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">.</span><span class="n">as_list</span><span class="p">()</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_entries</span><span class="p">())]</span>
        <span class="n">r</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">else_value</span><span class="p">())</span>
        <span class="k">return</span> <span class="n">r</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">obj_to_string</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">ModelRef</span><span class="p">(</span><span class="n">Z3PPObject</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Model/Solution of a satisfiability problem (aka system of constraints).&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">ctx</span><span class="p">):</span>
        <span class="k">assert</span> <span class="n">ctx</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">model</span> <span class="o">=</span> <span class="n">m</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span> <span class="o">=</span> <span class="n">ctx</span>
        <span class="n">Z3_model_inc_ref</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__del__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">()</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">Z3_model_dec_ref</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">Z3_model_dec_ref</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">obj_to_string</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">sexpr</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a textual representation of the s-expression representing the model.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Z3_model_to_string</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">eval</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">model_completion</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Evaluate the expression `t` in the model `self`.</span>
<span class="sd">        If `model_completion` is enabled, then a default interpretation is automatically added</span>
<span class="sd">        for symbols that do not have an interpretation in the model `self`.</span>

<span class="sd">        &gt;&gt;&gt; x = Int(&#39;x&#39;)</span>
<span class="sd">        &gt;&gt;&gt; s = Solver()</span>
<span class="sd">        &gt;&gt;&gt; s.add(x &gt; 0, x &lt; 2)</span>
<span class="sd">        &gt;&gt;&gt; s.check()</span>
<span class="sd">        sat</span>
<span class="sd">        &gt;&gt;&gt; m = s.model()</span>
<span class="sd">        &gt;&gt;&gt; m.eval(x + 1)</span>
<span class="sd">        2</span>
<span class="sd">        &gt;&gt;&gt; m.eval(x == 1)</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; y = Int(&#39;y&#39;)</span>
<span class="sd">        &gt;&gt;&gt; m.eval(y + x)</span>
<span class="sd">        1 + y</span>
<span class="sd">        &gt;&gt;&gt; m.eval(y)</span>
<span class="sd">        y</span>
<span class="sd">        &gt;&gt;&gt; m.eval(y, model_completion=True)</span>
<span class="sd">        0</span>
<span class="sd">        &gt;&gt;&gt; # Now, m contains an interpretation for y</span>
<span class="sd">        &gt;&gt;&gt; m.eval(y + x)</span>
<span class="sd">        1</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">r</span> <span class="o">=</span> <span class="p">(</span><span class="n">Ast</span> <span class="o">*</span> <span class="mi">1</span><span class="p">)()</span>
        <span class="k">if</span> <span class="n">Z3_model_eval</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">,</span> <span class="n">t</span><span class="o">.</span><span class="n">as_ast</span><span class="p">(),</span> <span class="n">model_completion</span><span class="p">,</span> <span class="n">r</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">_to_expr_ref</span><span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>
        <span class="k">raise</span> <span class="n">Z3Exception</span><span class="p">(</span><span class="s2">&quot;failed to evaluate expression in the model&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">evaluate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">model_completion</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Alias for `eval`.</span>

<span class="sd">        &gt;&gt;&gt; x = Int(&#39;x&#39;)</span>
<span class="sd">        &gt;&gt;&gt; s = Solver()</span>
<span class="sd">        &gt;&gt;&gt; s.add(x &gt; 0, x &lt; 2)</span>
<span class="sd">        &gt;&gt;&gt; s.check()</span>
<span class="sd">        sat</span>
<span class="sd">        &gt;&gt;&gt; m = s.model()</span>
<span class="sd">        &gt;&gt;&gt; m.evaluate(x + 1)</span>
<span class="sd">        2</span>
<span class="sd">        &gt;&gt;&gt; m.evaluate(x == 1)</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; y = Int(&#39;y&#39;)</span>
<span class="sd">        &gt;&gt;&gt; m.evaluate(y + x)</span>
<span class="sd">        1 + y</span>
<span class="sd">        &gt;&gt;&gt; m.evaluate(y)</span>
<span class="sd">        y</span>
<span class="sd">        &gt;&gt;&gt; m.evaluate(y, model_completion=True)</span>
<span class="sd">        0</span>
<span class="sd">        &gt;&gt;&gt; # Now, m contains an interpretation for y</span>
<span class="sd">        &gt;&gt;&gt; m.evaluate(y + x)</span>
<span class="sd">        1</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">eval</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">model_completion</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the number of constant and function declarations in the model `self`.</span>

<span class="sd">        &gt;&gt;&gt; f = Function(&#39;f&#39;, IntSort(), IntSort())</span>
<span class="sd">        &gt;&gt;&gt; x = Int(&#39;x&#39;)</span>
<span class="sd">        &gt;&gt;&gt; s = Solver()</span>
<span class="sd">        &gt;&gt;&gt; s.add(x &gt; 0, f(x) != x)</span>
<span class="sd">        &gt;&gt;&gt; s.check()</span>
<span class="sd">        sat</span>
<span class="sd">        &gt;&gt;&gt; m = s.model()</span>
<span class="sd">        &gt;&gt;&gt; len(m)</span>
<span class="sd">        2</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">num_consts</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">Z3_model_get_num_consts</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">))</span>
        <span class="n">num_funcs</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">Z3_model_get_num_funcs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">num_consts</span> <span class="o">+</span> <span class="n">num_funcs</span>

    <span class="k">def</span> <span class="nf">get_interp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">decl</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the interpretation for a given declaration or constant.</span>

<span class="sd">        &gt;&gt;&gt; f = Function(&#39;f&#39;, IntSort(), IntSort())</span>
<span class="sd">        &gt;&gt;&gt; x = Int(&#39;x&#39;)</span>
<span class="sd">        &gt;&gt;&gt; s = Solver()</span>
<span class="sd">        &gt;&gt;&gt; s.add(x &gt; 0, x &lt; 2, f(x) == 0)</span>
<span class="sd">        &gt;&gt;&gt; s.check()</span>
<span class="sd">        sat</span>
<span class="sd">        &gt;&gt;&gt; m = s.model()</span>
<span class="sd">        &gt;&gt;&gt; m[x]</span>
<span class="sd">        1</span>
<span class="sd">        &gt;&gt;&gt; m[f]</span>
<span class="sd">        [else -&gt; 0]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">z3_debug</span><span class="p">():</span>
            <span class="n">_z3_assert</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">decl</span><span class="p">,</span> <span class="n">FuncDeclRef</span><span class="p">)</span> <span class="ow">or</span> <span class="n">is_const</span><span class="p">(</span><span class="n">decl</span><span class="p">),</span> <span class="s2">&quot;Z3 declaration expected&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">is_const</span><span class="p">(</span><span class="n">decl</span><span class="p">):</span>
            <span class="n">decl</span> <span class="o">=</span> <span class="n">decl</span><span class="o">.</span><span class="n">decl</span><span class="p">()</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">decl</span><span class="o">.</span><span class="n">arity</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">_r</span> <span class="o">=</span> <span class="n">Z3_model_get_const_interp</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">,</span> <span class="n">decl</span><span class="o">.</span><span class="n">ast</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">_r</span><span class="o">.</span><span class="n">value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">None</span>
                <span class="n">r</span> <span class="o">=</span> <span class="n">_to_expr_ref</span><span class="p">(</span><span class="n">_r</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">is_as_array</span><span class="p">(</span><span class="n">r</span><span class="p">):</span>
                    <span class="n">fi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_interp</span><span class="p">(</span><span class="n">get_as_array_func</span><span class="p">(</span><span class="n">r</span><span class="p">))</span>
                    <span class="k">if</span> <span class="n">fi</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="k">return</span> <span class="n">fi</span>                    
                    <span class="n">e</span> <span class="o">=</span> <span class="n">fi</span><span class="o">.</span><span class="n">else_value</span><span class="p">()</span>
                    <span class="k">if</span> <span class="n">e</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="k">return</span> <span class="n">fi</span>
                    <span class="k">if</span> <span class="n">fi</span><span class="o">.</span><span class="n">arity</span><span class="p">()</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="k">return</span> <span class="n">fi</span>
                    <span class="n">srt</span> <span class="o">=</span> <span class="n">decl</span><span class="o">.</span><span class="n">range</span><span class="p">()</span>
                    <span class="n">dom</span> <span class="o">=</span>  <span class="n">srt</span><span class="o">.</span><span class="n">domain</span><span class="p">()</span>
                    <span class="n">e</span> <span class="o">=</span> <span class="n">K</span><span class="p">(</span><span class="n">dom</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span>
                    <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="n">sz</span> <span class="o">=</span> <span class="n">fi</span><span class="o">.</span><span class="n">num_entries</span><span class="p">()</span>
                    <span class="n">n</span> <span class="o">=</span> <span class="n">fi</span><span class="o">.</span><span class="n">arity</span><span class="p">()</span>
                    <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">sz</span><span class="p">:</span>
                        <span class="n">fe</span> <span class="o">=</span> <span class="n">fi</span><span class="o">.</span><span class="n">entry</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                        <span class="n">e</span> <span class="o">=</span> <span class="n">Store</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">fe</span><span class="o">.</span><span class="n">arg_value</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">fe</span><span class="o">.</span><span class="n">value</span><span class="p">())</span>
                        <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="k">return</span> <span class="n">e</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">r</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">FuncInterp</span><span class="p">(</span><span class="n">Z3_model_get_func_interp</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">,</span> <span class="n">decl</span><span class="o">.</span><span class="n">ast</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">Z3Exception</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">num_sorts</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the number of uninterpreted sorts that contain an interpretation in the model `self`.</span>

<span class="sd">        &gt;&gt;&gt; A = DeclareSort(&#39;A&#39;)</span>
<span class="sd">        &gt;&gt;&gt; a, b = Consts(&#39;a b&#39;, A)</span>
<span class="sd">        &gt;&gt;&gt; s = Solver()</span>
<span class="sd">        &gt;&gt;&gt; s.add(a != b)</span>
<span class="sd">        &gt;&gt;&gt; s.check()</span>
<span class="sd">        sat</span>
<span class="sd">        &gt;&gt;&gt; m = s.model()</span>
<span class="sd">        &gt;&gt;&gt; m.num_sorts()</span>
<span class="sd">        1</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">Z3_model_get_num_sorts</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">get_sort</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the uninterpreted sort at position `idx` &lt; self.num_sorts().</span>

<span class="sd">        &gt;&gt;&gt; A = DeclareSort(&#39;A&#39;)</span>
<span class="sd">        &gt;&gt;&gt; B = DeclareSort(&#39;B&#39;)</span>
<span class="sd">        &gt;&gt;&gt; a1, a2 = Consts(&#39;a1 a2&#39;, A)</span>
<span class="sd">        &gt;&gt;&gt; b1, b2 = Consts(&#39;b1 b2&#39;, B)</span>
<span class="sd">        &gt;&gt;&gt; s = Solver()</span>
<span class="sd">        &gt;&gt;&gt; s.add(a1 != a2, b1 != b2)</span>
<span class="sd">        &gt;&gt;&gt; s.check()</span>
<span class="sd">        sat</span>
<span class="sd">        &gt;&gt;&gt; m = s.model()</span>
<span class="sd">        &gt;&gt;&gt; m.num_sorts()</span>
<span class="sd">        2</span>
<span class="sd">        &gt;&gt;&gt; m.get_sort(0)</span>
<span class="sd">        A</span>
<span class="sd">        &gt;&gt;&gt; m.get_sort(1)</span>
<span class="sd">        B</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">idx</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_sorts</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">IndexError</span>
        <span class="k">return</span> <span class="n">_to_sort_ref</span><span class="p">(</span><span class="n">Z3_model_get_sort</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">,</span> <span class="n">idx</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">sorts</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return all uninterpreted sorts that have an interpretation in the model `self`.</span>

<span class="sd">        &gt;&gt;&gt; A = DeclareSort(&#39;A&#39;)</span>
<span class="sd">        &gt;&gt;&gt; B = DeclareSort(&#39;B&#39;)</span>
<span class="sd">        &gt;&gt;&gt; a1, a2 = Consts(&#39;a1 a2&#39;, A)</span>
<span class="sd">        &gt;&gt;&gt; b1, b2 = Consts(&#39;b1 b2&#39;, B)</span>
<span class="sd">        &gt;&gt;&gt; s = Solver()</span>
<span class="sd">        &gt;&gt;&gt; s.add(a1 != a2, b1 != b2)</span>
<span class="sd">        &gt;&gt;&gt; s.check()</span>
<span class="sd">        sat</span>
<span class="sd">        &gt;&gt;&gt; m = s.model()</span>
<span class="sd">        &gt;&gt;&gt; m.sorts()</span>
<span class="sd">        [A, B]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">get_sort</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_sorts</span><span class="p">())]</span>

    <span class="k">def</span> <span class="nf">get_universe</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the interpretation for the uninterpreted sort `s` in the model `self`.</span>

<span class="sd">        &gt;&gt;&gt; A = DeclareSort(&#39;A&#39;)</span>
<span class="sd">        &gt;&gt;&gt; a, b = Consts(&#39;a b&#39;, A)</span>
<span class="sd">        &gt;&gt;&gt; s = Solver()</span>
<span class="sd">        &gt;&gt;&gt; s.add(a != b)</span>
<span class="sd">        &gt;&gt;&gt; s.check()</span>
<span class="sd">        sat</span>
<span class="sd">        &gt;&gt;&gt; m = s.model()</span>
<span class="sd">        &gt;&gt;&gt; m.get_universe(A)</span>
<span class="sd">        [A!val!1, A!val!0]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">z3_debug</span><span class="p">():</span>
            <span class="n">_z3_assert</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">SortRef</span><span class="p">),</span> <span class="s2">&quot;Z3 sort expected&quot;</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">AstVector</span><span class="p">(</span><span class="n">Z3_model_get_sort_universe</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">,</span> <span class="n">s</span><span class="o">.</span><span class="n">ast</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">Z3Exception</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;If `idx` is an integer, then the declaration at position `idx` in the model `self` is returned.</span>
<span class="sd">        If `idx` is a declaration, then the actual interpretation is returned.</span>

<span class="sd">        The elements can be retrieved using position or the actual declaration.</span>

<span class="sd">        &gt;&gt;&gt; f = Function(&#39;f&#39;, IntSort(), IntSort())</span>
<span class="sd">        &gt;&gt;&gt; x = Int(&#39;x&#39;)</span>
<span class="sd">        &gt;&gt;&gt; s = Solver()</span>
<span class="sd">        &gt;&gt;&gt; s.add(x &gt; 0, x &lt; 2, f(x) == 0)</span>
<span class="sd">        &gt;&gt;&gt; s.check()</span>
<span class="sd">        sat</span>
<span class="sd">        &gt;&gt;&gt; m = s.model()</span>
<span class="sd">        &gt;&gt;&gt; len(m)</span>
<span class="sd">        2</span>
<span class="sd">        &gt;&gt;&gt; m[0]</span>
<span class="sd">        x</span>
<span class="sd">        &gt;&gt;&gt; m[1]</span>
<span class="sd">        f</span>
<span class="sd">        &gt;&gt;&gt; m[x]</span>
<span class="sd">        1</span>
<span class="sd">        &gt;&gt;&gt; m[f]</span>
<span class="sd">        [else -&gt; 0]</span>
<span class="sd">        &gt;&gt;&gt; for d in m: print(&quot;%s -&gt; %s&quot; % (d, m[d]))</span>
<span class="sd">        x -&gt; 1</span>
<span class="sd">        f -&gt; [else -&gt; 0]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">_is_int</span><span class="p">(</span><span class="n">idx</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">idx</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">IndexError</span>
            <span class="n">num_consts</span> <span class="o">=</span> <span class="n">Z3_model_get_num_consts</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">)</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">idx</span> <span class="o">&lt;</span> <span class="n">num_consts</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">FuncDeclRef</span><span class="p">(</span><span class="n">Z3_model_get_const_decl</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">,</span> <span class="n">idx</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">FuncDeclRef</span><span class="p">(</span><span class="n">Z3_model_get_func_decl</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">,</span> <span class="n">idx</span> <span class="o">-</span> <span class="n">num_consts</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">FuncDeclRef</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_interp</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">is_const</span><span class="p">(</span><span class="n">idx</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_interp</span><span class="p">(</span><span class="n">idx</span><span class="o">.</span><span class="n">decl</span><span class="p">())</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">SortRef</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_universe</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">z3_debug</span><span class="p">():</span>
            <span class="n">_z3_assert</span><span class="p">(</span><span class="kc">False</span><span class="p">,</span> <span class="s2">&quot;Integer, Z3 declaration, or Z3 constant expected&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">decls</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a list with all symbols that have an interpretation in the model `self`.</span>
<span class="sd">        &gt;&gt;&gt; f = Function(&#39;f&#39;, IntSort(), IntSort())</span>
<span class="sd">        &gt;&gt;&gt; x = Int(&#39;x&#39;)</span>
<span class="sd">        &gt;&gt;&gt; s = Solver()</span>
<span class="sd">        &gt;&gt;&gt; s.add(x &gt; 0, x &lt; 2, f(x) == 0)</span>
<span class="sd">        &gt;&gt;&gt; s.check()</span>
<span class="sd">        sat</span>
<span class="sd">        &gt;&gt;&gt; m = s.model()</span>
<span class="sd">        &gt;&gt;&gt; m.decls()</span>
<span class="sd">        [x, f]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">r</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">Z3_model_get_num_consts</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">)):</span>
            <span class="n">r</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">FuncDeclRef</span><span class="p">(</span><span class="n">Z3_model_get_const_decl</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">,</span> <span class="n">i</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">Z3_model_get_num_funcs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">)):</span>
            <span class="n">r</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">FuncDeclRef</span><span class="p">(</span><span class="n">Z3_model_get_func_decl</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">,</span> <span class="n">i</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">r</span>

    <span class="k">def</span> <span class="nf">update_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Update the interpretation of a constant&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">is_expr</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">decl</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">is_func_decl</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="ow">and</span> <span class="n">x</span><span class="o">.</span><span class="n">arity</span><span class="p">()</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">FuncInterp</span><span class="p">):</span>
            <span class="n">fi1</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">f</span>
            <span class="n">fi2</span> <span class="o">=</span> <span class="n">Z3_add_func_interp</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">ctx_ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">ast</span><span class="p">,</span> <span class="n">value</span><span class="o">.</span><span class="n">else_value</span><span class="p">()</span><span class="o">.</span><span class="n">ast</span><span class="p">);</span>
            <span class="n">fi2</span> <span class="o">=</span> <span class="n">FuncInterp</span><span class="p">(</span><span class="n">fi2</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">value</span><span class="o">.</span><span class="n">num_entries</span><span class="p">()):</span>
                <span class="n">e</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">entry</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                <span class="n">n</span> <span class="o">=</span> <span class="n">Z3_func_entry_get_num_args</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">ctx_ref</span><span class="p">(),</span> <span class="n">e</span><span class="o">.</span><span class="n">entry</span><span class="p">)</span>
                <span class="n">v</span> <span class="o">=</span> <span class="n">AstVector</span><span class="p">()</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
                    <span class="n">v</span><span class="o">.</span><span class="n">push</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">arg_value</span><span class="p">(</span><span class="n">j</span><span class="p">))</span>                    
                <span class="n">val</span> <span class="o">=</span> <span class="n">Z3_func_entry_get_value</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">ctx_ref</span><span class="p">(),</span> <span class="n">e</span><span class="o">.</span><span class="n">entry</span><span class="p">)</span>
                <span class="n">Z3_func_interp_add_entry</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">ctx_ref</span><span class="p">(),</span> <span class="n">fi2</span><span class="o">.</span><span class="n">f</span><span class="p">,</span> <span class="n">v</span><span class="o">.</span><span class="n">vector</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">is_func_decl</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="ow">or</span> <span class="n">x</span><span class="o">.</span><span class="n">arity</span><span class="p">()</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">Z3Exception</span><span class="p">(</span><span class="s2">&quot;Expecting 0-ary function or constant expression&quot;</span><span class="p">)</span>
        <span class="n">value</span> <span class="o">=</span> <span class="n">_py2expr</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        <span class="n">Z3_add_const_interp</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">ctx_ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">ast</span><span class="p">,</span> <span class="n">value</span><span class="o">.</span><span class="n">ast</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">translate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Translate `self` to the context `target`. That is, return a copy of `self` in the context `target`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">z3_debug</span><span class="p">():</span>
            <span class="n">_z3_assert</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">Context</span><span class="p">),</span> <span class="s2">&quot;argument must be a Z3 context&quot;</span><span class="p">)</span>
        <span class="n">model</span> <span class="o">=</span> <span class="n">Z3_model_translate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">,</span> <span class="n">target</span><span class="o">.</span><span class="n">ref</span><span class="p">())</span>
        <span class="k">return</span> <span class="n">ModelRef</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">target</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__copy__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">translate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__deepcopy__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">memo</span><span class="o">=</span><span class="p">{}):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">translate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">Model</span><span class="p">(</span><span class="n">ctx</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="n">ctx</span> <span class="o">=</span> <span class="n">_get_ctx</span><span class="p">(</span><span class="n">ctx</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">ModelRef</span><span class="p">(</span><span class="n">Z3_mk_model</span><span class="p">(</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">()),</span> <span class="n">ctx</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">is_as_array</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return true if n is a Z3 expression of the form (_ as-array f).&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">ExprRef</span><span class="p">)</span> <span class="ow">and</span> <span class="n">Z3_is_as_array</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="n">n</span><span class="o">.</span><span class="n">as_ast</span><span class="p">())</span>


<span class="k">def</span> <span class="nf">get_as_array_func</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return the function declaration f associated with a Z3 expression of the form (_ as-array f).&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">z3_debug</span><span class="p">():</span>
        <span class="n">_z3_assert</span><span class="p">(</span><span class="n">is_as_array</span><span class="p">(</span><span class="n">n</span><span class="p">),</span> <span class="s2">&quot;as-array Z3 expression expected.&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">FuncDeclRef</span><span class="p">(</span><span class="n">Z3_get_as_array_func_decl</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="n">n</span><span class="o">.</span><span class="n">as_ast</span><span class="p">()),</span> <span class="n">n</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>

<span class="c1">#########################################</span>
<span class="c1">#</span>
<span class="c1"># Statistics</span>
<span class="c1">#</span>
<span class="c1">#########################################</span>


<span class="k">class</span> <span class="nc">Statistics</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Statistics for `Solver.check()`.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stats</span><span class="p">,</span> <span class="n">ctx</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stats</span> <span class="o">=</span> <span class="n">stats</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span> <span class="o">=</span> <span class="n">ctx</span>
        <span class="n">Z3_stats_inc_ref</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">stats</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__deepcopy__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">memo</span><span class="o">=</span><span class="p">{}):</span>
        <span class="k">return</span> <span class="n">Statistics</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stats</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__del__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">()</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">Z3_stats_dec_ref</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">Z3_stats_dec_ref</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">stats</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">in_html_mode</span><span class="p">():</span>
            <span class="n">out</span> <span class="o">=</span> <span class="n">io</span><span class="o">.</span><span class="n">StringIO</span><span class="p">()</span>
            <span class="n">even</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">out</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">u</span><span class="p">(</span><span class="s1">&#39;&lt;table border=&quot;1&quot; cellpadding=&quot;2&quot; cellspacing=&quot;0&quot;&gt;&#39;</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">even</span><span class="p">:</span>
                    <span class="n">out</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">u</span><span class="p">(</span><span class="s1">&#39;&lt;tr style=&quot;background-color:#CFCFCF&quot;&gt;&#39;</span><span class="p">))</span>
                    <span class="n">even</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">out</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">u</span><span class="p">(</span><span class="s2">&quot;&lt;tr&gt;&quot;</span><span class="p">))</span>
                    <span class="n">even</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="n">out</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">u</span><span class="p">(</span><span class="s2">&quot;&lt;td&gt;</span><span class="si">%s</span><span class="s2">&lt;/td&gt;&lt;td&gt;</span><span class="si">%s</span><span class="s2">&lt;/td&gt;&lt;/tr&gt;&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)))</span>
            <span class="n">out</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">u</span><span class="p">(</span><span class="s2">&quot;&lt;/table&gt;&quot;</span><span class="p">))</span>
            <span class="k">return</span> <span class="n">out</span><span class="o">.</span><span class="n">getvalue</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Z3_stats_to_string</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">stats</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the number of statistical counters.</span>

<span class="sd">        &gt;&gt;&gt; x = Int(&#39;x&#39;)</span>
<span class="sd">        &gt;&gt;&gt; s = Then(&#39;simplify&#39;, &#39;nlsat&#39;).solver()</span>
<span class="sd">        &gt;&gt;&gt; s.add(x &gt; 0)</span>
<span class="sd">        &gt;&gt;&gt; s.check()</span>
<span class="sd">        sat</span>
<span class="sd">        &gt;&gt;&gt; st = s.statistics()</span>
<span class="sd">        &gt;&gt;&gt; len(st)</span>
<span class="sd">        6</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">Z3_stats_size</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">stats</span><span class="p">))</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the value of statistical counter at position `idx`. The result is a pair (key, value).</span>

<span class="sd">        &gt;&gt;&gt; x = Int(&#39;x&#39;)</span>
<span class="sd">        &gt;&gt;&gt; s = Then(&#39;simplify&#39;, &#39;nlsat&#39;).solver()</span>
<span class="sd">        &gt;&gt;&gt; s.add(x &gt; 0)</span>
<span class="sd">        &gt;&gt;&gt; s.check()</span>
<span class="sd">        sat</span>
<span class="sd">        &gt;&gt;&gt; st = s.statistics()</span>
<span class="sd">        &gt;&gt;&gt; len(st)</span>
<span class="sd">        6</span>
<span class="sd">        &gt;&gt;&gt; st[0]</span>
<span class="sd">        (&#39;nlsat propagations&#39;, 2)</span>
<span class="sd">        &gt;&gt;&gt; st[1]</span>
<span class="sd">        (&#39;nlsat stages&#39;, 2)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">idx</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">IndexError</span>
        <span class="k">if</span> <span class="n">Z3_stats_is_uint</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">stats</span><span class="p">,</span> <span class="n">idx</span><span class="p">):</span>
            <span class="n">val</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">Z3_stats_get_uint_value</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">stats</span><span class="p">,</span> <span class="n">idx</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">val</span> <span class="o">=</span> <span class="n">Z3_stats_get_double_value</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">stats</span><span class="p">,</span> <span class="n">idx</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">Z3_stats_get_key</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">stats</span><span class="p">,</span> <span class="n">idx</span><span class="p">),</span> <span class="n">val</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">keys</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the list of statistical counters.</span>

<span class="sd">        &gt;&gt;&gt; x = Int(&#39;x&#39;)</span>
<span class="sd">        &gt;&gt;&gt; s = Then(&#39;simplify&#39;, &#39;nlsat&#39;).solver()</span>
<span class="sd">        &gt;&gt;&gt; s.add(x &gt; 0)</span>
<span class="sd">        &gt;&gt;&gt; s.check()</span>
<span class="sd">        sat</span>
<span class="sd">        &gt;&gt;&gt; st = s.statistics()</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">Z3_stats_get_key</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">stats</span><span class="p">,</span> <span class="n">idx</span><span class="p">)</span> <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">))]</span>

    <span class="k">def</span> <span class="nf">get_key_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the value of a particular statistical counter.</span>

<span class="sd">        &gt;&gt;&gt; x = Int(&#39;x&#39;)</span>
<span class="sd">        &gt;&gt;&gt; s = Then(&#39;simplify&#39;, &#39;nlsat&#39;).solver()</span>
<span class="sd">        &gt;&gt;&gt; s.add(x &gt; 0)</span>
<span class="sd">        &gt;&gt;&gt; s.check()</span>
<span class="sd">        sat</span>
<span class="sd">        &gt;&gt;&gt; st = s.statistics()</span>
<span class="sd">        &gt;&gt;&gt; st.get_key_value(&#39;nlsat propagations&#39;)</span>
<span class="sd">        2</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">key</span> <span class="o">==</span> <span class="n">Z3_stats_get_key</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">stats</span><span class="p">,</span> <span class="n">idx</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">Z3_stats_is_uint</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">stats</span><span class="p">,</span> <span class="n">idx</span><span class="p">):</span>
                    <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">Z3_stats_get_uint_value</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">stats</span><span class="p">,</span> <span class="n">idx</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">Z3_stats_get_double_value</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">stats</span><span class="p">,</span> <span class="n">idx</span><span class="p">)</span>
        <span class="k">raise</span> <span class="n">Z3Exception</span><span class="p">(</span><span class="s2">&quot;unknown key&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__getattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Access the value of statistical using attributes.</span>

<span class="sd">        Remark: to access a counter containing blank spaces (e.g., &#39;nlsat propagations&#39;),</span>
<span class="sd">        we should use &#39;_&#39; (e.g., &#39;nlsat_propagations&#39;).</span>

<span class="sd">        &gt;&gt;&gt; x = Int(&#39;x&#39;)</span>
<span class="sd">        &gt;&gt;&gt; s = Then(&#39;simplify&#39;, &#39;nlsat&#39;).solver()</span>
<span class="sd">        &gt;&gt;&gt; s.add(x &gt; 0)</span>
<span class="sd">        &gt;&gt;&gt; s.check()</span>
<span class="sd">        sat</span>
<span class="sd">        &gt;&gt;&gt; st = s.statistics()</span>
<span class="sd">        &gt;&gt;&gt; st.nlsat_propagations</span>
<span class="sd">        2</span>
<span class="sd">        &gt;&gt;&gt; st.nlsat_stages</span>
<span class="sd">        2</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">key</span> <span class="o">=</span> <span class="n">name</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;_&quot;</span><span class="p">,</span> <span class="s2">&quot; &quot;</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_key_value</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">Z3Exception</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span>

<span class="c1">#########################################</span>
<span class="c1">#</span>
<span class="c1"># Solver</span>
<span class="c1">#</span>
<span class="c1">#########################################</span>


<span class="k">class</span> <span class="nc">CheckSatResult</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Represents the result of a satisfiability check: sat, unsat, unknown.</span>

<span class="sd">    &gt;&gt;&gt; s = Solver()</span>
<span class="sd">    &gt;&gt;&gt; s.check()</span>
<span class="sd">    sat</span>
<span class="sd">    &gt;&gt;&gt; r = s.check()</span>
<span class="sd">    &gt;&gt;&gt; isinstance(r, CheckSatResult)</span>
<span class="sd">    True</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">r</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">r</span> <span class="o">=</span> <span class="n">r</span>

    <span class="k">def</span> <span class="nf">__deepcopy__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">memo</span><span class="o">=</span><span class="p">{}):</span>
        <span class="k">return</span> <span class="n">CheckSatResult</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">r</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">CheckSatResult</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">r</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">r</span>

    <span class="k">def</span> <span class="fm">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__eq__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">in_html_mode</span><span class="p">():</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">r</span> <span class="o">==</span> <span class="n">Z3_L_TRUE</span><span class="p">:</span>
                <span class="k">return</span> <span class="s2">&quot;&lt;b&gt;sat&lt;/b&gt;&quot;</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">r</span> <span class="o">==</span> <span class="n">Z3_L_FALSE</span><span class="p">:</span>
                <span class="k">return</span> <span class="s2">&quot;&lt;b&gt;unsat&lt;/b&gt;&quot;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="s2">&quot;&lt;b&gt;unknown&lt;/b&gt;&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">r</span> <span class="o">==</span> <span class="n">Z3_L_TRUE</span><span class="p">:</span>
                <span class="k">return</span> <span class="s2">&quot;sat&quot;</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">r</span> <span class="o">==</span> <span class="n">Z3_L_FALSE</span><span class="p">:</span>
                <span class="k">return</span> <span class="s2">&quot;unsat&quot;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="s2">&quot;unknown&quot;</span>

    <span class="k">def</span> <span class="nf">_repr_html_</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">in_html</span> <span class="o">=</span> <span class="n">in_html_mode</span><span class="p">()</span>
        <span class="n">set_html_mode</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">res</span> <span class="o">=</span> <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">set_html_mode</span><span class="p">(</span><span class="n">in_html</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">res</span>


<span class="n">sat</span> <span class="o">=</span> <span class="n">CheckSatResult</span><span class="p">(</span><span class="n">Z3_L_TRUE</span><span class="p">)</span>
<span class="n">unsat</span> <span class="o">=</span> <span class="n">CheckSatResult</span><span class="p">(</span><span class="n">Z3_L_FALSE</span><span class="p">)</span>
<span class="n">unknown</span> <span class="o">=</span> <span class="n">CheckSatResult</span><span class="p">(</span><span class="n">Z3_L_UNDEF</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">Solver</span><span class="p">(</span><span class="n">Z3PPObject</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Solver API provides methods for implementing the main SMT 2.0 commands:</span>
<span class="sd">    push, pop, check, get-model, etc.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">solver</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ctx</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">logFile</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">assert</span> <span class="n">solver</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">ctx</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span> <span class="o">=</span> <span class="n">_get_ctx</span><span class="p">(</span><span class="n">ctx</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">backtrack_level</span> <span class="o">=</span> <span class="mi">4000000000</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">solver</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">solver</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">solver</span> <span class="o">=</span> <span class="n">Z3_mk_solver</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">())</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">solver</span> <span class="o">=</span> <span class="n">solver</span>
        <span class="n">Z3_solver_inc_ref</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">solver</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">logFile</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s2">&quot;smtlib2_log&quot;</span><span class="p">,</span> <span class="n">logFile</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__del__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">solver</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">()</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">Z3_solver_dec_ref</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">Z3_solver_dec_ref</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">solver</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__enter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">push</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="fm">__exit__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">exc_info</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">set</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">keys</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Set a configuration option.</span>
<span class="sd">        The method `help()` return a string containing all available options.</span>

<span class="sd">        &gt;&gt;&gt; s = Solver()</span>
<span class="sd">        &gt;&gt;&gt; # The option MBQI can be set using three different approaches.</span>
<span class="sd">        &gt;&gt;&gt; s.set(mbqi=True)</span>
<span class="sd">        &gt;&gt;&gt; s.set(&#39;MBQI&#39;, True)</span>
<span class="sd">        &gt;&gt;&gt; s.set(&#39;:mbqi&#39;, True)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">args2params</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">keys</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>
        <span class="n">Z3_solver_set_params</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">solver</span><span class="p">,</span> <span class="n">p</span><span class="o">.</span><span class="n">params</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">push</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create a backtracking point.</span>

<span class="sd">        &gt;&gt;&gt; x = Int(&#39;x&#39;)</span>
<span class="sd">        &gt;&gt;&gt; s = Solver()</span>
<span class="sd">        &gt;&gt;&gt; s.add(x &gt; 0)</span>
<span class="sd">        &gt;&gt;&gt; s</span>
<span class="sd">        [x &gt; 0]</span>
<span class="sd">        &gt;&gt;&gt; s.push()</span>
<span class="sd">        &gt;&gt;&gt; s.add(x &lt; 1)</span>
<span class="sd">        &gt;&gt;&gt; s</span>
<span class="sd">        [x &gt; 0, x &lt; 1]</span>
<span class="sd">        &gt;&gt;&gt; s.check()</span>
<span class="sd">        unsat</span>
<span class="sd">        &gt;&gt;&gt; s.pop()</span>
<span class="sd">        &gt;&gt;&gt; s.check()</span>
<span class="sd">        sat</span>
<span class="sd">        &gt;&gt;&gt; s</span>
<span class="sd">        [x &gt; 0]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">Z3_solver_push</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">solver</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">pop</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">num</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Backtrack \\c num backtracking points.</span>

<span class="sd">        &gt;&gt;&gt; x = Int(&#39;x&#39;)</span>
<span class="sd">        &gt;&gt;&gt; s = Solver()</span>
<span class="sd">        &gt;&gt;&gt; s.add(x &gt; 0)</span>
<span class="sd">        &gt;&gt;&gt; s</span>
<span class="sd">        [x &gt; 0]</span>
<span class="sd">        &gt;&gt;&gt; s.push()</span>
<span class="sd">        &gt;&gt;&gt; s.add(x &lt; 1)</span>
<span class="sd">        &gt;&gt;&gt; s</span>
<span class="sd">        [x &gt; 0, x &lt; 1]</span>
<span class="sd">        &gt;&gt;&gt; s.check()</span>
<span class="sd">        unsat</span>
<span class="sd">        &gt;&gt;&gt; s.pop()</span>
<span class="sd">        &gt;&gt;&gt; s.check()</span>
<span class="sd">        sat</span>
<span class="sd">        &gt;&gt;&gt; s</span>
<span class="sd">        [x &gt; 0]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">Z3_solver_pop</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">solver</span><span class="p">,</span> <span class="n">num</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">num_scopes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the current number of backtracking points.</span>

<span class="sd">        &gt;&gt;&gt; s = Solver()</span>
<span class="sd">        &gt;&gt;&gt; s.num_scopes()</span>
<span class="sd">        0</span>
<span class="sd">        &gt;&gt;&gt; s.push()</span>
<span class="sd">        &gt;&gt;&gt; s.num_scopes()</span>
<span class="sd">        1</span>
<span class="sd">        &gt;&gt;&gt; s.push()</span>
<span class="sd">        &gt;&gt;&gt; s.num_scopes()</span>
<span class="sd">        2</span>
<span class="sd">        &gt;&gt;&gt; s.pop()</span>
<span class="sd">        &gt;&gt;&gt; s.num_scopes()</span>
<span class="sd">        1</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Z3_solver_get_num_scopes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">solver</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">reset</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Remove all asserted constraints and backtracking points created using `push()`.</span>

<span class="sd">        &gt;&gt;&gt; x = Int(&#39;x&#39;)</span>
<span class="sd">        &gt;&gt;&gt; s = Solver()</span>
<span class="sd">        &gt;&gt;&gt; s.add(x &gt; 0)</span>
<span class="sd">        &gt;&gt;&gt; s</span>
<span class="sd">        [x &gt; 0]</span>
<span class="sd">        &gt;&gt;&gt; s.reset()</span>
<span class="sd">        &gt;&gt;&gt; s</span>
<span class="sd">        []</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">Z3_solver_reset</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">solver</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">assert_exprs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Assert constraints into the solver.</span>

<span class="sd">        &gt;&gt;&gt; x = Int(&#39;x&#39;)</span>
<span class="sd">        &gt;&gt;&gt; s = Solver()</span>
<span class="sd">        &gt;&gt;&gt; s.assert_exprs(x &gt; 0, x &lt; 2)</span>
<span class="sd">        &gt;&gt;&gt; s</span>
<span class="sd">        [x &gt; 0, x &lt; 2]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">args</span> <span class="o">=</span> <span class="n">_get_args</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">BoolSort</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">args</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">Goal</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">AstVector</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">arg</span><span class="p">:</span>
                    <span class="n">Z3_solver_assert</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">solver</span><span class="p">,</span> <span class="n">f</span><span class="o">.</span><span class="n">as_ast</span><span class="p">())</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">arg</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>
                <span class="n">Z3_solver_assert</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">solver</span><span class="p">,</span> <span class="n">arg</span><span class="o">.</span><span class="n">as_ast</span><span class="p">())</span>

    <span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Assert constraints into the solver.</span>

<span class="sd">        &gt;&gt;&gt; x = Int(&#39;x&#39;)</span>
<span class="sd">        &gt;&gt;&gt; s = Solver()</span>
<span class="sd">        &gt;&gt;&gt; s.add(x &gt; 0, x &lt; 2)</span>
<span class="sd">        &gt;&gt;&gt; s</span>
<span class="sd">        [x &gt; 0, x &lt; 2]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">assert_exprs</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__iadd__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fml</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">fml</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">append</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Assert constraints into the solver.</span>

<span class="sd">        &gt;&gt;&gt; x = Int(&#39;x&#39;)</span>
<span class="sd">        &gt;&gt;&gt; s = Solver()</span>
<span class="sd">        &gt;&gt;&gt; s.append(x &gt; 0, x &lt; 2)</span>
<span class="sd">        &gt;&gt;&gt; s</span>
<span class="sd">        [x &gt; 0, x &lt; 2]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">assert_exprs</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">insert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Assert constraints into the solver.</span>

<span class="sd">        &gt;&gt;&gt; x = Int(&#39;x&#39;)</span>
<span class="sd">        &gt;&gt;&gt; s = Solver()</span>
<span class="sd">        &gt;&gt;&gt; s.insert(x &gt; 0, x &lt; 2)</span>
<span class="sd">        &gt;&gt;&gt; s</span>
<span class="sd">        [x &gt; 0, x &lt; 2]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">assert_exprs</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">assert_and_track</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">p</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Assert constraint `a` and track it in the unsat core using the Boolean constant `p`.</span>

<span class="sd">        If `p` is a string, it will be automatically converted into a Boolean constant.</span>

<span class="sd">        &gt;&gt;&gt; x = Int(&#39;x&#39;)</span>
<span class="sd">        &gt;&gt;&gt; p3 = Bool(&#39;p3&#39;)</span>
<span class="sd">        &gt;&gt;&gt; s = Solver()</span>
<span class="sd">        &gt;&gt;&gt; s.set(unsat_core=True)</span>
<span class="sd">        &gt;&gt;&gt; s.assert_and_track(x &gt; 0,  &#39;p1&#39;)</span>
<span class="sd">        &gt;&gt;&gt; s.assert_and_track(x != 1, &#39;p2&#39;)</span>
<span class="sd">        &gt;&gt;&gt; s.assert_and_track(x &lt; 0,  p3)</span>
<span class="sd">        &gt;&gt;&gt; print(s.check())</span>
<span class="sd">        unsat</span>
<span class="sd">        &gt;&gt;&gt; c = s.unsat_core()</span>
<span class="sd">        &gt;&gt;&gt; len(c)</span>
<span class="sd">        2</span>
<span class="sd">        &gt;&gt;&gt; Bool(&#39;p1&#39;) in c</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; Bool(&#39;p2&#39;) in c</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; p3 in c</span>
<span class="sd">        True</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">Bool</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>
        <span class="n">_z3_assert</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">BoolRef</span><span class="p">),</span> <span class="s2">&quot;Boolean expression expected&quot;</span><span class="p">)</span>
        <span class="n">_z3_assert</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">BoolRef</span><span class="p">)</span> <span class="ow">and</span> <span class="n">is_const</span><span class="p">(</span><span class="n">p</span><span class="p">),</span> <span class="s2">&quot;Boolean expression expected&quot;</span><span class="p">)</span>
        <span class="n">Z3_solver_assert_and_track</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">solver</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">as_ast</span><span class="p">(),</span> <span class="n">p</span><span class="o">.</span><span class="n">as_ast</span><span class="p">())</span>

    <span class="k">def</span> <span class="nf">check</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">assumptions</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Check whether the assertions in the given solver plus the optional assumptions are consistent or not.</span>

<span class="sd">        &gt;&gt;&gt; x = Int(&#39;x&#39;)</span>
<span class="sd">        &gt;&gt;&gt; s = Solver()</span>
<span class="sd">        &gt;&gt;&gt; s.check()</span>
<span class="sd">        sat</span>
<span class="sd">        &gt;&gt;&gt; s.add(x &gt; 0, x &lt; 2)</span>
<span class="sd">        &gt;&gt;&gt; s.check()</span>
<span class="sd">        sat</span>
<span class="sd">        &gt;&gt;&gt; s.model().eval(x)</span>
<span class="sd">        1</span>
<span class="sd">        &gt;&gt;&gt; s.add(x &lt; 1)</span>
<span class="sd">        &gt;&gt;&gt; s.check()</span>
<span class="sd">        unsat</span>
<span class="sd">        &gt;&gt;&gt; s.reset()</span>
<span class="sd">        &gt;&gt;&gt; s.add(2**x == 4)</span>
<span class="sd">        &gt;&gt;&gt; s.check()</span>
<span class="sd">        unknown</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">BoolSort</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>
        <span class="n">assumptions</span> <span class="o">=</span> <span class="n">_get_args</span><span class="p">(</span><span class="n">assumptions</span><span class="p">)</span>
        <span class="n">num</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">assumptions</span><span class="p">)</span>
        <span class="n">_assumptions</span> <span class="o">=</span> <span class="p">(</span><span class="n">Ast</span> <span class="o">*</span> <span class="n">num</span><span class="p">)()</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num</span><span class="p">):</span>
            <span class="n">_assumptions</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="n">assumptions</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">.</span><span class="n">as_ast</span><span class="p">()</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">Z3_solver_check_assumptions</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">solver</span><span class="p">,</span> <span class="n">num</span><span class="p">,</span> <span class="n">_assumptions</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">CheckSatResult</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">model</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a model for the last `check()`.</span>

<span class="sd">        This function raises an exception if</span>
<span class="sd">        a model is not available (e.g., last `check()` returned unsat).</span>

<span class="sd">        &gt;&gt;&gt; s = Solver()</span>
<span class="sd">        &gt;&gt;&gt; a = Int(&#39;a&#39;)</span>
<span class="sd">        &gt;&gt;&gt; s.add(a + 2 == 0)</span>
<span class="sd">        &gt;&gt;&gt; s.check()</span>
<span class="sd">        sat</span>
<span class="sd">        &gt;&gt;&gt; s.model()</span>
<span class="sd">        [a = -2]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">ModelRef</span><span class="p">(</span><span class="n">Z3_solver_get_model</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">solver</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">Z3Exception</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">Z3Exception</span><span class="p">(</span><span class="s2">&quot;model is not available&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">import_model_converter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Import model converter from other into the current solver&quot;&quot;&quot;</span>
        <span class="n">Z3_solver_import_model_converter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="n">other</span><span class="o">.</span><span class="n">solver</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">solver</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">interrupt</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Interrupt the execution of the solver object.</span>
<span class="sd">        Remarks: This ensures that the interrupt applies only</span>
<span class="sd">        to the given solver object and it applies only if it is running.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">Z3_solver_interrupt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">solver</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">unsat_core</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a subset (as an AST vector) of the assumptions provided to the last check().</span>

<span class="sd">        These are the assumptions Z3 used in the unsatisfiability proof.</span>
<span class="sd">        Assumptions are available in Z3. They are used to extract unsatisfiable cores.</span>
<span class="sd">        They may be also used to &quot;retract&quot; assumptions. Note that, assumptions are not really</span>
<span class="sd">        &quot;soft constraints&quot;, but they can be used to implement them.</span>

<span class="sd">        &gt;&gt;&gt; p1, p2, p3 = Bools(&#39;p1 p2 p3&#39;)</span>
<span class="sd">        &gt;&gt;&gt; x, y       = Ints(&#39;x y&#39;)</span>
<span class="sd">        &gt;&gt;&gt; s          = Solver()</span>
<span class="sd">        &gt;&gt;&gt; s.add(Implies(p1, x &gt; 0))</span>
<span class="sd">        &gt;&gt;&gt; s.add(Implies(p2, y &gt; x))</span>
<span class="sd">        &gt;&gt;&gt; s.add(Implies(p2, y &lt; 1))</span>
<span class="sd">        &gt;&gt;&gt; s.add(Implies(p3, y &gt; -3))</span>
<span class="sd">        &gt;&gt;&gt; s.check(p1, p2, p3)</span>
<span class="sd">        unsat</span>
<span class="sd">        &gt;&gt;&gt; core = s.unsat_core()</span>
<span class="sd">        &gt;&gt;&gt; len(core)</span>
<span class="sd">        2</span>
<span class="sd">        &gt;&gt;&gt; p1 in core</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; p2 in core</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; p3 in core</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; # &quot;Retracting&quot; p2</span>
<span class="sd">        &gt;&gt;&gt; s.check(p1, p3)</span>
<span class="sd">        sat</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">AstVector</span><span class="p">(</span><span class="n">Z3_solver_get_unsat_core</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">solver</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">consequences</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">assumptions</span><span class="p">,</span> <span class="n">variables</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Determine fixed values for the variables based on the solver state and assumptions.</span>
<span class="sd">        &gt;&gt;&gt; s = Solver()</span>
<span class="sd">        &gt;&gt;&gt; a, b, c, d = Bools(&#39;a b c d&#39;)</span>
<span class="sd">        &gt;&gt;&gt; s.add(Implies(a,b), Implies(b, c))</span>
<span class="sd">        &gt;&gt;&gt; s.consequences([a],[b,c,d])</span>
<span class="sd">        (sat, [Implies(a, b), Implies(a, c)])</span>
<span class="sd">        &gt;&gt;&gt; s.consequences([Not(c),d],[a,b,c,d])</span>
<span class="sd">        (sat, [Implies(d, d), Implies(Not(c), Not(c)), Implies(Not(c), Not(b)), Implies(Not(c), Not(a))])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">assumptions</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">_asms</span> <span class="o">=</span> <span class="n">AstVector</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">assumptions</span><span class="p">:</span>
                <span class="n">_asms</span><span class="o">.</span><span class="n">push</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
            <span class="n">assumptions</span> <span class="o">=</span> <span class="n">_asms</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">variables</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">_vars</span> <span class="o">=</span> <span class="n">AstVector</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">variables</span><span class="p">:</span>
                <span class="n">_vars</span><span class="o">.</span><span class="n">push</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
            <span class="n">variables</span> <span class="o">=</span> <span class="n">_vars</span>
        <span class="n">_z3_assert</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">assumptions</span><span class="p">,</span> <span class="n">AstVector</span><span class="p">),</span> <span class="s2">&quot;ast vector expected&quot;</span><span class="p">)</span>
        <span class="n">_z3_assert</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">variables</span><span class="p">,</span> <span class="n">AstVector</span><span class="p">),</span> <span class="s2">&quot;ast vector expected&quot;</span><span class="p">)</span>
        <span class="n">consequences</span> <span class="o">=</span> <span class="n">AstVector</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">Z3_solver_get_consequences</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">solver</span><span class="p">,</span> <span class="n">assumptions</span><span class="o">.</span><span class="n">vector</span><span class="p">,</span>
                                       <span class="n">variables</span><span class="o">.</span><span class="n">vector</span><span class="p">,</span> <span class="n">consequences</span><span class="o">.</span><span class="n">vector</span><span class="p">)</span>
        <span class="n">sz</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">consequences</span><span class="p">)</span>
        <span class="n">consequences</span> <span class="o">=</span> <span class="p">[</span><span class="n">consequences</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">sz</span><span class="p">)]</span>
        <span class="k">return</span> <span class="n">CheckSatResult</span><span class="p">(</span><span class="n">r</span><span class="p">),</span> <span class="n">consequences</span>

    <span class="k">def</span> <span class="nf">from_file</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Parse assertions from a file&quot;&quot;&quot;</span>
        <span class="n">Z3_solver_from_file</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">solver</span><span class="p">,</span> <span class="n">filename</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">from_string</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Parse assertions from a string&quot;&quot;&quot;</span>
        <span class="n">Z3_solver_from_string</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">solver</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">cube</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">vars</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get set of cubes</span>
<span class="sd">        The method takes an optional set of variables that restrict which</span>
<span class="sd">        variables may be used as a starting point for cubing.</span>
<span class="sd">        If vars is not None, then the first case split is based on a variable in</span>
<span class="sd">        this set.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cube_vs</span> <span class="o">=</span> <span class="n">AstVector</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">vars</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">vars</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">cube_vs</span><span class="o">.</span><span class="n">push</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">lvl</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">backtrack_level</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">backtrack_level</span> <span class="o">=</span> <span class="mi">4000000000</span>
            <span class="n">r</span> <span class="o">=</span> <span class="n">AstVector</span><span class="p">(</span><span class="n">Z3_solver_cube</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">solver</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cube_vs</span><span class="o">.</span><span class="n">vector</span><span class="p">,</span> <span class="n">lvl</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>
            <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">is_false</span><span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">])):</span>
                <span class="k">return</span>
            <span class="k">yield</span> <span class="n">r</span>
            <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
                <span class="k">return</span>

    <span class="k">def</span> <span class="nf">cube_vars</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Access the set of variables that were touched by the most recently generated cube.</span>
<span class="sd">        This set of variables can be used as a starting point for additional cubes.</span>
<span class="sd">        The idea is that variables that appear in clauses that are reduced by the most recent</span>
<span class="sd">        cube are likely more useful to cube on.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">cube_vs</span>

    <span class="k">def</span> <span class="nf">root</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">_py2expr</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Retrieve congruence closure root of the term t relative to the current search state</span>
<span class="sd">        The function primarily works for SimpleSolver. Terms and variables that are</span>
<span class="sd">        eliminated during pre-processing are not visible to the congruence closure.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_to_expr_ref</span><span class="p">(</span><span class="n">Z3_solver_congruence_root</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">solver</span><span class="p">,</span> <span class="n">t</span><span class="o">.</span><span class="n">ast</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">next</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">_py2expr</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Retrieve congruence closure sibling of the term t relative to the current search state</span>
<span class="sd">        The function primarily works for SimpleSolver. Terms and variables that are</span>
<span class="sd">        eliminated during pre-processing are not visible to the congruence closure.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_to_expr_ref</span><span class="p">(</span><span class="n">Z3_solver_congruence_next</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">solver</span><span class="p">,</span> <span class="n">t</span><span class="o">.</span><span class="n">ast</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">proof</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a proof for the last `check()`. Proof construction must be enabled.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_to_expr_ref</span><span class="p">(</span><span class="n">Z3_solver_get_proof</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">solver</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">assertions</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return an AST vector containing all added constraints.</span>

<span class="sd">        &gt;&gt;&gt; s = Solver()</span>
<span class="sd">        &gt;&gt;&gt; s.assertions()</span>
<span class="sd">        []</span>
<span class="sd">        &gt;&gt;&gt; a = Int(&#39;a&#39;)</span>
<span class="sd">        &gt;&gt;&gt; s.add(a &gt; 0)</span>
<span class="sd">        &gt;&gt;&gt; s.add(a &lt; 10)</span>
<span class="sd">        &gt;&gt;&gt; s.assertions()</span>
<span class="sd">        [a &gt; 0, a &lt; 10]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">AstVector</span><span class="p">(</span><span class="n">Z3_solver_get_assertions</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">solver</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">units</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return an AST vector containing all currently inferred units.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">AstVector</span><span class="p">(</span><span class="n">Z3_solver_get_units</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">solver</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">non_units</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return an AST vector containing all atomic formulas in solver state that are not units.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">AstVector</span><span class="p">(</span><span class="n">Z3_solver_get_non_units</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">solver</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">trail_levels</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return trail and decision levels of the solver state after a check() call.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">trail</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">trail</span><span class="p">()</span>
        <span class="n">levels</span> <span class="o">=</span> <span class="p">(</span><span class="n">ctypes</span><span class="o">.</span><span class="n">c_uint</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">trail</span><span class="p">))()</span>
        <span class="n">Z3_solver_get_levels</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">solver</span><span class="p">,</span> <span class="n">trail</span><span class="o">.</span><span class="n">vector</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">trail</span><span class="p">),</span> <span class="n">levels</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">trail</span><span class="p">,</span> <span class="n">levels</span>

    <span class="k">def</span> <span class="nf">trail</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return trail of the solver state after a check() call.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">AstVector</span><span class="p">(</span><span class="n">Z3_solver_get_trail</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">solver</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">statistics</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return statistics for the last `check()`.</span>

<span class="sd">        &gt;&gt;&gt; s = SimpleSolver()</span>
<span class="sd">        &gt;&gt;&gt; x = Int(&#39;x&#39;)</span>
<span class="sd">        &gt;&gt;&gt; s.add(x &gt; 0)</span>
<span class="sd">        &gt;&gt;&gt; s.check()</span>
<span class="sd">        sat</span>
<span class="sd">        &gt;&gt;&gt; st = s.statistics()</span>
<span class="sd">        &gt;&gt;&gt; st.get_key_value(&#39;final checks&#39;)</span>
<span class="sd">        1</span>
<span class="sd">        &gt;&gt;&gt; len(st) &gt; 0</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; st[0] != 0</span>
<span class="sd">        True</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Statistics</span><span class="p">(</span><span class="n">Z3_solver_get_statistics</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">solver</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">reason_unknown</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a string describing why the last `check()` returned `unknown`.</span>

<span class="sd">        &gt;&gt;&gt; x = Int(&#39;x&#39;)</span>
<span class="sd">        &gt;&gt;&gt; s = SimpleSolver()</span>
<span class="sd">        &gt;&gt;&gt; s.add(2**x == 4)</span>
<span class="sd">        &gt;&gt;&gt; s.check()</span>
<span class="sd">        unknown</span>
<span class="sd">        &gt;&gt;&gt; s.reason_unknown()</span>
<span class="sd">        &#39;(incomplete (theory arithmetic))&#39;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Z3_solver_get_reason_unknown</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">solver</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">help</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Display a string describing all available options.&quot;&quot;&quot;</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">Z3_solver_get_help</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">solver</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">param_descrs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the parameter description set.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">ParamDescrsRef</span><span class="p">(</span><span class="n">Z3_solver_get_param_descrs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">solver</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a formatted string with all added constraints.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">obj_to_string</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">translate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Translate `self` to the context `target`. That is, return a copy of `self` in the context `target`.</span>

<span class="sd">        &gt;&gt;&gt; c1 = Context()</span>
<span class="sd">        &gt;&gt;&gt; c2 = Context()</span>
<span class="sd">        &gt;&gt;&gt; s1 = Solver(ctx=c1)</span>
<span class="sd">        &gt;&gt;&gt; s2 = s1.translate(c2)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">z3_debug</span><span class="p">():</span>
            <span class="n">_z3_assert</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">Context</span><span class="p">),</span> <span class="s2">&quot;argument must be a Z3 context&quot;</span><span class="p">)</span>
        <span class="n">solver</span> <span class="o">=</span> <span class="n">Z3_solver_translate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">solver</span><span class="p">,</span> <span class="n">target</span><span class="o">.</span><span class="n">ref</span><span class="p">())</span>
        <span class="k">return</span> <span class="n">Solver</span><span class="p">(</span><span class="n">solver</span><span class="p">,</span> <span class="n">target</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__copy__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">translate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__deepcopy__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">memo</span><span class="o">=</span><span class="p">{}):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">translate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">sexpr</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a formatted string (in Lisp-like format) with all added constraints.</span>
<span class="sd">        We say the string is in s-expression format.</span>

<span class="sd">        &gt;&gt;&gt; x = Int(&#39;x&#39;)</span>
<span class="sd">        &gt;&gt;&gt; s = Solver()</span>
<span class="sd">        &gt;&gt;&gt; s.add(x &gt; 0)</span>
<span class="sd">        &gt;&gt;&gt; s.add(x &lt; 2)</span>
<span class="sd">        &gt;&gt;&gt; r = s.sexpr()</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Z3_solver_to_string</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">solver</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">dimacs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">include_names</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a textual representation of the solver in DIMACS format.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Z3_solver_to_dimacs_string</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">solver</span><span class="p">,</span> <span class="n">include_names</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">to_smt2</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;return SMTLIB2 formatted benchmark for solver&#39;s assertions&quot;&quot;&quot;</span>
        <span class="n">es</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">assertions</span><span class="p">()</span>
        <span class="n">sz</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">es</span><span class="p">)</span>
        <span class="n">sz1</span> <span class="o">=</span> <span class="n">sz</span>
        <span class="k">if</span> <span class="n">sz1</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">sz1</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="n">v</span> <span class="o">=</span> <span class="p">(</span><span class="n">Ast</span> <span class="o">*</span> <span class="n">sz1</span><span class="p">)()</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">sz1</span><span class="p">):</span>
            <span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">es</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">as_ast</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">sz</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">e</span> <span class="o">=</span> <span class="n">es</span><span class="p">[</span><span class="n">sz1</span><span class="p">]</span><span class="o">.</span><span class="n">as_ast</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">e</span> <span class="o">=</span> <span class="n">BoolVal</span><span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span><span class="o">.</span><span class="n">as_ast</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">Z3_benchmark_to_smtlib_string</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="s2">&quot;benchmark generated from python API&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="s2">&quot;unknown&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">sz1</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">e</span><span class="p">,</span>
        <span class="p">)</span>


<span class="k">def</span> <span class="nf">SolverFor</span><span class="p">(</span><span class="n">logic</span><span class="p">,</span> <span class="n">ctx</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">logFile</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Create a solver customized for the given logic.</span>

<span class="sd">    The parameter `logic` is a string. It should be contains</span>
<span class="sd">    the name of a SMT-LIB logic.</span>
<span class="sd">    See http://www.smtlib.org/ for the name of all available logics.</span>

<span class="sd">    &gt;&gt;&gt; s = SolverFor(&quot;QF_LIA&quot;)</span>
<span class="sd">    &gt;&gt;&gt; x = Int(&#39;x&#39;)</span>
<span class="sd">    &gt;&gt;&gt; s.add(x &gt; 0)</span>
<span class="sd">    &gt;&gt;&gt; s.add(x &lt; 2)</span>
<span class="sd">    &gt;&gt;&gt; s.check()</span>
<span class="sd">    sat</span>
<span class="sd">    &gt;&gt;&gt; s.model()</span>
<span class="sd">    [x = 1]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ctx</span> <span class="o">=</span> <span class="n">_get_ctx</span><span class="p">(</span><span class="n">ctx</span><span class="p">)</span>
    <span class="n">logic</span> <span class="o">=</span> <span class="n">to_symbol</span><span class="p">(</span><span class="n">logic</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">Solver</span><span class="p">(</span><span class="n">Z3_mk_solver_for_logic</span><span class="p">(</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="n">logic</span><span class="p">),</span> <span class="n">ctx</span><span class="p">,</span> <span class="n">logFile</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">SimpleSolver</span><span class="p">(</span><span class="n">ctx</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">logFile</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return a simple general purpose solver with limited amount of preprocessing.</span>

<span class="sd">    &gt;&gt;&gt; s = SimpleSolver()</span>
<span class="sd">    &gt;&gt;&gt; x = Int(&#39;x&#39;)</span>
<span class="sd">    &gt;&gt;&gt; s.add(x &gt; 0)</span>
<span class="sd">    &gt;&gt;&gt; s.check()</span>
<span class="sd">    sat</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ctx</span> <span class="o">=</span> <span class="n">_get_ctx</span><span class="p">(</span><span class="n">ctx</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">Solver</span><span class="p">(</span><span class="n">Z3_mk_simple_solver</span><span class="p">(</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">()),</span> <span class="n">ctx</span><span class="p">,</span> <span class="n">logFile</span><span class="p">)</span>

<span class="c1">#########################################</span>
<span class="c1">#</span>
<span class="c1"># Fixedpoint</span>
<span class="c1">#</span>
<span class="c1">#########################################</span>


<span class="k">class</span> <span class="nc">Fixedpoint</span><span class="p">(</span><span class="n">Z3PPObject</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Fixedpoint API provides methods for solving with recursive predicates&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fixedpoint</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ctx</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">assert</span> <span class="n">fixedpoint</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">ctx</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span> <span class="o">=</span> <span class="n">_get_ctx</span><span class="p">(</span><span class="n">ctx</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fixedpoint</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">fixedpoint</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fixedpoint</span> <span class="o">=</span> <span class="n">Z3_mk_fixedpoint</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">())</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fixedpoint</span> <span class="o">=</span> <span class="n">fixedpoint</span>
        <span class="n">Z3_fixedpoint_inc_ref</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">fixedpoint</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vars</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">def</span> <span class="nf">__deepcopy__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">memo</span><span class="o">=</span><span class="p">{}):</span>
        <span class="k">return</span> <span class="n">FixedPoint</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fixedpoint</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__del__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">fixedpoint</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">()</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">Z3_fixedpoint_dec_ref</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">Z3_fixedpoint_dec_ref</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">fixedpoint</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">set</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">keys</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Set a configuration option. The method `help()` return a string containing all available options.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">args2params</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">keys</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>
        <span class="n">Z3_fixedpoint_set_params</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">fixedpoint</span><span class="p">,</span> <span class="n">p</span><span class="o">.</span><span class="n">params</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">help</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Display a string describing all available options.&quot;&quot;&quot;</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">Z3_fixedpoint_get_help</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">fixedpoint</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">param_descrs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the parameter description set.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">ParamDescrsRef</span><span class="p">(</span><span class="n">Z3_fixedpoint_get_param_descrs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">fixedpoint</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">assert_exprs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Assert constraints as background axioms for the fixedpoint solver.&quot;&quot;&quot;</span>
        <span class="n">args</span> <span class="o">=</span> <span class="n">_get_args</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">BoolSort</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">args</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">Goal</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">AstVector</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">arg</span><span class="p">:</span>
                    <span class="n">f</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">abstract</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
                    <span class="n">Z3_fixedpoint_assert</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">fixedpoint</span><span class="p">,</span> <span class="n">f</span><span class="o">.</span><span class="n">as_ast</span><span class="p">())</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">arg</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>
                <span class="n">arg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">abstract</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>
                <span class="n">Z3_fixedpoint_assert</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">fixedpoint</span><span class="p">,</span> <span class="n">arg</span><span class="o">.</span><span class="n">as_ast</span><span class="p">())</span>

    <span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Assert constraints as background axioms for the fixedpoint solver. Alias for assert_expr.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">assert_exprs</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__iadd__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fml</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">fml</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">append</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Assert constraints as background axioms for the fixedpoint solver. Alias for assert_expr.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">assert_exprs</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">insert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Assert constraints as background axioms for the fixedpoint solver. Alias for assert_expr.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">assert_exprs</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">add_rule</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">head</span><span class="p">,</span> <span class="n">body</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Assert rules defining recursive predicates to the fixedpoint solver.</span>
<span class="sd">        &gt;&gt;&gt; a = Bool(&#39;a&#39;)</span>
<span class="sd">        &gt;&gt;&gt; b = Bool(&#39;b&#39;)</span>
<span class="sd">        &gt;&gt;&gt; s = Fixedpoint()</span>
<span class="sd">        &gt;&gt;&gt; s.register_relation(a.decl())</span>
<span class="sd">        &gt;&gt;&gt; s.register_relation(b.decl())</span>
<span class="sd">        &gt;&gt;&gt; s.fact(a)</span>
<span class="sd">        &gt;&gt;&gt; s.rule(b, a)</span>
<span class="sd">        &gt;&gt;&gt; s.query(b)</span>
<span class="sd">        sat</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="n">name</span> <span class="o">=</span> <span class="n">to_symbol</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">body</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">head</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">abstract</span><span class="p">(</span><span class="n">head</span><span class="p">)</span>
            <span class="n">Z3_fixedpoint_add_rule</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">fixedpoint</span><span class="p">,</span> <span class="n">head</span><span class="o">.</span><span class="n">as_ast</span><span class="p">(),</span> <span class="n">name</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">body</span> <span class="o">=</span> <span class="n">_get_args</span><span class="p">(</span><span class="n">body</span><span class="p">)</span>
            <span class="n">f</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">abstract</span><span class="p">(</span><span class="n">Implies</span><span class="p">(</span><span class="n">And</span><span class="p">(</span><span class="n">body</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">),</span> <span class="n">head</span><span class="p">))</span>
            <span class="n">Z3_fixedpoint_add_rule</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">fixedpoint</span><span class="p">,</span> <span class="n">f</span><span class="o">.</span><span class="n">as_ast</span><span class="p">(),</span> <span class="n">name</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">rule</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">head</span><span class="p">,</span> <span class="n">body</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Assert rules defining recursive predicates to the fixedpoint solver. Alias for add_rule.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_rule</span><span class="p">(</span><span class="n">head</span><span class="p">,</span> <span class="n">body</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">fact</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">head</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Assert facts defining recursive predicates to the fixedpoint solver. Alias for add_rule.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_rule</span><span class="p">(</span><span class="n">head</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">query</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">query</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Query the fixedpoint engine whether formula is derivable.</span>
<span class="sd">           You can also pass an tuple or list of recursive predicates.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">query</span> <span class="o">=</span> <span class="n">_get_args</span><span class="p">(</span><span class="n">query</span><span class="p">)</span>
        <span class="n">sz</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">query</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">sz</span> <span class="o">&gt;=</span> <span class="mi">1</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">query</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">FuncDeclRef</span><span class="p">):</span>
            <span class="n">_decls</span> <span class="o">=</span> <span class="p">(</span><span class="n">FuncDecl</span> <span class="o">*</span> <span class="n">sz</span><span class="p">)()</span>
            <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">q</span> <span class="ow">in</span> <span class="n">query</span><span class="p">:</span>
                <span class="n">_decls</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="n">ast</span>
                <span class="n">i</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="n">r</span> <span class="o">=</span> <span class="n">Z3_fixedpoint_query_relations</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">fixedpoint</span><span class="p">,</span> <span class="n">sz</span><span class="p">,</span> <span class="n">_decls</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">sz</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">query</span> <span class="o">=</span> <span class="n">query</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">query</span> <span class="o">=</span> <span class="n">And</span><span class="p">(</span><span class="n">query</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>
            <span class="n">query</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">abstract</span><span class="p">(</span><span class="n">query</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
            <span class="n">r</span> <span class="o">=</span> <span class="n">Z3_fixedpoint_query</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">fixedpoint</span><span class="p">,</span> <span class="n">query</span><span class="o">.</span><span class="n">as_ast</span><span class="p">())</span>
        <span class="k">return</span> <span class="n">CheckSatResult</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">query_from_lvl</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lvl</span><span class="p">,</span> <span class="o">*</span><span class="n">query</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Query the fixedpoint engine whether formula is derivable starting at the given query level.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">query</span> <span class="o">=</span> <span class="n">_get_args</span><span class="p">(</span><span class="n">query</span><span class="p">)</span>
        <span class="n">sz</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">query</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">sz</span> <span class="o">&gt;=</span> <span class="mi">1</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">query</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">FuncDecl</span><span class="p">):</span>
            <span class="n">_z3_assert</span><span class="p">(</span><span class="kc">False</span><span class="p">,</span> <span class="s2">&quot;unsupported&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">sz</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">query</span> <span class="o">=</span> <span class="n">query</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">query</span> <span class="o">=</span> <span class="n">And</span><span class="p">(</span><span class="n">query</span><span class="p">)</span>
            <span class="n">query</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">abstract</span><span class="p">(</span><span class="n">query</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
            <span class="n">r</span> <span class="o">=</span> <span class="n">Z3_fixedpoint_query_from_lvl</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">fixedpoint</span><span class="p">,</span> <span class="n">query</span><span class="o">.</span><span class="n">as_ast</span><span class="p">(),</span> <span class="n">lvl</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">CheckSatResult</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">update_rule</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">head</span><span class="p">,</span> <span class="n">body</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;update rule&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="n">name</span> <span class="o">=</span> <span class="n">to_symbol</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>
        <span class="n">body</span> <span class="o">=</span> <span class="n">_get_args</span><span class="p">(</span><span class="n">body</span><span class="p">)</span>
        <span class="n">f</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">abstract</span><span class="p">(</span><span class="n">Implies</span><span class="p">(</span><span class="n">And</span><span class="p">(</span><span class="n">body</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">),</span> <span class="n">head</span><span class="p">))</span>
        <span class="n">Z3_fixedpoint_update_rule</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">fixedpoint</span><span class="p">,</span> <span class="n">f</span><span class="o">.</span><span class="n">as_ast</span><span class="p">(),</span> <span class="n">name</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_answer</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Retrieve answer from last query call.&quot;&quot;&quot;</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">Z3_fixedpoint_get_answer</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">fixedpoint</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">_to_expr_ref</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_ground_sat_answer</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Retrieve a ground cex from last query call.&quot;&quot;&quot;</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">Z3_fixedpoint_get_ground_sat_answer</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">fixedpoint</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">_to_expr_ref</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_rules_along_trace</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;retrieve rules along the counterexample trace&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">AstVector</span><span class="p">(</span><span class="n">Z3_fixedpoint_get_rules_along_trace</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">fixedpoint</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_rule_names_along_trace</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;retrieve rule names along the counterexample trace&quot;&quot;&quot;</span>
        <span class="c1"># this is a hack as I don&#39;t know how to return a list of symbols from C++;</span>
        <span class="c1"># obtain names as a single string separated by semicolons</span>
        <span class="n">names</span> <span class="o">=</span> <span class="n">_symbol2py</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">,</span> <span class="n">Z3_fixedpoint_get_rule_names_along_trace</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">fixedpoint</span><span class="p">))</span>
        <span class="c1"># split into individual names</span>
        <span class="k">return</span> <span class="n">names</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;;&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_num_levels</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">predicate</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Retrieve number of levels used for predicate in PDR engine&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Z3_fixedpoint_get_num_levels</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">fixedpoint</span><span class="p">,</span> <span class="n">predicate</span><span class="o">.</span><span class="n">ast</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_cover_delta</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">level</span><span class="p">,</span> <span class="n">predicate</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Retrieve properties known about predicate for the level&#39;th unfolding.</span>
<span class="sd">        -1 is treated as the limit (infinity)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">Z3_fixedpoint_get_cover_delta</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">fixedpoint</span><span class="p">,</span> <span class="n">level</span><span class="p">,</span> <span class="n">predicate</span><span class="o">.</span><span class="n">ast</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">_to_expr_ref</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">add_cover</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">level</span><span class="p">,</span> <span class="n">predicate</span><span class="p">,</span> <span class="nb">property</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Add property to predicate for the level&#39;th unfolding.</span>
<span class="sd">        -1 is treated as infinity (infinity)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">Z3_fixedpoint_add_cover</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">fixedpoint</span><span class="p">,</span> <span class="n">level</span><span class="p">,</span> <span class="n">predicate</span><span class="o">.</span><span class="n">ast</span><span class="p">,</span> <span class="nb">property</span><span class="o">.</span><span class="n">ast</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">register_relation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">relations</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Register relation as recursive&quot;&quot;&quot;</span>
        <span class="n">relations</span> <span class="o">=</span> <span class="n">_get_args</span><span class="p">(</span><span class="n">relations</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">relations</span><span class="p">:</span>
            <span class="n">Z3_fixedpoint_register_relation</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">fixedpoint</span><span class="p">,</span> <span class="n">f</span><span class="o">.</span><span class="n">ast</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">set_predicate_representation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">representations</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Control how relation is represented&quot;&quot;&quot;</span>
        <span class="n">representations</span> <span class="o">=</span> <span class="n">_get_args</span><span class="p">(</span><span class="n">representations</span><span class="p">)</span>
        <span class="n">representations</span> <span class="o">=</span> <span class="p">[</span><span class="n">to_symbol</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">representations</span><span class="p">]</span>
        <span class="n">sz</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">representations</span><span class="p">)</span>
        <span class="n">args</span> <span class="o">=</span> <span class="p">(</span><span class="n">Symbol</span> <span class="o">*</span> <span class="n">sz</span><span class="p">)()</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">sz</span><span class="p">):</span>
            <span class="n">args</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">representations</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">Z3_fixedpoint_set_predicate_representation</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">fixedpoint</span><span class="p">,</span> <span class="n">f</span><span class="o">.</span><span class="n">ast</span><span class="p">,</span> <span class="n">sz</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">parse_string</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Parse rules and queries from a string&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">AstVector</span><span class="p">(</span><span class="n">Z3_fixedpoint_from_string</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">fixedpoint</span><span class="p">,</span> <span class="n">s</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">parse_file</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">f</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Parse rules and queries from a file&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">AstVector</span><span class="p">(</span><span class="n">Z3_fixedpoint_from_file</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">fixedpoint</span><span class="p">,</span> <span class="n">f</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_rules</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;retrieve rules that have been added to fixedpoint context&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">AstVector</span><span class="p">(</span><span class="n">Z3_fixedpoint_get_rules</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">fixedpoint</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_assertions</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;retrieve assertions that have been added to fixedpoint context&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">AstVector</span><span class="p">(</span><span class="n">Z3_fixedpoint_get_assertions</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">fixedpoint</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a formatted string with all added rules and constraints.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">sexpr</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">sexpr</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a formatted string (in Lisp-like format) with all added constraints.</span>
<span class="sd">        We say the string is in s-expression format.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Z3_fixedpoint_to_string</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">fixedpoint</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="n">Ast</span> <span class="o">*</span> <span class="mi">0</span><span class="p">)())</span>

    <span class="k">def</span> <span class="nf">to_string</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">queries</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a formatted string (in Lisp-like format) with all added constraints.</span>
<span class="sd">           We say the string is in s-expression format.</span>
<span class="sd">           Include also queries.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">args</span><span class="p">,</span> <span class="nb">len</span> <span class="o">=</span> <span class="n">_to_ast_array</span><span class="p">(</span><span class="n">queries</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Z3_fixedpoint_to_string</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">fixedpoint</span><span class="p">,</span> <span class="nb">len</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">statistics</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return statistics for the last `query()`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Statistics</span><span class="p">(</span><span class="n">Z3_fixedpoint_get_statistics</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">fixedpoint</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">reason_unknown</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a string describing why the last `query()` returned `unknown`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Z3_fixedpoint_get_reason_unknown</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">fixedpoint</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">declare_var</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="nb">vars</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Add variable or several variables.</span>
<span class="sd">        The added variable or variables will be bound in the rules</span>
<span class="sd">        and queries</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">vars</span> <span class="o">=</span> <span class="n">_get_args</span><span class="p">(</span><span class="nb">vars</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">vars</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">vars</span> <span class="o">+=</span> <span class="p">[</span><span class="n">v</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">abstract</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fml</span><span class="p">,</span> <span class="n">is_forall</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">vars</span> <span class="o">==</span> <span class="p">[]:</span>
            <span class="k">return</span> <span class="n">fml</span>
        <span class="k">if</span> <span class="n">is_forall</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">ForAll</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vars</span><span class="p">,</span> <span class="n">fml</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Exists</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vars</span><span class="p">,</span> <span class="n">fml</span><span class="p">)</span>


<span class="c1">#########################################</span>
<span class="c1">#</span>
<span class="c1"># Finite domains</span>
<span class="c1">#</span>
<span class="c1">#########################################</span>

<span class="k">class</span> <span class="nc">FiniteDomainSortRef</span><span class="p">(</span><span class="n">SortRef</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Finite domain sort.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">size</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the size of the finite domain sort&quot;&quot;&quot;</span>
        <span class="n">r</span> <span class="o">=</span> <span class="p">(</span><span class="n">ctypes</span><span class="o">.</span><span class="n">c_ulonglong</span> <span class="o">*</span> <span class="mi">1</span><span class="p">)()</span>
        <span class="k">if</span> <span class="n">Z3_get_finite_domain_sort_size</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx_ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">ast</span><span class="p">,</span> <span class="n">r</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">Z3Exception</span><span class="p">(</span><span class="s2">&quot;Failed to retrieve finite domain sort size&quot;</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">FiniteDomainSort</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">sz</span><span class="p">,</span> <span class="n">ctx</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Create a named finite domain sort of a given size sz&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">Symbol</span><span class="p">):</span>
        <span class="n">name</span> <span class="o">=</span> <span class="n">to_symbol</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
    <span class="n">ctx</span> <span class="o">=</span> <span class="n">_get_ctx</span><span class="p">(</span><span class="n">ctx</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">FiniteDomainSortRef</span><span class="p">(</span><span class="n">Z3_mk_finite_domain_sort</span><span class="p">(</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="n">name</span><span class="p">,</span> <span class="n">sz</span><span class="p">),</span> <span class="n">ctx</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">is_finite_domain_sort</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return True if `s` is a Z3 finite-domain sort.</span>

<span class="sd">    &gt;&gt;&gt; is_finite_domain_sort(FiniteDomainSort(&#39;S&#39;, 100))</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; is_finite_domain_sort(IntSort())</span>
<span class="sd">    False</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">FiniteDomainSortRef</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">FiniteDomainRef</span><span class="p">(</span><span class="n">ExprRef</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Finite-domain expressions.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">sort</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the sort of the finite-domain expression `self`.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">FiniteDomainSortRef</span><span class="p">(</span><span class="n">Z3_get_sort</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx_ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_ast</span><span class="p">()),</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">as_string</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a Z3 floating point expression as a Python string.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Z3_ast_to_string</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx_ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_ast</span><span class="p">())</span>


<span class="k">def</span> <span class="nf">is_finite_domain</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return `True` if `a` is a Z3 finite-domain expression.</span>

<span class="sd">    &gt;&gt;&gt; s = FiniteDomainSort(&#39;S&#39;, 100)</span>
<span class="sd">    &gt;&gt;&gt; b = Const(&#39;b&#39;, s)</span>
<span class="sd">    &gt;&gt;&gt; is_finite_domain(b)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; is_finite_domain(Int(&#39;x&#39;))</span>
<span class="sd">    False</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">FiniteDomainRef</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">FiniteDomainNumRef</span><span class="p">(</span><span class="n">FiniteDomainRef</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Integer values.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">as_long</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a Z3 finite-domain numeral as a Python long (bignum) numeral.</span>

<span class="sd">        &gt;&gt;&gt; s = FiniteDomainSort(&#39;S&#39;, 100)</span>
<span class="sd">        &gt;&gt;&gt; v = FiniteDomainVal(3, s)</span>
<span class="sd">        &gt;&gt;&gt; v</span>
<span class="sd">        3</span>
<span class="sd">        &gt;&gt;&gt; v.as_long() + 1</span>
<span class="sd">        4</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">as_string</span><span class="p">())</span>

    <span class="k">def</span> <span class="nf">as_string</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a Z3 finite-domain numeral as a Python string.</span>

<span class="sd">        &gt;&gt;&gt; s = FiniteDomainSort(&#39;S&#39;, 100)</span>
<span class="sd">        &gt;&gt;&gt; v = FiniteDomainVal(42, s)</span>
<span class="sd">        &gt;&gt;&gt; v.as_string()</span>
<span class="sd">        &#39;42&#39;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Z3_get_numeral_string</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx_ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_ast</span><span class="p">())</span>


<span class="k">def</span> <span class="nf">FiniteDomainVal</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">sort</span><span class="p">,</span> <span class="n">ctx</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return a Z3 finite-domain value. If `ctx=None`, then the global context is used.</span>

<span class="sd">    &gt;&gt;&gt; s = FiniteDomainSort(&#39;S&#39;, 256)</span>
<span class="sd">    &gt;&gt;&gt; FiniteDomainVal(255, s)</span>
<span class="sd">    255</span>
<span class="sd">    &gt;&gt;&gt; FiniteDomainVal(&#39;100&#39;, s)</span>
<span class="sd">    100</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">z3_debug</span><span class="p">():</span>
        <span class="n">_z3_assert</span><span class="p">(</span><span class="n">is_finite_domain_sort</span><span class="p">(</span><span class="n">sort</span><span class="p">),</span> <span class="s2">&quot;Expected finite-domain sort&quot;</span><span class="p">)</span>
    <span class="n">ctx</span> <span class="o">=</span> <span class="n">sort</span><span class="o">.</span><span class="n">ctx</span>
    <span class="k">return</span> <span class="n">FiniteDomainNumRef</span><span class="p">(</span><span class="n">Z3_mk_numeral</span><span class="p">(</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="n">_to_int_str</span><span class="p">(</span><span class="n">val</span><span class="p">),</span> <span class="n">sort</span><span class="o">.</span><span class="n">ast</span><span class="p">),</span> <span class="n">ctx</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">is_finite_domain_value</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return `True` if `a` is a Z3 finite-domain value.</span>

<span class="sd">    &gt;&gt;&gt; s = FiniteDomainSort(&#39;S&#39;, 100)</span>
<span class="sd">    &gt;&gt;&gt; b = Const(&#39;b&#39;, s)</span>
<span class="sd">    &gt;&gt;&gt; is_finite_domain_value(b)</span>
<span class="sd">    False</span>
<span class="sd">    &gt;&gt;&gt; b = FiniteDomainVal(10, s)</span>
<span class="sd">    &gt;&gt;&gt; b</span>
<span class="sd">    10</span>
<span class="sd">    &gt;&gt;&gt; is_finite_domain_value(b)</span>
<span class="sd">    True</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">is_finite_domain</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="ow">and</span> <span class="n">_is_numeral</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">ctx</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">as_ast</span><span class="p">())</span>


<span class="c1">#########################################</span>
<span class="c1">#</span>
<span class="c1"># Optimize</span>
<span class="c1">#</span>
<span class="c1">#########################################</span>

<span class="k">class</span> <span class="nc">OptimizeObjective</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">opt</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">is_max</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_opt</span> <span class="o">=</span> <span class="n">opt</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_value</span> <span class="o">=</span> <span class="n">value</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_is_max</span> <span class="o">=</span> <span class="n">is_max</span>

    <span class="k">def</span> <span class="nf">lower</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">opt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_opt</span>
        <span class="k">return</span> <span class="n">_to_expr_ref</span><span class="p">(</span><span class="n">Z3_optimize_get_lower</span><span class="p">(</span><span class="n">opt</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="n">opt</span><span class="o">.</span><span class="n">optimize</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_value</span><span class="p">),</span> <span class="n">opt</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">upper</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">opt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_opt</span>
        <span class="k">return</span> <span class="n">_to_expr_ref</span><span class="p">(</span><span class="n">Z3_optimize_get_upper</span><span class="p">(</span><span class="n">opt</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="n">opt</span><span class="o">.</span><span class="n">optimize</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_value</span><span class="p">),</span> <span class="n">opt</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">lower_values</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">opt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_opt</span>
        <span class="k">return</span> <span class="n">AstVector</span><span class="p">(</span><span class="n">Z3_optimize_get_lower_as_vector</span><span class="p">(</span><span class="n">opt</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="n">opt</span><span class="o">.</span><span class="n">optimize</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_value</span><span class="p">),</span> <span class="n">opt</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">upper_values</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">opt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_opt</span>
        <span class="k">return</span> <span class="n">AstVector</span><span class="p">(</span><span class="n">Z3_optimize_get_upper_as_vector</span><span class="p">(</span><span class="n">opt</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="n">opt</span><span class="o">.</span><span class="n">optimize</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_value</span><span class="p">),</span> <span class="n">opt</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">value</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_max</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2">:</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_value</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_max</span><span class="p">)</span>


<span class="n">_on_models</span> <span class="o">=</span> <span class="p">{}</span>


<span class="k">def</span> <span class="nf">_global_on_model</span><span class="p">(</span><span class="n">ctx</span><span class="p">):</span>
    <span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="n">mdl</span><span class="p">)</span> <span class="o">=</span> <span class="n">_on_models</span><span class="p">[</span><span class="n">ctx</span><span class="p">]</span>
    <span class="n">fn</span><span class="p">(</span><span class="n">mdl</span><span class="p">)</span>


<span class="n">_on_model_eh</span> <span class="o">=</span> <span class="n">on_model_eh_type</span><span class="p">(</span><span class="n">_global_on_model</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">Optimize</span><span class="p">(</span><span class="n">Z3PPObject</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Optimize API provides methods for solving using objective functions and weighted soft constraints&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ctx</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span> <span class="o">=</span> <span class="n">_get_ctx</span><span class="p">(</span><span class="n">ctx</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">optimize</span> <span class="o">=</span> <span class="n">Z3_mk_optimize</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">())</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_on_models_id</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">Z3_optimize_inc_ref</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">optimize</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__deepcopy__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">memo</span><span class="o">=</span><span class="p">{}):</span>
        <span class="k">return</span> <span class="n">Optimize</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">optimize</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__del__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">optimize</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">()</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">Z3_optimize_dec_ref</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">Z3_optimize_dec_ref</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">optimize</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_on_models_id</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">del</span> <span class="n">_on_models</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_on_models_id</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">set</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">keys</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Set a configuration option.</span>
<span class="sd">        The method `help()` return a string containing all available options.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">args2params</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">keys</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>
        <span class="n">Z3_optimize_set_params</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">optimize</span><span class="p">,</span> <span class="n">p</span><span class="o">.</span><span class="n">params</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">help</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Display a string describing all available options.&quot;&quot;&quot;</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">Z3_optimize_get_help</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">optimize</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">param_descrs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the parameter description set.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">ParamDescrsRef</span><span class="p">(</span><span class="n">Z3_optimize_get_param_descrs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">optimize</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">assert_exprs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Assert constraints as background axioms for the optimize solver.&quot;&quot;&quot;</span>
        <span class="n">args</span> <span class="o">=</span> <span class="n">_get_args</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">BoolSort</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">args</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">Goal</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">AstVector</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">arg</span><span class="p">:</span>
                    <span class="n">Z3_optimize_assert</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">optimize</span><span class="p">,</span> <span class="n">f</span><span class="o">.</span><span class="n">as_ast</span><span class="p">())</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">arg</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>
                <span class="n">Z3_optimize_assert</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">optimize</span><span class="p">,</span> <span class="n">arg</span><span class="o">.</span><span class="n">as_ast</span><span class="p">())</span>

    <span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Assert constraints as background axioms for the optimize solver. Alias for assert_expr.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">assert_exprs</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__iadd__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fml</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">fml</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">assert_and_track</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">p</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Assert constraint `a` and track it in the unsat core using the Boolean constant `p`.</span>

<span class="sd">        If `p` is a string, it will be automatically converted into a Boolean constant.</span>

<span class="sd">        &gt;&gt;&gt; x = Int(&#39;x&#39;)</span>
<span class="sd">        &gt;&gt;&gt; p3 = Bool(&#39;p3&#39;)</span>
<span class="sd">        &gt;&gt;&gt; s = Optimize()</span>
<span class="sd">        &gt;&gt;&gt; s.assert_and_track(x &gt; 0,  &#39;p1&#39;)</span>
<span class="sd">        &gt;&gt;&gt; s.assert_and_track(x != 1, &#39;p2&#39;)</span>
<span class="sd">        &gt;&gt;&gt; s.assert_and_track(x &lt; 0,  p3)</span>
<span class="sd">        &gt;&gt;&gt; print(s.check())</span>
<span class="sd">        unsat</span>
<span class="sd">        &gt;&gt;&gt; c = s.unsat_core()</span>
<span class="sd">        &gt;&gt;&gt; len(c)</span>
<span class="sd">        2</span>
<span class="sd">        &gt;&gt;&gt; Bool(&#39;p1&#39;) in c</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; Bool(&#39;p2&#39;) in c</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; p3 in c</span>
<span class="sd">        True</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">Bool</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>
        <span class="n">_z3_assert</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">BoolRef</span><span class="p">),</span> <span class="s2">&quot;Boolean expression expected&quot;</span><span class="p">)</span>
        <span class="n">_z3_assert</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">BoolRef</span><span class="p">)</span> <span class="ow">and</span> <span class="n">is_const</span><span class="p">(</span><span class="n">p</span><span class="p">),</span> <span class="s2">&quot;Boolean expression expected&quot;</span><span class="p">)</span>
        <span class="n">Z3_optimize_assert_and_track</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">optimize</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">as_ast</span><span class="p">(),</span> <span class="n">p</span><span class="o">.</span><span class="n">as_ast</span><span class="p">())</span>

    <span class="k">def</span> <span class="nf">add_soft</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="s2">&quot;1&quot;</span><span class="p">,</span> <span class="nb">id</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Add soft constraint with optional weight and optional identifier.</span>
<span class="sd">           If no weight is supplied, then the penalty for violating the soft constraint</span>
<span class="sd">           is 1.</span>
<span class="sd">           Soft constraints are grouped by identifiers. Soft constraints that are</span>
<span class="sd">           added without identifiers are grouped by default.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">_is_int</span><span class="p">(</span><span class="n">weight</span><span class="p">):</span>
            <span class="n">weight</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">weight</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">weight</span><span class="p">,</span> <span class="nb">float</span><span class="p">):</span>
            <span class="n">weight</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">%f</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">weight</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">weight</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">Z3Exception</span><span class="p">(</span><span class="s2">&quot;weight should be a string or an integer&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">id</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="nb">id</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="nb">id</span> <span class="o">=</span> <span class="n">to_symbol</span><span class="p">(</span><span class="nb">id</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">asoft</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
            <span class="n">v</span> <span class="o">=</span> <span class="n">Z3_optimize_assert_soft</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">optimize</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">as_ast</span><span class="p">(),</span> <span class="n">weight</span><span class="p">,</span> <span class="nb">id</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">OptimizeObjective</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">sys</span><span class="o">.</span><span class="n">version_info</span><span class="o">.</span><span class="n">major</span> <span class="o">&gt;=</span> <span class="mi">3</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">):</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">asoft</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">arg</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">asoft</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">maximize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arg</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Add objective function to maximize.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">OptimizeObjective</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">Z3_optimize_maximize</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">optimize</span><span class="p">,</span> <span class="n">arg</span><span class="o">.</span><span class="n">as_ast</span><span class="p">()),</span>
            <span class="n">is_max</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">minimize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arg</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Add objective function to minimize.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">OptimizeObjective</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">Z3_optimize_minimize</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">optimize</span><span class="p">,</span> <span class="n">arg</span><span class="o">.</span><span class="n">as_ast</span><span class="p">()),</span>
            <span class="n">is_max</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">push</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;create a backtracking point for added rules, facts and assertions&quot;&quot;&quot;</span>
        <span class="n">Z3_optimize_push</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">optimize</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">pop</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;restore to previously created backtracking point&quot;&quot;&quot;</span>
        <span class="n">Z3_optimize_pop</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">optimize</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">check</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">assumptions</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Check consistency and produce optimal values.&quot;&quot;&quot;</span>
        <span class="n">assumptions</span> <span class="o">=</span> <span class="n">_get_args</span><span class="p">(</span><span class="n">assumptions</span><span class="p">)</span>
        <span class="n">num</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">assumptions</span><span class="p">)</span>
        <span class="n">_assumptions</span> <span class="o">=</span> <span class="p">(</span><span class="n">Ast</span> <span class="o">*</span> <span class="n">num</span><span class="p">)()</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num</span><span class="p">):</span>
            <span class="n">_assumptions</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">assumptions</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">as_ast</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">CheckSatResult</span><span class="p">(</span><span class="n">Z3_optimize_check</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">optimize</span><span class="p">,</span> <span class="n">num</span><span class="p">,</span> <span class="n">_assumptions</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">reason_unknown</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a string that describes why the last `check()` returned `unknown`.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Z3_optimize_get_reason_unknown</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">optimize</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">model</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a model for the last check().&quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">ModelRef</span><span class="p">(</span><span class="n">Z3_optimize_get_model</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">optimize</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">Z3Exception</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">Z3Exception</span><span class="p">(</span><span class="s2">&quot;model is not available&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">unsat_core</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">AstVector</span><span class="p">(</span><span class="n">Z3_optimize_get_unsat_core</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">optimize</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">lower</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">OptimizeObjective</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">Z3Exception</span><span class="p">(</span><span class="s2">&quot;Expecting objective handle returned by maximize/minimize&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">obj</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">upper</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">OptimizeObjective</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">Z3Exception</span><span class="p">(</span><span class="s2">&quot;Expecting objective handle returned by maximize/minimize&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">obj</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">lower_values</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">OptimizeObjective</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">Z3Exception</span><span class="p">(</span><span class="s2">&quot;Expecting objective handle returned by maximize/minimize&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">obj</span><span class="o">.</span><span class="n">lower_values</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">upper_values</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">OptimizeObjective</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">Z3Exception</span><span class="p">(</span><span class="s2">&quot;Expecting objective handle returned by maximize/minimize&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">obj</span><span class="o">.</span><span class="n">upper_values</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">from_file</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Parse assertions and objectives from a file&quot;&quot;&quot;</span>
        <span class="n">Z3_optimize_from_file</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">optimize</span><span class="p">,</span> <span class="n">filename</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">from_string</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Parse assertions and objectives from a string&quot;&quot;&quot;</span>
        <span class="n">Z3_optimize_from_string</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">optimize</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">assertions</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return an AST vector containing all added constraints.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">AstVector</span><span class="p">(</span><span class="n">Z3_optimize_get_assertions</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">optimize</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">objectives</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;returns set of objective functions&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">AstVector</span><span class="p">(</span><span class="n">Z3_optimize_get_objectives</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">optimize</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a formatted string with all added rules and constraints.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">sexpr</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">sexpr</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a formatted string (in Lisp-like format) with all added constraints.</span>
<span class="sd">        We say the string is in s-expression format.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Z3_optimize_to_string</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">optimize</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">statistics</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return statistics for the last check`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Statistics</span><span class="p">(</span><span class="n">Z3_optimize_get_statistics</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">optimize</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">set_on_model</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">on_model</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Register a callback that is invoked with every incremental improvement to</span>
<span class="sd">        objective values. The callback takes a model as argument.</span>
<span class="sd">        The life-time of the model is limited to the callback so the</span>
<span class="sd">        model has to be (deep) copied if it is to be used after the callback</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">id</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">_on_models</span><span class="p">)</span> <span class="o">+</span> <span class="mi">41</span>
        <span class="n">mdl</span> <span class="o">=</span> <span class="n">Model</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>
        <span class="n">_on_models</span><span class="p">[</span><span class="nb">id</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">on_model</span><span class="p">,</span> <span class="n">mdl</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_on_models_id</span> <span class="o">=</span> <span class="nb">id</span>
        <span class="n">Z3_optimize_register_model_eh</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">optimize</span><span class="p">,</span> <span class="n">mdl</span><span class="o">.</span><span class="n">model</span><span class="p">,</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_void_p</span><span class="p">(</span><span class="nb">id</span><span class="p">),</span> <span class="n">_on_model_eh</span><span class="p">,</span>
        <span class="p">)</span>


<span class="c1">#########################################</span>
<span class="c1">#</span>
<span class="c1"># ApplyResult</span>
<span class="c1">#</span>
<span class="c1">#########################################</span>
<span class="k">class</span> <span class="nc">ApplyResult</span><span class="p">(</span><span class="n">Z3PPObject</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;An ApplyResult object contains the subgoals produced by a tactic when applied to a goal.</span>
<span class="sd">    It also contains model and proof converters.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">result</span><span class="p">,</span> <span class="n">ctx</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">result</span> <span class="o">=</span> <span class="n">result</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span> <span class="o">=</span> <span class="n">ctx</span>
        <span class="n">Z3_apply_result_inc_ref</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">result</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__deepcopy__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">memo</span><span class="o">=</span><span class="p">{}):</span>
        <span class="k">return</span> <span class="n">ApplyResult</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">result</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__del__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">()</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">Z3_apply_result_dec_ref</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">Z3_apply_result_dec_ref</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">result</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the number of subgoals in `self`.</span>

<span class="sd">        &gt;&gt;&gt; a, b = Ints(&#39;a b&#39;)</span>
<span class="sd">        &gt;&gt;&gt; g = Goal()</span>
<span class="sd">        &gt;&gt;&gt; g.add(Or(a == 0, a == 1), Or(b == 0, b == 1), a &gt; b)</span>
<span class="sd">        &gt;&gt;&gt; t = Tactic(&#39;split-clause&#39;)</span>
<span class="sd">        &gt;&gt;&gt; r = t(g)</span>
<span class="sd">        &gt;&gt;&gt; len(r)</span>
<span class="sd">        2</span>
<span class="sd">        &gt;&gt;&gt; t = Then(Tactic(&#39;split-clause&#39;), Tactic(&#39;split-clause&#39;))</span>
<span class="sd">        &gt;&gt;&gt; len(t(g))</span>
<span class="sd">        4</span>
<span class="sd">        &gt;&gt;&gt; t = Then(Tactic(&#39;split-clause&#39;), Tactic(&#39;split-clause&#39;), Tactic(&#39;propagate-values&#39;))</span>
<span class="sd">        &gt;&gt;&gt; len(t(g))</span>
<span class="sd">        1</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">Z3_apply_result_get_num_subgoals</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">result</span><span class="p">))</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return one of the subgoals stored in ApplyResult object `self`.</span>

<span class="sd">        &gt;&gt;&gt; a, b = Ints(&#39;a b&#39;)</span>
<span class="sd">        &gt;&gt;&gt; g = Goal()</span>
<span class="sd">        &gt;&gt;&gt; g.add(Or(a == 0, a == 1), Or(b == 0, b == 1), a &gt; b)</span>
<span class="sd">        &gt;&gt;&gt; t = Tactic(&#39;split-clause&#39;)</span>
<span class="sd">        &gt;&gt;&gt; r = t(g)</span>
<span class="sd">        &gt;&gt;&gt; r[0]</span>
<span class="sd">        [a == 0, Or(b == 0, b == 1), a &gt; b]</span>
<span class="sd">        &gt;&gt;&gt; r[1]</span>
<span class="sd">        [a == 1, Or(b == 0, b == 1), a &gt; b]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">idx</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">IndexError</span>
        <span class="k">return</span> <span class="n">Goal</span><span class="p">(</span><span class="n">goal</span><span class="o">=</span><span class="n">Z3_apply_result_get_subgoal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">result</span><span class="p">,</span> <span class="n">idx</span><span class="p">),</span> <span class="n">ctx</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">obj_to_string</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">sexpr</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a textual representation of the s-expression representing the set of subgoals in `self`.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Z3_apply_result_to_string</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">result</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">as_expr</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a Z3 expression consisting of all subgoals.</span>

<span class="sd">        &gt;&gt;&gt; x = Int(&#39;x&#39;)</span>
<span class="sd">        &gt;&gt;&gt; g = Goal()</span>
<span class="sd">        &gt;&gt;&gt; g.add(x &gt; 1)</span>
<span class="sd">        &gt;&gt;&gt; g.add(Or(x == 2, x == 3))</span>
<span class="sd">        &gt;&gt;&gt; r = Tactic(&#39;simplify&#39;)(g)</span>
<span class="sd">        &gt;&gt;&gt; r</span>
<span class="sd">        [[Not(x &lt;= 1), Or(x == 2, x == 3)]]</span>
<span class="sd">        &gt;&gt;&gt; r.as_expr()</span>
<span class="sd">        And(Not(x &lt;= 1), Or(x == 2, x == 3))</span>
<span class="sd">        &gt;&gt;&gt; r = Tactic(&#39;split-clause&#39;)(g)</span>
<span class="sd">        &gt;&gt;&gt; r</span>
<span class="sd">        [[x &gt; 1, x == 2], [x &gt; 1, x == 3]]</span>
<span class="sd">        &gt;&gt;&gt; r.as_expr()</span>
<span class="sd">        Or(And(x &gt; 1, x == 2), And(x &gt; 1, x == 3))</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">sz</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">sz</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">BoolVal</span><span class="p">(</span><span class="kc">False</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">sz</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">as_expr</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Or</span><span class="p">([</span><span class="bp">self</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">as_expr</span><span class="p">()</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">))])</span>

<span class="c1">#########################################</span>
<span class="c1">#</span>
<span class="c1"># Simplifiers</span>
<span class="c1">#</span>
<span class="c1">#########################################</span>

<span class="k">class</span> <span class="nc">Simplifier</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Simplifiers act as pre-processing utilities for solvers.</span>
<span class="sd">    Build a custom simplifier and add it to a solver&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">simplifier</span><span class="p">,</span> <span class="n">ctx</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span> <span class="o">=</span> <span class="n">_get_ctx</span><span class="p">(</span><span class="n">ctx</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">simplifier</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">simplifier</span><span class="p">,</span> <span class="n">SimplifierObj</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">simplifier</span> <span class="o">=</span> <span class="n">simplifier</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">simplifier</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">simps</span> <span class="o">=</span> <span class="p">[</span><span class="n">Simplifier</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">ctx</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">simplifier</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">simplifier</span> <span class="o">=</span> <span class="n">simps</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">simplifier</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">simps</span><span class="p">)):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">simplifier</span> <span class="o">=</span> <span class="n">Z3_simplifier_and_then</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">simplifier</span><span class="p">,</span> <span class="n">simps</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">simplifier</span><span class="p">)</span>
            <span class="n">Z3_simplifier_inc_ref</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">simplifier</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">z3_debug</span><span class="p">():</span>
                <span class="n">_z3_assert</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">simplifier</span><span class="p">,</span> <span class="nb">str</span><span class="p">),</span> <span class="s2">&quot;simplifier name expected&quot;</span><span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">simplifier</span> <span class="o">=</span> <span class="n">Z3_mk_simplifier</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="nb">str</span><span class="p">(</span><span class="n">simplifier</span><span class="p">))</span>
            <span class="k">except</span> <span class="n">Z3Exception</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">Z3Exception</span><span class="p">(</span><span class="s2">&quot;unknown simplifier &#39;</span><span class="si">%s</span><span class="s2">&#39;&quot;</span> <span class="o">%</span> <span class="n">simplifier</span><span class="p">)</span>
        <span class="n">Z3_simplifier_inc_ref</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">simplifier</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__deepcopy__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">memo</span><span class="o">=</span><span class="p">{}):</span>
        <span class="k">return</span> <span class="n">Simplifier</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">simplifier</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__del__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">simplifier</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">()</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">Z3_simplifier_dec_ref</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">Z3_simplifier_dec_ref</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">simplifier</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">using_params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">keys</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a simplifier that uses the given configuration options&quot;&quot;&quot;</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">args2params</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">keys</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Simplifier</span><span class="p">(</span><span class="n">Z3_simplifier_using_params</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">simplifier</span><span class="p">,</span> <span class="n">p</span><span class="o">.</span><span class="n">params</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">solver</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a solver that applies the simplification pre-processing specified by the simplifier&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Solver</span><span class="p">(</span><span class="n">Z3_solver_add_simplifier</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="n">solver</span><span class="o">.</span><span class="n">solver</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">simplifier</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">help</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Display a string containing a description of the available options for the `self` simplifier.&quot;&quot;&quot;</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">Z3_simplifier_get_help</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">simplifier</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">param_descrs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the parameter description set.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">ParamDescrsRef</span><span class="p">(</span><span class="n">Z3_simplifier_get_param_descrs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">simplifier</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>
        
    
<span class="c1">#########################################</span>
<span class="c1">#</span>
<span class="c1"># Tactics</span>
<span class="c1">#</span>
<span class="c1">#########################################</span>


<span class="k">class</span> <span class="nc">Tactic</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Tactics transform, solver and/or simplify sets of constraints (Goal).</span>
<span class="sd">    A Tactic can be converted into a Solver using the method solver().</span>

<span class="sd">    Several combinators are available for creating new tactics using the built-in ones:</span>
<span class="sd">    Then(), OrElse(), FailIf(), Repeat(), When(), Cond().</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tactic</span><span class="p">,</span> <span class="n">ctx</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span> <span class="o">=</span> <span class="n">_get_ctx</span><span class="p">(</span><span class="n">ctx</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tactic</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tactic</span><span class="p">,</span> <span class="n">TacticObj</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tactic</span> <span class="o">=</span> <span class="n">tactic</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">z3_debug</span><span class="p">():</span>
                <span class="n">_z3_assert</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">tactic</span><span class="p">,</span> <span class="nb">str</span><span class="p">),</span> <span class="s2">&quot;tactic name expected&quot;</span><span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">tactic</span> <span class="o">=</span> <span class="n">Z3_mk_tactic</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="nb">str</span><span class="p">(</span><span class="n">tactic</span><span class="p">))</span>
            <span class="k">except</span> <span class="n">Z3Exception</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">Z3Exception</span><span class="p">(</span><span class="s2">&quot;unknown tactic &#39;</span><span class="si">%s</span><span class="s2">&#39;&quot;</span> <span class="o">%</span> <span class="n">tactic</span><span class="p">)</span>
        <span class="n">Z3_tactic_inc_ref</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">tactic</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__deepcopy__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">memo</span><span class="o">=</span><span class="p">{}):</span>
        <span class="k">return</span> <span class="n">Tactic</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tactic</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__del__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">tactic</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">()</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">Z3_tactic_dec_ref</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">Z3_tactic_dec_ref</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">tactic</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">solver</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">logFile</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create a solver using the tactic `self`.</span>

<span class="sd">        The solver supports the methods `push()` and `pop()`, but it</span>
<span class="sd">        will always solve each `check()` from scratch.</span>

<span class="sd">        &gt;&gt;&gt; t = Then(&#39;simplify&#39;, &#39;nlsat&#39;)</span>
<span class="sd">        &gt;&gt;&gt; s = t.solver()</span>
<span class="sd">        &gt;&gt;&gt; x = Real(&#39;x&#39;)</span>
<span class="sd">        &gt;&gt;&gt; s.add(x**2 == 2, x &gt; 0)</span>
<span class="sd">        &gt;&gt;&gt; s.check()</span>
<span class="sd">        sat</span>
<span class="sd">        &gt;&gt;&gt; s.model()</span>
<span class="sd">        [x = 1.4142135623?]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Solver</span><span class="p">(</span><span class="n">Z3_mk_solver_from_tactic</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">tactic</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">,</span> <span class="n">logFile</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">apply</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">goal</span><span class="p">,</span> <span class="o">*</span><span class="n">arguments</span><span class="p">,</span> <span class="o">**</span><span class="n">keywords</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Apply tactic `self` to the given goal or Z3 Boolean expression using the given options.</span>

<span class="sd">        &gt;&gt;&gt; x, y = Ints(&#39;x y&#39;)</span>
<span class="sd">        &gt;&gt;&gt; t = Tactic(&#39;solve-eqs&#39;)</span>
<span class="sd">        &gt;&gt;&gt; t.apply(And(x == 0, y &gt;= x + 1))</span>
<span class="sd">        [[y &gt;= 1]]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">z3_debug</span><span class="p">():</span>
            <span class="n">_z3_assert</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">goal</span><span class="p">,</span> <span class="p">(</span><span class="n">Goal</span><span class="p">,</span> <span class="n">BoolRef</span><span class="p">)),</span> <span class="s2">&quot;Z3 Goal or Boolean expressions expected&quot;</span><span class="p">)</span>
        <span class="n">goal</span> <span class="o">=</span> <span class="n">_to_goal</span><span class="p">(</span><span class="n">goal</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">arguments</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">keywords</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">args2params</span><span class="p">(</span><span class="n">arguments</span><span class="p">,</span> <span class="n">keywords</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">ApplyResult</span><span class="p">(</span><span class="n">Z3_tactic_apply_ex</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">tactic</span><span class="p">,</span> <span class="n">goal</span><span class="o">.</span><span class="n">goal</span><span class="p">,</span> <span class="n">p</span><span class="o">.</span><span class="n">params</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">ApplyResult</span><span class="p">(</span><span class="n">Z3_tactic_apply</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">tactic</span><span class="p">,</span> <span class="n">goal</span><span class="o">.</span><span class="n">goal</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">goal</span><span class="p">,</span> <span class="o">*</span><span class="n">arguments</span><span class="p">,</span> <span class="o">**</span><span class="n">keywords</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Apply tactic `self` to the given goal or Z3 Boolean expression using the given options.</span>

<span class="sd">        &gt;&gt;&gt; x, y = Ints(&#39;x y&#39;)</span>
<span class="sd">        &gt;&gt;&gt; t = Tactic(&#39;solve-eqs&#39;)</span>
<span class="sd">        &gt;&gt;&gt; t(And(x == 0, y &gt;= x + 1))</span>
<span class="sd">        [[y &gt;= 1]]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">goal</span><span class="p">,</span> <span class="o">*</span><span class="n">arguments</span><span class="p">,</span> <span class="o">**</span><span class="n">keywords</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">help</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Display a string containing a description of the available options for the `self` tactic.&quot;&quot;&quot;</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">Z3_tactic_get_help</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">tactic</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">param_descrs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the parameter description set.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">ParamDescrsRef</span><span class="p">(</span><span class="n">Z3_tactic_get_param_descrs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">tactic</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_to_goal</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">BoolRef</span><span class="p">):</span>
        <span class="n">goal</span> <span class="o">=</span> <span class="n">Goal</span><span class="p">(</span><span class="n">ctx</span><span class="o">=</span><span class="n">a</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>
        <span class="n">goal</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">goal</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">a</span>


<span class="k">def</span> <span class="nf">_to_tactic</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">ctx</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">Tactic</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">t</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">Tactic</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">ctx</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_and_then</span><span class="p">(</span><span class="n">t1</span><span class="p">,</span> <span class="n">t2</span><span class="p">,</span> <span class="n">ctx</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="n">t1</span> <span class="o">=</span> <span class="n">_to_tactic</span><span class="p">(</span><span class="n">t1</span><span class="p">,</span> <span class="n">ctx</span><span class="p">)</span>
    <span class="n">t2</span> <span class="o">=</span> <span class="n">_to_tactic</span><span class="p">(</span><span class="n">t2</span><span class="p">,</span> <span class="n">ctx</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">z3_debug</span><span class="p">():</span>
        <span class="n">_z3_assert</span><span class="p">(</span><span class="n">t1</span><span class="o">.</span><span class="n">ctx</span> <span class="o">==</span> <span class="n">t2</span><span class="o">.</span><span class="n">ctx</span><span class="p">,</span> <span class="s2">&quot;Context mismatch&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">Tactic</span><span class="p">(</span><span class="n">Z3_tactic_and_then</span><span class="p">(</span><span class="n">t1</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="n">t1</span><span class="o">.</span><span class="n">tactic</span><span class="p">,</span> <span class="n">t2</span><span class="o">.</span><span class="n">tactic</span><span class="p">),</span> <span class="n">t1</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_or_else</span><span class="p">(</span><span class="n">t1</span><span class="p">,</span> <span class="n">t2</span><span class="p">,</span> <span class="n">ctx</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="n">t1</span> <span class="o">=</span> <span class="n">_to_tactic</span><span class="p">(</span><span class="n">t1</span><span class="p">,</span> <span class="n">ctx</span><span class="p">)</span>
    <span class="n">t2</span> <span class="o">=</span> <span class="n">_to_tactic</span><span class="p">(</span><span class="n">t2</span><span class="p">,</span> <span class="n">ctx</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">z3_debug</span><span class="p">():</span>
        <span class="n">_z3_assert</span><span class="p">(</span><span class="n">t1</span><span class="o">.</span><span class="n">ctx</span> <span class="o">==</span> <span class="n">t2</span><span class="o">.</span><span class="n">ctx</span><span class="p">,</span> <span class="s2">&quot;Context mismatch&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">Tactic</span><span class="p">(</span><span class="n">Z3_tactic_or_else</span><span class="p">(</span><span class="n">t1</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="n">t1</span><span class="o">.</span><span class="n">tactic</span><span class="p">,</span> <span class="n">t2</span><span class="o">.</span><span class="n">tactic</span><span class="p">),</span> <span class="n">t1</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">AndThen</span><span class="p">(</span><span class="o">*</span><span class="n">ts</span><span class="p">,</span> <span class="o">**</span><span class="n">ks</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return a tactic that applies the tactics in `*ts` in sequence.</span>

<span class="sd">    &gt;&gt;&gt; x, y = Ints(&#39;x y&#39;)</span>
<span class="sd">    &gt;&gt;&gt; t = AndThen(Tactic(&#39;simplify&#39;), Tactic(&#39;solve-eqs&#39;))</span>
<span class="sd">    &gt;&gt;&gt; t(And(x == 0, y &gt; x + 1))</span>
<span class="sd">    [[Not(y &lt;= 1)]]</span>
<span class="sd">    &gt;&gt;&gt; t(And(x == 0, y &gt; x + 1)).as_expr()</span>
<span class="sd">    Not(y &lt;= 1)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">z3_debug</span><span class="p">():</span>
        <span class="n">_z3_assert</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ts</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">,</span> <span class="s2">&quot;At least two arguments expected&quot;</span><span class="p">)</span>
    <span class="n">ctx</span> <span class="o">=</span> <span class="n">ks</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;ctx&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
    <span class="n">num</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ts</span><span class="p">)</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">ts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">_and_then</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">ts</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="n">ctx</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">r</span>


<span class="k">def</span> <span class="nf">Then</span><span class="p">(</span><span class="o">*</span><span class="n">ts</span><span class="p">,</span> <span class="o">**</span><span class="n">ks</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return a tactic that applies the tactics in `*ts` in sequence. Shorthand for AndThen(*ts, **ks).</span>

<span class="sd">    &gt;&gt;&gt; x, y = Ints(&#39;x y&#39;)</span>
<span class="sd">    &gt;&gt;&gt; t = Then(Tactic(&#39;simplify&#39;), Tactic(&#39;solve-eqs&#39;))</span>
<span class="sd">    &gt;&gt;&gt; t(And(x == 0, y &gt; x + 1))</span>
<span class="sd">    [[Not(y &lt;= 1)]]</span>
<span class="sd">    &gt;&gt;&gt; t(And(x == 0, y &gt; x + 1)).as_expr()</span>
<span class="sd">    Not(y &lt;= 1)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">AndThen</span><span class="p">(</span><span class="o">*</span><span class="n">ts</span><span class="p">,</span> <span class="o">**</span><span class="n">ks</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">OrElse</span><span class="p">(</span><span class="o">*</span><span class="n">ts</span><span class="p">,</span> <span class="o">**</span><span class="n">ks</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return a tactic that applies the tactics in `*ts` until one of them succeeds (it doesn&#39;t fail).</span>

<span class="sd">    &gt;&gt;&gt; x = Int(&#39;x&#39;)</span>
<span class="sd">    &gt;&gt;&gt; t = OrElse(Tactic(&#39;split-clause&#39;), Tactic(&#39;skip&#39;))</span>
<span class="sd">    &gt;&gt;&gt; # Tactic split-clause fails if there is no clause in the given goal.</span>
<span class="sd">    &gt;&gt;&gt; t(x == 0)</span>
<span class="sd">    [[x == 0]]</span>
<span class="sd">    &gt;&gt;&gt; t(Or(x == 0, x == 1))</span>
<span class="sd">    [[x == 0], [x == 1]]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">z3_debug</span><span class="p">():</span>
        <span class="n">_z3_assert</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ts</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">,</span> <span class="s2">&quot;At least two arguments expected&quot;</span><span class="p">)</span>
    <span class="n">ctx</span> <span class="o">=</span> <span class="n">ks</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;ctx&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
    <span class="n">num</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ts</span><span class="p">)</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">ts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">_or_else</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">ts</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="n">ctx</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">r</span>


<span class="k">def</span> <span class="nf">ParOr</span><span class="p">(</span><span class="o">*</span><span class="n">ts</span><span class="p">,</span> <span class="o">**</span><span class="n">ks</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return a tactic that applies the tactics in `*ts` in parallel until one of them succeeds (it doesn&#39;t fail).</span>

<span class="sd">    &gt;&gt;&gt; x = Int(&#39;x&#39;)</span>
<span class="sd">    &gt;&gt;&gt; t = ParOr(Tactic(&#39;simplify&#39;), Tactic(&#39;fail&#39;))</span>
<span class="sd">    &gt;&gt;&gt; t(x + 1 == 2)</span>
<span class="sd">    [[x == 1]]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">z3_debug</span><span class="p">():</span>
        <span class="n">_z3_assert</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ts</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">,</span> <span class="s2">&quot;At least two arguments expected&quot;</span><span class="p">)</span>
    <span class="n">ctx</span> <span class="o">=</span> <span class="n">_get_ctx</span><span class="p">(</span><span class="n">ks</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;ctx&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span>
    <span class="n">ts</span> <span class="o">=</span> <span class="p">[</span><span class="n">_to_tactic</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">ctx</span><span class="p">)</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">ts</span><span class="p">]</span>
    <span class="n">sz</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ts</span><span class="p">)</span>
    <span class="n">_args</span> <span class="o">=</span> <span class="p">(</span><span class="n">TacticObj</span> <span class="o">*</span> <span class="n">sz</span><span class="p">)()</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">sz</span><span class="p">):</span>
        <span class="n">_args</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">ts</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">tactic</span>
    <span class="k">return</span> <span class="n">Tactic</span><span class="p">(</span><span class="n">Z3_tactic_par_or</span><span class="p">(</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="n">sz</span><span class="p">,</span> <span class="n">_args</span><span class="p">),</span> <span class="n">ctx</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">ParThen</span><span class="p">(</span><span class="n">t1</span><span class="p">,</span> <span class="n">t2</span><span class="p">,</span> <span class="n">ctx</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return a tactic that applies t1 and then t2 to every subgoal produced by t1.</span>
<span class="sd">    The subgoals are processed in parallel.</span>

<span class="sd">    &gt;&gt;&gt; x, y = Ints(&#39;x y&#39;)</span>
<span class="sd">    &gt;&gt;&gt; t = ParThen(Tactic(&#39;split-clause&#39;), Tactic(&#39;propagate-values&#39;))</span>
<span class="sd">    &gt;&gt;&gt; t(And(Or(x == 1, x == 2), y == x + 1))</span>
<span class="sd">    [[x == 1, y == 2], [x == 2, y == 3]]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">t1</span> <span class="o">=</span> <span class="n">_to_tactic</span><span class="p">(</span><span class="n">t1</span><span class="p">,</span> <span class="n">ctx</span><span class="p">)</span>
    <span class="n">t2</span> <span class="o">=</span> <span class="n">_to_tactic</span><span class="p">(</span><span class="n">t2</span><span class="p">,</span> <span class="n">ctx</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">z3_debug</span><span class="p">():</span>
        <span class="n">_z3_assert</span><span class="p">(</span><span class="n">t1</span><span class="o">.</span><span class="n">ctx</span> <span class="o">==</span> <span class="n">t2</span><span class="o">.</span><span class="n">ctx</span><span class="p">,</span> <span class="s2">&quot;Context mismatch&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">Tactic</span><span class="p">(</span><span class="n">Z3_tactic_par_and_then</span><span class="p">(</span><span class="n">t1</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="n">t1</span><span class="o">.</span><span class="n">tactic</span><span class="p">,</span> <span class="n">t2</span><span class="o">.</span><span class="n">tactic</span><span class="p">),</span> <span class="n">t1</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">ParAndThen</span><span class="p">(</span><span class="n">t1</span><span class="p">,</span> <span class="n">t2</span><span class="p">,</span> <span class="n">ctx</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Alias for ParThen(t1, t2, ctx).&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ParThen</span><span class="p">(</span><span class="n">t1</span><span class="p">,</span> <span class="n">t2</span><span class="p">,</span> <span class="n">ctx</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">With</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">keys</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return a tactic that applies tactic `t` using the given configuration options.</span>

<span class="sd">    &gt;&gt;&gt; x, y = Ints(&#39;x y&#39;)</span>
<span class="sd">    &gt;&gt;&gt; t = With(Tactic(&#39;simplify&#39;), som=True)</span>
<span class="sd">    &gt;&gt;&gt; t((x + 1)*(y + 2) == 0)</span>
<span class="sd">    [[2*x + y + x*y == -2]]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ctx</span> <span class="o">=</span> <span class="n">keys</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;ctx&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">_to_tactic</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">ctx</span><span class="p">)</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">args2params</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">keys</span><span class="p">,</span> <span class="n">t</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">Tactic</span><span class="p">(</span><span class="n">Z3_tactic_using_params</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="n">t</span><span class="o">.</span><span class="n">tactic</span><span class="p">,</span> <span class="n">p</span><span class="o">.</span><span class="n">params</span><span class="p">),</span> <span class="n">t</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">WithParams</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">p</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return a tactic that applies tactic `t` using the given configuration options.</span>

<span class="sd">    &gt;&gt;&gt; x, y = Ints(&#39;x y&#39;)</span>
<span class="sd">    &gt;&gt;&gt; p = ParamsRef()</span>
<span class="sd">    &gt;&gt;&gt; p.set(&quot;som&quot;, True)</span>
<span class="sd">    &gt;&gt;&gt; t = WithParams(Tactic(&#39;simplify&#39;), p)</span>
<span class="sd">    &gt;&gt;&gt; t((x + 1)*(y + 2) == 0)</span>
<span class="sd">    [[2*x + y + x*y == -2]]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">_to_tactic</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">Tactic</span><span class="p">(</span><span class="n">Z3_tactic_using_params</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="n">t</span><span class="o">.</span><span class="n">tactic</span><span class="p">,</span> <span class="n">p</span><span class="o">.</span><span class="n">params</span><span class="p">),</span> <span class="n">t</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">Repeat</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="nb">max</span><span class="o">=</span><span class="mi">4294967295</span><span class="p">,</span> <span class="n">ctx</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return a tactic that keeps applying `t` until the goal is not modified anymore</span>
<span class="sd">    or the maximum number of iterations `max` is reached.</span>

<span class="sd">    &gt;&gt;&gt; x, y = Ints(&#39;x y&#39;)</span>
<span class="sd">    &gt;&gt;&gt; c = And(Or(x == 0, x == 1), Or(y == 0, y == 1), x &gt; y)</span>
<span class="sd">    &gt;&gt;&gt; t = Repeat(OrElse(Tactic(&#39;split-clause&#39;), Tactic(&#39;skip&#39;)))</span>
<span class="sd">    &gt;&gt;&gt; r = t(c)</span>
<span class="sd">    &gt;&gt;&gt; for subgoal in r: print(subgoal)</span>
<span class="sd">    [x == 0, y == 0, x &gt; y]</span>
<span class="sd">    [x == 0, y == 1, x &gt; y]</span>
<span class="sd">    [x == 1, y == 0, x &gt; y]</span>
<span class="sd">    [x == 1, y == 1, x &gt; y]</span>
<span class="sd">    &gt;&gt;&gt; t = Then(t, Tactic(&#39;propagate-values&#39;))</span>
<span class="sd">    &gt;&gt;&gt; t(c)</span>
<span class="sd">    [[x == 1, y == 0]]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">_to_tactic</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">ctx</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">Tactic</span><span class="p">(</span><span class="n">Z3_tactic_repeat</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="n">t</span><span class="o">.</span><span class="n">tactic</span><span class="p">,</span> <span class="nb">max</span><span class="p">),</span> <span class="n">t</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">TryFor</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">ms</span><span class="p">,</span> <span class="n">ctx</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return a tactic that applies `t` to a given goal for `ms` milliseconds.</span>

<span class="sd">    If `t` does not terminate in `ms` milliseconds, then it fails.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">_to_tactic</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">ctx</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">Tactic</span><span class="p">(</span><span class="n">Z3_tactic_try_for</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="n">t</span><span class="o">.</span><span class="n">tactic</span><span class="p">,</span> <span class="n">ms</span><span class="p">),</span> <span class="n">t</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">tactics</span><span class="p">(</span><span class="n">ctx</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return a list of all available tactics in Z3.</span>

<span class="sd">    &gt;&gt;&gt; l = tactics()</span>
<span class="sd">    &gt;&gt;&gt; l.count(&#39;simplify&#39;) == 1</span>
<span class="sd">    True</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ctx</span> <span class="o">=</span> <span class="n">_get_ctx</span><span class="p">(</span><span class="n">ctx</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">Z3_get_tactic_name</span><span class="p">(</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">Z3_get_num_tactics</span><span class="p">(</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">()))]</span>


<span class="k">def</span> <span class="nf">tactic_description</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">ctx</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return a short description for the tactic named `name`.</span>

<span class="sd">    &gt;&gt;&gt; d = tactic_description(&#39;simplify&#39;)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ctx</span> <span class="o">=</span> <span class="n">_get_ctx</span><span class="p">(</span><span class="n">ctx</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">Z3_tactic_get_descr</span><span class="p">(</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="n">name</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">describe_tactics</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Display a (tabular) description of all available tactics in Z3.&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">in_html_mode</span><span class="p">():</span>
        <span class="n">even</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;&lt;table border=&quot;1&quot; cellpadding=&quot;2&quot; cellspacing=&quot;0&quot;&gt;&#39;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">tactics</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">even</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;&lt;tr style=&quot;background-color:#CFCFCF&quot;&gt;&#39;</span><span class="p">)</span>
                <span class="n">even</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;&lt;tr&gt;&quot;</span><span class="p">)</span>
                <span class="n">even</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;&lt;td&gt;</span><span class="si">%s</span><span class="s2">&lt;/td&gt;&lt;td&gt;</span><span class="si">%s</span><span class="s2">&lt;/td&gt;&lt;/tr&gt;&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">insert_line_breaks</span><span class="p">(</span><span class="n">tactic_description</span><span class="p">(</span><span class="n">t</span><span class="p">),</span> <span class="mi">40</span><span class="p">)))</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;&lt;/table&gt;&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">tactics</span><span class="p">():</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> : </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">tactic_description</span><span class="p">(</span><span class="n">t</span><span class="p">)))</span>


<span class="k">class</span> <span class="nc">Probe</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Probes are used to inspect a goal (aka problem) and collect information that may be used</span>
<span class="sd">    to decide which solver and/or preprocessing step will be used.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">probe</span><span class="p">,</span> <span class="n">ctx</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span> <span class="o">=</span> <span class="n">_get_ctx</span><span class="p">(</span><span class="n">ctx</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">probe</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">probe</span><span class="p">,</span> <span class="n">ProbeObj</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">probe</span> <span class="o">=</span> <span class="n">probe</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">probe</span><span class="p">,</span> <span class="nb">float</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">probe</span> <span class="o">=</span> <span class="n">Z3_probe_const</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="n">probe</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">_is_int</span><span class="p">(</span><span class="n">probe</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">probe</span> <span class="o">=</span> <span class="n">Z3_probe_const</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="nb">float</span><span class="p">(</span><span class="n">probe</span><span class="p">))</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">probe</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">probe</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">probe</span> <span class="o">=</span> <span class="n">Z3_probe_const</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="mf">1.0</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">probe</span> <span class="o">=</span> <span class="n">Z3_probe_const</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="mf">0.0</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">z3_debug</span><span class="p">():</span>
                <span class="n">_z3_assert</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">probe</span><span class="p">,</span> <span class="nb">str</span><span class="p">),</span> <span class="s2">&quot;probe name expected&quot;</span><span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">probe</span> <span class="o">=</span> <span class="n">Z3_mk_probe</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="n">probe</span><span class="p">)</span>
            <span class="k">except</span> <span class="n">Z3Exception</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">Z3Exception</span><span class="p">(</span><span class="s2">&quot;unknown probe &#39;</span><span class="si">%s</span><span class="s2">&#39;&quot;</span> <span class="o">%</span> <span class="n">probe</span><span class="p">)</span>
        <span class="n">Z3_probe_inc_ref</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">probe</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__deepcopy__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">memo</span><span class="o">=</span><span class="p">{}):</span>
        <span class="k">return</span> <span class="n">Probe</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">probe</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__del__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">probe</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">()</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">Z3_probe_dec_ref</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">Z3_probe_dec_ref</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">probe</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__lt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a probe that evaluates to &quot;true&quot; when the value returned by `self`</span>
<span class="sd">        is less than the value returned by `other`.</span>

<span class="sd">        &gt;&gt;&gt; p = Probe(&#39;size&#39;) &lt; 10</span>
<span class="sd">        &gt;&gt;&gt; x = Int(&#39;x&#39;)</span>
<span class="sd">        &gt;&gt;&gt; g = Goal()</span>
<span class="sd">        &gt;&gt;&gt; g.add(x &gt; 0)</span>
<span class="sd">        &gt;&gt;&gt; g.add(x &lt; 10)</span>
<span class="sd">        &gt;&gt;&gt; p(g)</span>
<span class="sd">        1.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Probe</span><span class="p">(</span><span class="n">Z3_probe_lt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">probe</span><span class="p">,</span> <span class="n">_to_probe</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span><span class="o">.</span><span class="n">probe</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__gt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a probe that evaluates to &quot;true&quot; when the value returned by `self`</span>
<span class="sd">        is greater than the value returned by `other`.</span>

<span class="sd">        &gt;&gt;&gt; p = Probe(&#39;size&#39;) &gt; 10</span>
<span class="sd">        &gt;&gt;&gt; x = Int(&#39;x&#39;)</span>
<span class="sd">        &gt;&gt;&gt; g = Goal()</span>
<span class="sd">        &gt;&gt;&gt; g.add(x &gt; 0)</span>
<span class="sd">        &gt;&gt;&gt; g.add(x &lt; 10)</span>
<span class="sd">        &gt;&gt;&gt; p(g)</span>
<span class="sd">        0.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Probe</span><span class="p">(</span><span class="n">Z3_probe_gt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">probe</span><span class="p">,</span> <span class="n">_to_probe</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span><span class="o">.</span><span class="n">probe</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__le__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a probe that evaluates to &quot;true&quot; when the value returned by `self`</span>
<span class="sd">        is less than or equal to the value returned by `other`.</span>

<span class="sd">        &gt;&gt;&gt; p = Probe(&#39;size&#39;) &lt;= 2</span>
<span class="sd">        &gt;&gt;&gt; x = Int(&#39;x&#39;)</span>
<span class="sd">        &gt;&gt;&gt; g = Goal()</span>
<span class="sd">        &gt;&gt;&gt; g.add(x &gt; 0)</span>
<span class="sd">        &gt;&gt;&gt; g.add(x &lt; 10)</span>
<span class="sd">        &gt;&gt;&gt; p(g)</span>
<span class="sd">        1.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Probe</span><span class="p">(</span><span class="n">Z3_probe_le</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">probe</span><span class="p">,</span> <span class="n">_to_probe</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span><span class="o">.</span><span class="n">probe</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__ge__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a probe that evaluates to &quot;true&quot; when the value returned by `self`</span>
<span class="sd">        is greater than or equal to the value returned by `other`.</span>

<span class="sd">        &gt;&gt;&gt; p = Probe(&#39;size&#39;) &gt;= 2</span>
<span class="sd">        &gt;&gt;&gt; x = Int(&#39;x&#39;)</span>
<span class="sd">        &gt;&gt;&gt; g = Goal()</span>
<span class="sd">        &gt;&gt;&gt; g.add(x &gt; 0)</span>
<span class="sd">        &gt;&gt;&gt; g.add(x &lt; 10)</span>
<span class="sd">        &gt;&gt;&gt; p(g)</span>
<span class="sd">        1.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Probe</span><span class="p">(</span><span class="n">Z3_probe_ge</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">probe</span><span class="p">,</span> <span class="n">_to_probe</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span><span class="o">.</span><span class="n">probe</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a probe that evaluates to &quot;true&quot; when the value returned by `self`</span>
<span class="sd">        is equal to the value returned by `other`.</span>

<span class="sd">        &gt;&gt;&gt; p = Probe(&#39;size&#39;) == 2</span>
<span class="sd">        &gt;&gt;&gt; x = Int(&#39;x&#39;)</span>
<span class="sd">        &gt;&gt;&gt; g = Goal()</span>
<span class="sd">        &gt;&gt;&gt; g.add(x &gt; 0)</span>
<span class="sd">        &gt;&gt;&gt; g.add(x &lt; 10)</span>
<span class="sd">        &gt;&gt;&gt; p(g)</span>
<span class="sd">        1.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Probe</span><span class="p">(</span><span class="n">Z3_probe_eq</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">probe</span><span class="p">,</span> <span class="n">_to_probe</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span><span class="o">.</span><span class="n">probe</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a probe that evaluates to &quot;true&quot; when the value returned by `self`</span>
<span class="sd">        is not equal to the value returned by `other`.</span>

<span class="sd">        &gt;&gt;&gt; p = Probe(&#39;size&#39;) != 2</span>
<span class="sd">        &gt;&gt;&gt; x = Int(&#39;x&#39;)</span>
<span class="sd">        &gt;&gt;&gt; g = Goal()</span>
<span class="sd">        &gt;&gt;&gt; g.add(x &gt; 0)</span>
<span class="sd">        &gt;&gt;&gt; g.add(x &lt; 10)</span>
<span class="sd">        &gt;&gt;&gt; p(g)</span>
<span class="sd">        0.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__eq__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Probe</span><span class="p">(</span><span class="n">Z3_probe_not</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="n">p</span><span class="o">.</span><span class="n">probe</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">goal</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Evaluate the probe `self` in the given goal.</span>

<span class="sd">        &gt;&gt;&gt; p = Probe(&#39;size&#39;)</span>
<span class="sd">        &gt;&gt;&gt; x = Int(&#39;x&#39;)</span>
<span class="sd">        &gt;&gt;&gt; g = Goal()</span>
<span class="sd">        &gt;&gt;&gt; g.add(x &gt; 0)</span>
<span class="sd">        &gt;&gt;&gt; g.add(x &lt; 10)</span>
<span class="sd">        &gt;&gt;&gt; p(g)</span>
<span class="sd">        2.0</span>
<span class="sd">        &gt;&gt;&gt; g.add(x &lt; 20)</span>
<span class="sd">        &gt;&gt;&gt; p(g)</span>
<span class="sd">        3.0</span>
<span class="sd">        &gt;&gt;&gt; p = Probe(&#39;num-consts&#39;)</span>
<span class="sd">        &gt;&gt;&gt; p(g)</span>
<span class="sd">        1.0</span>
<span class="sd">        &gt;&gt;&gt; p = Probe(&#39;is-propositional&#39;)</span>
<span class="sd">        &gt;&gt;&gt; p(g)</span>
<span class="sd">        0.0</span>
<span class="sd">        &gt;&gt;&gt; p = Probe(&#39;is-qflia&#39;)</span>
<span class="sd">        &gt;&gt;&gt; p(g)</span>
<span class="sd">        1.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">z3_debug</span><span class="p">():</span>
            <span class="n">_z3_assert</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">goal</span><span class="p">,</span> <span class="p">(</span><span class="n">Goal</span><span class="p">,</span> <span class="n">BoolRef</span><span class="p">)),</span> <span class="s2">&quot;Z3 Goal or Boolean expression expected&quot;</span><span class="p">)</span>
        <span class="n">goal</span> <span class="o">=</span> <span class="n">_to_goal</span><span class="p">(</span><span class="n">goal</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Z3_probe_apply</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">probe</span><span class="p">,</span> <span class="n">goal</span><span class="o">.</span><span class="n">goal</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">is_probe</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return `True` if `p` is a Z3 probe.</span>

<span class="sd">    &gt;&gt;&gt; is_probe(Int(&#39;x&#39;))</span>
<span class="sd">    False</span>
<span class="sd">    &gt;&gt;&gt; is_probe(Probe(&#39;memory&#39;))</span>
<span class="sd">    True</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">Probe</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_to_probe</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">ctx</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">is_probe</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">p</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">Probe</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">ctx</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">probes</span><span class="p">(</span><span class="n">ctx</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return a list of all available probes in Z3.</span>

<span class="sd">    &gt;&gt;&gt; l = probes()</span>
<span class="sd">    &gt;&gt;&gt; l.count(&#39;memory&#39;) == 1</span>
<span class="sd">    True</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ctx</span> <span class="o">=</span> <span class="n">_get_ctx</span><span class="p">(</span><span class="n">ctx</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">Z3_get_probe_name</span><span class="p">(</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">Z3_get_num_probes</span><span class="p">(</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">()))]</span>


<span class="k">def</span> <span class="nf">probe_description</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">ctx</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return a short description for the probe named `name`.</span>

<span class="sd">    &gt;&gt;&gt; d = probe_description(&#39;memory&#39;)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ctx</span> <span class="o">=</span> <span class="n">_get_ctx</span><span class="p">(</span><span class="n">ctx</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">Z3_probe_get_descr</span><span class="p">(</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="n">name</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">describe_probes</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Display a (tabular) description of all available probes in Z3.&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">in_html_mode</span><span class="p">():</span>
        <span class="n">even</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;&lt;table border=&quot;1&quot; cellpadding=&quot;2&quot; cellspacing=&quot;0&quot;&gt;&#39;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">probes</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">even</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;&lt;tr style=&quot;background-color:#CFCFCF&quot;&gt;&#39;</span><span class="p">)</span>
                <span class="n">even</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;&lt;tr&gt;&quot;</span><span class="p">)</span>
                <span class="n">even</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;&lt;td&gt;</span><span class="si">%s</span><span class="s2">&lt;/td&gt;&lt;td&gt;</span><span class="si">%s</span><span class="s2">&lt;/td&gt;&lt;/tr&gt;&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">insert_line_breaks</span><span class="p">(</span><span class="n">probe_description</span><span class="p">(</span><span class="n">p</span><span class="p">),</span> <span class="mi">40</span><span class="p">)))</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;&lt;/table&gt;&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">probes</span><span class="p">():</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> : </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">probe_description</span><span class="p">(</span><span class="n">p</span><span class="p">)))</span>


<span class="k">def</span> <span class="nf">_probe_nary</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">ctx</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">z3_debug</span><span class="p">():</span>
        <span class="n">_z3_assert</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;At least one argument expected&quot;</span><span class="p">)</span>
    <span class="n">num</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">_to_probe</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ctx</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">Probe</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="n">r</span><span class="o">.</span><span class="n">probe</span><span class="p">,</span> <span class="n">_to_probe</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="n">ctx</span><span class="p">)</span><span class="o">.</span><span class="n">probe</span><span class="p">),</span> <span class="n">ctx</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">r</span>


<span class="k">def</span> <span class="nf">_probe_and</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">ctx</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">_probe_nary</span><span class="p">(</span><span class="n">Z3_probe_and</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">ctx</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_probe_or</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">ctx</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">_probe_nary</span><span class="p">(</span><span class="n">Z3_probe_or</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">ctx</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">FailIf</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">ctx</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return a tactic that fails if the probe `p` evaluates to true.</span>
<span class="sd">    Otherwise, it returns the input goal unmodified.</span>

<span class="sd">    In the following example, the tactic applies &#39;simplify&#39; if and only if there are</span>
<span class="sd">    more than 2 constraints in the goal.</span>

<span class="sd">    &gt;&gt;&gt; t = OrElse(FailIf(Probe(&#39;size&#39;) &gt; 2), Tactic(&#39;simplify&#39;))</span>
<span class="sd">    &gt;&gt;&gt; x, y = Ints(&#39;x y&#39;)</span>
<span class="sd">    &gt;&gt;&gt; g = Goal()</span>
<span class="sd">    &gt;&gt;&gt; g.add(x &gt; 0)</span>
<span class="sd">    &gt;&gt;&gt; g.add(y &gt; 0)</span>
<span class="sd">    &gt;&gt;&gt; t(g)</span>
<span class="sd">    [[x &gt; 0, y &gt; 0]]</span>
<span class="sd">    &gt;&gt;&gt; g.add(x == y + 1)</span>
<span class="sd">    &gt;&gt;&gt; t(g)</span>
<span class="sd">    [[Not(x &lt;= 0), Not(y &lt;= 0), x == 1 + y]]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">_to_probe</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">ctx</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">Tactic</span><span class="p">(</span><span class="n">Z3_tactic_fail_if</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="n">p</span><span class="o">.</span><span class="n">probe</span><span class="p">),</span> <span class="n">p</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">When</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">ctx</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return a tactic that applies tactic `t` only if probe `p` evaluates to true.</span>
<span class="sd">    Otherwise, it returns the input goal unmodified.</span>

<span class="sd">    &gt;&gt;&gt; t = When(Probe(&#39;size&#39;) &gt; 2, Tactic(&#39;simplify&#39;))</span>
<span class="sd">    &gt;&gt;&gt; x, y = Ints(&#39;x y&#39;)</span>
<span class="sd">    &gt;&gt;&gt; g = Goal()</span>
<span class="sd">    &gt;&gt;&gt; g.add(x &gt; 0)</span>
<span class="sd">    &gt;&gt;&gt; g.add(y &gt; 0)</span>
<span class="sd">    &gt;&gt;&gt; t(g)</span>
<span class="sd">    [[x &gt; 0, y &gt; 0]]</span>
<span class="sd">    &gt;&gt;&gt; g.add(x == y + 1)</span>
<span class="sd">    &gt;&gt;&gt; t(g)</span>
<span class="sd">    [[Not(x &lt;= 0), Not(y &lt;= 0), x == 1 + y]]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">_to_probe</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">ctx</span><span class="p">)</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">_to_tactic</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">ctx</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">Tactic</span><span class="p">(</span><span class="n">Z3_tactic_when</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="n">p</span><span class="o">.</span><span class="n">probe</span><span class="p">,</span> <span class="n">t</span><span class="o">.</span><span class="n">tactic</span><span class="p">),</span> <span class="n">t</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">Cond</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">t1</span><span class="p">,</span> <span class="n">t2</span><span class="p">,</span> <span class="n">ctx</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return a tactic that applies tactic `t1` to a goal if probe `p` evaluates to true, and `t2` otherwise.</span>

<span class="sd">    &gt;&gt;&gt; t = Cond(Probe(&#39;is-qfnra&#39;), Tactic(&#39;qfnra&#39;), Tactic(&#39;smt&#39;))</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">_to_probe</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">ctx</span><span class="p">)</span>
    <span class="n">t1</span> <span class="o">=</span> <span class="n">_to_tactic</span><span class="p">(</span><span class="n">t1</span><span class="p">,</span> <span class="n">ctx</span><span class="p">)</span>
    <span class="n">t2</span> <span class="o">=</span> <span class="n">_to_tactic</span><span class="p">(</span><span class="n">t2</span><span class="p">,</span> <span class="n">ctx</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">Tactic</span><span class="p">(</span><span class="n">Z3_tactic_cond</span><span class="p">(</span><span class="n">t1</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="n">p</span><span class="o">.</span><span class="n">probe</span><span class="p">,</span> <span class="n">t1</span><span class="o">.</span><span class="n">tactic</span><span class="p">,</span> <span class="n">t2</span><span class="o">.</span><span class="n">tactic</span><span class="p">),</span> <span class="n">t1</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>

<span class="c1">#########################################</span>
<span class="c1">#</span>
<span class="c1"># Utils</span>
<span class="c1">#</span>
<span class="c1">#########################################</span>


<span class="k">def</span> <span class="nf">simplify</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="o">*</span><span class="n">arguments</span><span class="p">,</span> <span class="o">**</span><span class="n">keywords</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Simplify the expression `a` using the given options.</span>

<span class="sd">    This function has many options. Use `help_simplify` to obtain the complete list.</span>

<span class="sd">    &gt;&gt;&gt; x = Int(&#39;x&#39;)</span>
<span class="sd">    &gt;&gt;&gt; y = Int(&#39;y&#39;)</span>
<span class="sd">    &gt;&gt;&gt; simplify(x + 1 + y + x + 1)</span>
<span class="sd">    2 + 2*x + y</span>
<span class="sd">    &gt;&gt;&gt; simplify((x + 1)*(y + 1), som=True)</span>
<span class="sd">    1 + x + y + x*y</span>
<span class="sd">    &gt;&gt;&gt; simplify(Distinct(x, y, 1), blast_distinct=True)</span>
<span class="sd">    And(Not(x == y), Not(x == 1), Not(y == 1))</span>
<span class="sd">    &gt;&gt;&gt; simplify(And(x == 0, y == 1), elim_and=True)</span>
<span class="sd">    Not(Or(Not(x == 0), Not(y == 1)))</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">z3_debug</span><span class="p">():</span>
        <span class="n">_z3_assert</span><span class="p">(</span><span class="n">is_expr</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="s2">&quot;Z3 expression expected&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">arguments</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">keywords</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">args2params</span><span class="p">(</span><span class="n">arguments</span><span class="p">,</span> <span class="n">keywords</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">_to_expr_ref</span><span class="p">(</span><span class="n">Z3_simplify_ex</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">ctx_ref</span><span class="p">(),</span> <span class="n">a</span><span class="o">.</span><span class="n">as_ast</span><span class="p">(),</span> <span class="n">p</span><span class="o">.</span><span class="n">params</span><span class="p">),</span> <span class="n">a</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_to_expr_ref</span><span class="p">(</span><span class="n">Z3_simplify</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">ctx_ref</span><span class="p">(),</span> <span class="n">a</span><span class="o">.</span><span class="n">as_ast</span><span class="p">()),</span> <span class="n">a</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">help_simplify</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return a string describing all options available for Z3 `simplify` procedure.&quot;&quot;&quot;</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">Z3_simplify_get_help</span><span class="p">(</span><span class="n">main_ctx</span><span class="p">()</span><span class="o">.</span><span class="n">ref</span><span class="p">()))</span>


<span class="k">def</span> <span class="nf">simplify_param_descrs</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return the set of parameter descriptions for Z3 `simplify` procedure.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ParamDescrsRef</span><span class="p">(</span><span class="n">Z3_simplify_get_param_descrs</span><span class="p">(</span><span class="n">main_ctx</span><span class="p">()</span><span class="o">.</span><span class="n">ref</span><span class="p">()),</span> <span class="n">main_ctx</span><span class="p">())</span>


<span class="k">def</span> <span class="nf">substitute</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="o">*</span><span class="n">m</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Apply substitution m on t, m is a list of pairs of the form (from, to).</span>
<span class="sd">    Every occurrence in t of from is replaced with to.</span>

<span class="sd">    &gt;&gt;&gt; x = Int(&#39;x&#39;)</span>
<span class="sd">    &gt;&gt;&gt; y = Int(&#39;y&#39;)</span>
<span class="sd">    &gt;&gt;&gt; substitute(x + 1, (x, y + 1))</span>
<span class="sd">    y + 1 + 1</span>
<span class="sd">    &gt;&gt;&gt; f = Function(&#39;f&#39;, IntSort(), IntSort())</span>
<span class="sd">    &gt;&gt;&gt; substitute(f(x) + f(y), (f(x), IntVal(1)), (f(y), IntVal(1)))</span>
<span class="sd">    1 + 1</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
        <span class="n">m1</span> <span class="o">=</span> <span class="n">_get_args</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">m1</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">m1</span><span class="p">):</span>
            <span class="n">m</span> <span class="o">=</span> <span class="n">m1</span>
    <span class="k">if</span> <span class="n">z3_debug</span><span class="p">():</span>
        <span class="n">_z3_assert</span><span class="p">(</span><span class="n">is_expr</span><span class="p">(</span><span class="n">t</span><span class="p">),</span> <span class="s2">&quot;Z3 expression expected&quot;</span><span class="p">)</span>
        <span class="n">_z3_assert</span><span class="p">(</span>
            <span class="nb">all</span><span class="p">([</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="ow">and</span> <span class="n">is_expr</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="ow">and</span> <span class="n">is_expr</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">m</span><span class="p">]),</span>
            <span class="s2">&quot;Z3 invalid substitution, expression pairs expected.&quot;</span><span class="p">)</span>
        <span class="n">_z3_assert</span><span class="p">(</span>
            <span class="nb">all</span><span class="p">([</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span><span class="o">.</span><span class="n">eq</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">sort</span><span class="p">())</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">m</span><span class="p">]),</span>
            <span class="s1">&#39;Z3 invalid substitution, mismatching &quot;from&quot; and &quot;to&quot; sorts.&#39;</span><span class="p">)</span>
    <span class="n">num</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
    <span class="n">_from</span> <span class="o">=</span> <span class="p">(</span><span class="n">Ast</span> <span class="o">*</span> <span class="n">num</span><span class="p">)()</span>
    <span class="n">_to</span> <span class="o">=</span> <span class="p">(</span><span class="n">Ast</span> <span class="o">*</span> <span class="n">num</span><span class="p">)()</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num</span><span class="p">):</span>
        <span class="n">_from</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">m</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">as_ast</span><span class="p">()</span>
        <span class="n">_to</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">m</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">as_ast</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">_to_expr_ref</span><span class="p">(</span><span class="n">Z3_substitute</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="n">t</span><span class="o">.</span><span class="n">as_ast</span><span class="p">(),</span> <span class="n">num</span><span class="p">,</span> <span class="n">_from</span><span class="p">,</span> <span class="n">_to</span><span class="p">),</span> <span class="n">t</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">substitute_vars</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="o">*</span><span class="n">m</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Substitute the free variables in t with the expression in m.</span>

<span class="sd">    &gt;&gt;&gt; v0 = Var(0, IntSort())</span>
<span class="sd">    &gt;&gt;&gt; v1 = Var(1, IntSort())</span>
<span class="sd">    &gt;&gt;&gt; x  = Int(&#39;x&#39;)</span>
<span class="sd">    &gt;&gt;&gt; f  = Function(&#39;f&#39;, IntSort(), IntSort(), IntSort())</span>
<span class="sd">    &gt;&gt;&gt; # replace v0 with x+1 and v1 with x</span>
<span class="sd">    &gt;&gt;&gt; substitute_vars(f(v0, v1), x + 1, x)</span>
<span class="sd">    f(x + 1, x)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">z3_debug</span><span class="p">():</span>
        <span class="n">_z3_assert</span><span class="p">(</span><span class="n">is_expr</span><span class="p">(</span><span class="n">t</span><span class="p">),</span> <span class="s2">&quot;Z3 expression expected&quot;</span><span class="p">)</span>
        <span class="n">_z3_assert</span><span class="p">(</span><span class="nb">all</span><span class="p">([</span><span class="n">is_expr</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">m</span><span class="p">]),</span> <span class="s2">&quot;Z3 invalid substitution, list of expressions expected.&quot;</span><span class="p">)</span>
    <span class="n">num</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
    <span class="n">_to</span> <span class="o">=</span> <span class="p">(</span><span class="n">Ast</span> <span class="o">*</span> <span class="n">num</span><span class="p">)()</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num</span><span class="p">):</span>
        <span class="n">_to</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">m</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">as_ast</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">_to_expr_ref</span><span class="p">(</span><span class="n">Z3_substitute_vars</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="n">t</span><span class="o">.</span><span class="n">as_ast</span><span class="p">(),</span> <span class="n">num</span><span class="p">,</span> <span class="n">_to</span><span class="p">),</span> <span class="n">t</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">substitute_funs</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="o">*</span><span class="n">m</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Apply substitution m on t, m is a list of pairs of a function and expression (from, to)</span>
<span class="sd">    Every occurrence in to of the function from is replaced with the expression to.</span>
<span class="sd">    The expression to can have free variables, that refer to the arguments of from.</span>
<span class="sd">    For examples, see </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
        <span class="n">m1</span> <span class="o">=</span> <span class="n">_get_args</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">m1</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">m1</span><span class="p">):</span>
            <span class="n">m</span> <span class="o">=</span> <span class="n">m1</span>
    <span class="k">if</span> <span class="n">z3_debug</span><span class="p">():</span>
        <span class="n">_z3_assert</span><span class="p">(</span><span class="n">is_expr</span><span class="p">(</span><span class="n">t</span><span class="p">),</span> <span class="s2">&quot;Z3 expression expected&quot;</span><span class="p">)</span>
        <span class="n">_z3_assert</span><span class="p">(</span><span class="nb">all</span><span class="p">([</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="ow">and</span> <span class="n">is_func_decl</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="ow">and</span> <span class="n">is_expr</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">m</span><span class="p">]),</span> <span class="s2">&quot;Z3 invalid substitution, funcion pairs expected.&quot;</span><span class="p">)</span>
    <span class="n">num</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
    <span class="n">_from</span> <span class="o">=</span> <span class="p">(</span><span class="n">FuncDecl</span> <span class="o">*</span> <span class="n">num</span><span class="p">)()</span>
    <span class="n">_to</span> <span class="o">=</span> <span class="p">(</span><span class="n">Ast</span> <span class="o">*</span> <span class="n">num</span><span class="p">)()</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num</span><span class="p">):</span>
        <span class="n">_from</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">m</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">as_func_decl</span><span class="p">()</span>
        <span class="n">_to</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">m</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">as_ast</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">_to_expr_ref</span><span class="p">(</span><span class="n">Z3_substitute_funs</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="n">t</span><span class="o">.</span><span class="n">as_ast</span><span class="p">(),</span> <span class="n">num</span><span class="p">,</span> <span class="n">_from</span><span class="p">,</span> <span class="n">_to</span><span class="p">),</span> <span class="n">t</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">Sum</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Create the sum of the Z3 expressions.</span>

<span class="sd">    &gt;&gt;&gt; a, b, c = Ints(&#39;a b c&#39;)</span>
<span class="sd">    &gt;&gt;&gt; Sum(a, b, c)</span>
<span class="sd">    a + b + c</span>
<span class="sd">    &gt;&gt;&gt; Sum([a, b, c])</span>
<span class="sd">    a + b + c</span>
<span class="sd">    &gt;&gt;&gt; A = IntVector(&#39;a&#39;, 5)</span>
<span class="sd">    &gt;&gt;&gt; Sum(A)</span>
<span class="sd">    a__0 + a__1 + a__2 + a__3 + a__4</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">args</span> <span class="o">=</span> <span class="n">_get_args</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">0</span>
    <span class="n">ctx</span> <span class="o">=</span> <span class="n">_ctx_from_ast_arg_list</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">ctx</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_reduce</span><span class="p">(</span><span class="k">lambda</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">args</span> <span class="o">=</span> <span class="n">_coerce_expr_list</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">ctx</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">is_bv</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
        <span class="k">return</span> <span class="n">_reduce</span><span class="p">(</span><span class="k">lambda</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">_args</span><span class="p">,</span> <span class="n">sz</span> <span class="o">=</span> <span class="n">_to_ast_array</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ArithRef</span><span class="p">(</span><span class="n">Z3_mk_add</span><span class="p">(</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="n">sz</span><span class="p">,</span> <span class="n">_args</span><span class="p">),</span> <span class="n">ctx</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">Product</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Create the product of the Z3 expressions.</span>

<span class="sd">    &gt;&gt;&gt; a, b, c = Ints(&#39;a b c&#39;)</span>
<span class="sd">    &gt;&gt;&gt; Product(a, b, c)</span>
<span class="sd">    a*b*c</span>
<span class="sd">    &gt;&gt;&gt; Product([a, b, c])</span>
<span class="sd">    a*b*c</span>
<span class="sd">    &gt;&gt;&gt; A = IntVector(&#39;a&#39;, 5)</span>
<span class="sd">    &gt;&gt;&gt; Product(A)</span>
<span class="sd">    a__0*a__1*a__2*a__3*a__4</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">args</span> <span class="o">=</span> <span class="n">_get_args</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">1</span>
    <span class="n">ctx</span> <span class="o">=</span> <span class="n">_ctx_from_ast_arg_list</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">ctx</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_reduce</span><span class="p">(</span><span class="k">lambda</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="n">a</span> <span class="o">*</span> <span class="n">b</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">args</span> <span class="o">=</span> <span class="n">_coerce_expr_list</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">ctx</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">is_bv</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
        <span class="k">return</span> <span class="n">_reduce</span><span class="p">(</span><span class="k">lambda</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="n">a</span> <span class="o">*</span> <span class="n">b</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">_args</span><span class="p">,</span> <span class="n">sz</span> <span class="o">=</span> <span class="n">_to_ast_array</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ArithRef</span><span class="p">(</span><span class="n">Z3_mk_mul</span><span class="p">(</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="n">sz</span><span class="p">,</span> <span class="n">_args</span><span class="p">),</span> <span class="n">ctx</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">Abs</span><span class="p">(</span><span class="n">arg</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Create the absolute value of an arithmetic expression&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">If</span><span class="p">(</span><span class="n">arg</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span> <span class="o">-</span><span class="n">arg</span><span class="p">)</span>
    

<span class="k">def</span> <span class="nf">AtMost</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Create an at-most Pseudo-Boolean k constraint.</span>

<span class="sd">    &gt;&gt;&gt; a, b, c = Bools(&#39;a b c&#39;)</span>
<span class="sd">    &gt;&gt;&gt; f = AtMost(a, b, c, 2)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">args</span> <span class="o">=</span> <span class="n">_get_args</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">z3_debug</span><span class="p">():</span>
        <span class="n">_z3_assert</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;Non empty list of arguments expected&quot;</span><span class="p">)</span>
    <span class="n">ctx</span> <span class="o">=</span> <span class="n">_ctx_from_ast_arg_list</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">z3_debug</span><span class="p">():</span>
        <span class="n">_z3_assert</span><span class="p">(</span><span class="n">ctx</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;At least one of the arguments must be a Z3 expression&quot;</span><span class="p">)</span>
    <span class="n">args1</span> <span class="o">=</span> <span class="n">_coerce_expr_list</span><span class="p">(</span><span class="n">args</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">ctx</span><span class="p">)</span>
    <span class="n">k</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">_args</span><span class="p">,</span> <span class="n">sz</span> <span class="o">=</span> <span class="n">_to_ast_array</span><span class="p">(</span><span class="n">args1</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">BoolRef</span><span class="p">(</span><span class="n">Z3_mk_atmost</span><span class="p">(</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="n">sz</span><span class="p">,</span> <span class="n">_args</span><span class="p">,</span> <span class="n">k</span><span class="p">),</span> <span class="n">ctx</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">AtLeast</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Create an at-most Pseudo-Boolean k constraint.</span>

<span class="sd">    &gt;&gt;&gt; a, b, c = Bools(&#39;a b c&#39;)</span>
<span class="sd">    &gt;&gt;&gt; f = AtLeast(a, b, c, 2)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">args</span> <span class="o">=</span> <span class="n">_get_args</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">z3_debug</span><span class="p">():</span>
        <span class="n">_z3_assert</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;Non empty list of arguments expected&quot;</span><span class="p">)</span>
    <span class="n">ctx</span> <span class="o">=</span> <span class="n">_ctx_from_ast_arg_list</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">z3_debug</span><span class="p">():</span>
        <span class="n">_z3_assert</span><span class="p">(</span><span class="n">ctx</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;At least one of the arguments must be a Z3 expression&quot;</span><span class="p">)</span>
    <span class="n">args1</span> <span class="o">=</span> <span class="n">_coerce_expr_list</span><span class="p">(</span><span class="n">args</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">ctx</span><span class="p">)</span>
    <span class="n">k</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">_args</span><span class="p">,</span> <span class="n">sz</span> <span class="o">=</span> <span class="n">_to_ast_array</span><span class="p">(</span><span class="n">args1</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">BoolRef</span><span class="p">(</span><span class="n">Z3_mk_atleast</span><span class="p">(</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="n">sz</span><span class="p">,</span> <span class="n">_args</span><span class="p">,</span> <span class="n">k</span><span class="p">),</span> <span class="n">ctx</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_reorder_pb_arg</span><span class="p">(</span><span class="n">arg</span><span class="p">):</span>
    <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">arg</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">_is_int</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="ow">and</span> <span class="n">_is_int</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">b</span><span class="p">,</span> <span class="n">a</span>
    <span class="k">return</span> <span class="n">arg</span>


<span class="k">def</span> <span class="nf">_pb_args_coeffs</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">default_ctx</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="n">args</span> <span class="o">=</span> <span class="n">_get_args_ast_list</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_get_ctx</span><span class="p">(</span><span class="n">default_ctx</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="n">Ast</span> <span class="o">*</span> <span class="mi">0</span><span class="p">)(),</span> <span class="p">(</span><span class="n">ctypes</span><span class="o">.</span><span class="n">c_int</span> <span class="o">*</span> <span class="mi">0</span><span class="p">)()</span>
    <span class="n">args</span> <span class="o">=</span> <span class="p">[</span><span class="n">_reorder_pb_arg</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span> <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">args</span><span class="p">]</span>
    <span class="n">args</span><span class="p">,</span> <span class="n">coeffs</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">z3_debug</span><span class="p">():</span>
        <span class="n">_z3_assert</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;Non empty list of arguments expected&quot;</span><span class="p">)</span>
    <span class="n">ctx</span> <span class="o">=</span> <span class="n">_ctx_from_ast_arg_list</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">z3_debug</span><span class="p">():</span>
        <span class="n">_z3_assert</span><span class="p">(</span><span class="n">ctx</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;At least one of the arguments must be a Z3 expression&quot;</span><span class="p">)</span>
    <span class="n">args</span> <span class="o">=</span> <span class="n">_coerce_expr_list</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">ctx</span><span class="p">)</span>
    <span class="n">_args</span><span class="p">,</span> <span class="n">sz</span> <span class="o">=</span> <span class="n">_to_ast_array</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
    <span class="n">_coeffs</span> <span class="o">=</span> <span class="p">(</span><span class="n">ctypes</span><span class="o">.</span><span class="n">c_int</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">coeffs</span><span class="p">))()</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">coeffs</span><span class="p">)):</span>
        <span class="n">_z3_check_cint_overflow</span><span class="p">(</span><span class="n">coeffs</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="s2">&quot;coefficient&quot;</span><span class="p">)</span>
        <span class="n">_coeffs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">coeffs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">ctx</span><span class="p">,</span> <span class="n">sz</span><span class="p">,</span> <span class="n">_args</span><span class="p">,</span> <span class="n">_coeffs</span><span class="p">,</span> <span class="n">args</span>


<span class="k">def</span> <span class="nf">PbLe</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Create a Pseudo-Boolean inequality k constraint.</span>

<span class="sd">    &gt;&gt;&gt; a, b, c = Bools(&#39;a b c&#39;)</span>
<span class="sd">    &gt;&gt;&gt; f = PbLe(((a,1),(b,3),(c,2)), 3)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_z3_check_cint_overflow</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="s2">&quot;k&quot;</span><span class="p">)</span>
    <span class="n">ctx</span><span class="p">,</span> <span class="n">sz</span><span class="p">,</span> <span class="n">_args</span><span class="p">,</span> <span class="n">_coeffs</span><span class="p">,</span> <span class="n">args</span> <span class="o">=</span> <span class="n">_pb_args_coeffs</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">BoolRef</span><span class="p">(</span><span class="n">Z3_mk_pble</span><span class="p">(</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="n">sz</span><span class="p">,</span> <span class="n">_args</span><span class="p">,</span> <span class="n">_coeffs</span><span class="p">,</span> <span class="n">k</span><span class="p">),</span> <span class="n">ctx</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">PbGe</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Create a Pseudo-Boolean inequality k constraint.</span>

<span class="sd">    &gt;&gt;&gt; a, b, c = Bools(&#39;a b c&#39;)</span>
<span class="sd">    &gt;&gt;&gt; f = PbGe(((a,1),(b,3),(c,2)), 3)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_z3_check_cint_overflow</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="s2">&quot;k&quot;</span><span class="p">)</span>
    <span class="n">ctx</span><span class="p">,</span> <span class="n">sz</span><span class="p">,</span> <span class="n">_args</span><span class="p">,</span> <span class="n">_coeffs</span><span class="p">,</span> <span class="n">args</span> <span class="o">=</span> <span class="n">_pb_args_coeffs</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">BoolRef</span><span class="p">(</span><span class="n">Z3_mk_pbge</span><span class="p">(</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="n">sz</span><span class="p">,</span> <span class="n">_args</span><span class="p">,</span> <span class="n">_coeffs</span><span class="p">,</span> <span class="n">k</span><span class="p">),</span> <span class="n">ctx</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">PbEq</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">ctx</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Create a Pseudo-Boolean equality k constraint.</span>

<span class="sd">    &gt;&gt;&gt; a, b, c = Bools(&#39;a b c&#39;)</span>
<span class="sd">    &gt;&gt;&gt; f = PbEq(((a,1),(b,3),(c,2)), 3)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_z3_check_cint_overflow</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="s2">&quot;k&quot;</span><span class="p">)</span>
    <span class="n">ctx</span><span class="p">,</span> <span class="n">sz</span><span class="p">,</span> <span class="n">_args</span><span class="p">,</span> <span class="n">_coeffs</span><span class="p">,</span> <span class="n">args</span> <span class="o">=</span> <span class="n">_pb_args_coeffs</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">BoolRef</span><span class="p">(</span><span class="n">Z3_mk_pbeq</span><span class="p">(</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="n">sz</span><span class="p">,</span> <span class="n">_args</span><span class="p">,</span> <span class="n">_coeffs</span><span class="p">,</span> <span class="n">k</span><span class="p">),</span> <span class="n">ctx</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">keywords</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Solve the constraints `*args`.</span>

<span class="sd">    This is a simple function for creating demonstrations. It creates a solver,</span>
<span class="sd">    configure it using the options in `keywords`, adds the constraints</span>
<span class="sd">    in `args`, and invokes check.</span>

<span class="sd">    &gt;&gt;&gt; a = Int(&#39;a&#39;)</span>
<span class="sd">    &gt;&gt;&gt; solve(a &gt; 0, a &lt; 2)</span>
<span class="sd">    [a = 1]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">show</span> <span class="o">=</span> <span class="n">keywords</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;show&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">Solver</span><span class="p">()</span>
    <span class="n">s</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="o">**</span><span class="n">keywords</span><span class="p">)</span>
    <span class="n">s</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">show</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">check</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">r</span> <span class="o">==</span> <span class="n">unsat</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;no solution&quot;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">r</span> <span class="o">==</span> <span class="n">unknown</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;failed to solve&quot;</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">model</span><span class="p">())</span>
        <span class="k">except</span> <span class="n">Z3Exception</span><span class="p">:</span>
            <span class="k">return</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">model</span><span class="p">())</span>


<span class="k">def</span> <span class="nf">solve_using</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">keywords</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Solve the constraints `*args` using solver `s`.</span>

<span class="sd">    This is a simple function for creating demonstrations. It is similar to `solve`,</span>
<span class="sd">    but it uses the given solver `s`.</span>
<span class="sd">    It configures solver `s` using the options in `keywords`, adds the constraints</span>
<span class="sd">    in `args`, and invokes check.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">show</span> <span class="o">=</span> <span class="n">keywords</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;show&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">z3_debug</span><span class="p">():</span>
        <span class="n">_z3_assert</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">Solver</span><span class="p">),</span> <span class="s2">&quot;Solver object expected&quot;</span><span class="p">)</span>
    <span class="n">s</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="o">**</span><span class="n">keywords</span><span class="p">)</span>
    <span class="n">s</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">show</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Problem:&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">check</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">r</span> <span class="o">==</span> <span class="n">unsat</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;no solution&quot;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">r</span> <span class="o">==</span> <span class="n">unknown</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;failed to solve&quot;</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">model</span><span class="p">())</span>
        <span class="k">except</span> <span class="n">Z3Exception</span><span class="p">:</span>
            <span class="k">return</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">show</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Solution:&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">model</span><span class="p">())</span>


<span class="k">def</span> <span class="nf">prove</span><span class="p">(</span><span class="n">claim</span><span class="p">,</span> <span class="n">show</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">keywords</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Try to prove the given claim.</span>

<span class="sd">    This is a simple function for creating demonstrations.  It tries to prove</span>
<span class="sd">    `claim` by showing the negation is unsatisfiable.</span>

<span class="sd">    &gt;&gt;&gt; p, q = Bools(&#39;p q&#39;)</span>
<span class="sd">    &gt;&gt;&gt; prove(Not(And(p, q)) == Or(Not(p), Not(q)))</span>
<span class="sd">    proved</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">z3_debug</span><span class="p">():</span>
        <span class="n">_z3_assert</span><span class="p">(</span><span class="n">is_bool</span><span class="p">(</span><span class="n">claim</span><span class="p">),</span> <span class="s2">&quot;Z3 Boolean expression expected&quot;</span><span class="p">)</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">Solver</span><span class="p">()</span>
    <span class="n">s</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="o">**</span><span class="n">keywords</span><span class="p">)</span>
    <span class="n">s</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">Not</span><span class="p">(</span><span class="n">claim</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">show</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">check</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">r</span> <span class="o">==</span> <span class="n">unsat</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;proved&quot;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">r</span> <span class="o">==</span> <span class="n">unknown</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;failed to prove&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">model</span><span class="p">())</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;counterexample&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">model</span><span class="p">())</span>


<span class="k">def</span> <span class="nf">_solve_html</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">keywords</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Version of function `solve` that renders HTML output.&quot;&quot;&quot;</span>
    <span class="n">show</span> <span class="o">=</span> <span class="n">keywords</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;show&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">Solver</span><span class="p">()</span>
    <span class="n">s</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="o">**</span><span class="n">keywords</span><span class="p">)</span>
    <span class="n">s</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">show</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;&lt;b&gt;Problem:&lt;/b&gt;&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">check</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">r</span> <span class="o">==</span> <span class="n">unsat</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;&lt;b&gt;no solution&lt;/b&gt;&quot;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">r</span> <span class="o">==</span> <span class="n">unknown</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;&lt;b&gt;failed to solve&lt;/b&gt;&quot;</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">model</span><span class="p">())</span>
        <span class="k">except</span> <span class="n">Z3Exception</span><span class="p">:</span>
            <span class="k">return</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">show</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;&lt;b&gt;Solution:&lt;/b&gt;&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">model</span><span class="p">())</span>


<span class="k">def</span> <span class="nf">_solve_using_html</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">keywords</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Version of function `solve_using` that renders HTML.&quot;&quot;&quot;</span>
    <span class="n">show</span> <span class="o">=</span> <span class="n">keywords</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;show&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">z3_debug</span><span class="p">():</span>
        <span class="n">_z3_assert</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">Solver</span><span class="p">),</span> <span class="s2">&quot;Solver object expected&quot;</span><span class="p">)</span>
    <span class="n">s</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="o">**</span><span class="n">keywords</span><span class="p">)</span>
    <span class="n">s</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">show</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;&lt;b&gt;Problem:&lt;/b&gt;&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">check</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">r</span> <span class="o">==</span> <span class="n">unsat</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;&lt;b&gt;no solution&lt;/b&gt;&quot;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">r</span> <span class="o">==</span> <span class="n">unknown</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;&lt;b&gt;failed to solve&lt;/b&gt;&quot;</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">model</span><span class="p">())</span>
        <span class="k">except</span> <span class="n">Z3Exception</span><span class="p">:</span>
            <span class="k">return</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">show</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;&lt;b&gt;Solution:&lt;/b&gt;&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">model</span><span class="p">())</span>


<span class="k">def</span> <span class="nf">_prove_html</span><span class="p">(</span><span class="n">claim</span><span class="p">,</span> <span class="n">show</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">keywords</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Version of function `prove` that renders HTML.&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">z3_debug</span><span class="p">():</span>
        <span class="n">_z3_assert</span><span class="p">(</span><span class="n">is_bool</span><span class="p">(</span><span class="n">claim</span><span class="p">),</span> <span class="s2">&quot;Z3 Boolean expression expected&quot;</span><span class="p">)</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">Solver</span><span class="p">()</span>
    <span class="n">s</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="o">**</span><span class="n">keywords</span><span class="p">)</span>
    <span class="n">s</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">Not</span><span class="p">(</span><span class="n">claim</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">show</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">check</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">r</span> <span class="o">==</span> <span class="n">unsat</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;&lt;b&gt;proved&lt;/b&gt;&quot;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">r</span> <span class="o">==</span> <span class="n">unknown</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;&lt;b&gt;failed to prove&lt;/b&gt;&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">model</span><span class="p">())</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;&lt;b&gt;counterexample&lt;/b&gt;&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">model</span><span class="p">())</span>


<span class="k">def</span> <span class="nf">_dict2sarray</span><span class="p">(</span><span class="n">sorts</span><span class="p">,</span> <span class="n">ctx</span><span class="p">):</span>
    <span class="n">sz</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">sorts</span><span class="p">)</span>
    <span class="n">_names</span> <span class="o">=</span> <span class="p">(</span><span class="n">Symbol</span> <span class="o">*</span> <span class="n">sz</span><span class="p">)()</span>
    <span class="n">_sorts</span> <span class="o">=</span> <span class="p">(</span><span class="n">Sort</span> <span class="o">*</span> <span class="n">sz</span><span class="p">)()</span>
    <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">sorts</span><span class="p">:</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">sorts</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">z3_debug</span><span class="p">():</span>
            <span class="n">_z3_assert</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="nb">str</span><span class="p">),</span> <span class="s2">&quot;String expected&quot;</span><span class="p">)</span>
            <span class="n">_z3_assert</span><span class="p">(</span><span class="n">is_sort</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="s2">&quot;Z3 sort expected&quot;</span><span class="p">)</span>
        <span class="n">_names</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">to_symbol</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">ctx</span><span class="p">)</span>
        <span class="n">_sorts</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">ast</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">sz</span><span class="p">,</span> <span class="n">_names</span><span class="p">,</span> <span class="n">_sorts</span>


<span class="k">def</span> <span class="nf">_dict2darray</span><span class="p">(</span><span class="n">decls</span><span class="p">,</span> <span class="n">ctx</span><span class="p">):</span>
    <span class="n">sz</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">decls</span><span class="p">)</span>
    <span class="n">_names</span> <span class="o">=</span> <span class="p">(</span><span class="n">Symbol</span> <span class="o">*</span> <span class="n">sz</span><span class="p">)()</span>
    <span class="n">_decls</span> <span class="o">=</span> <span class="p">(</span><span class="n">FuncDecl</span> <span class="o">*</span> <span class="n">sz</span><span class="p">)()</span>
    <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">decls</span><span class="p">:</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">decls</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">z3_debug</span><span class="p">():</span>
            <span class="n">_z3_assert</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="nb">str</span><span class="p">),</span> <span class="s2">&quot;String expected&quot;</span><span class="p">)</span>
            <span class="n">_z3_assert</span><span class="p">(</span><span class="n">is_func_decl</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="ow">or</span> <span class="n">is_const</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="s2">&quot;Z3 declaration or constant expected&quot;</span><span class="p">)</span>
        <span class="n">_names</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">to_symbol</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">ctx</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">is_const</span><span class="p">(</span><span class="n">v</span><span class="p">):</span>
            <span class="n">_decls</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">decl</span><span class="p">()</span><span class="o">.</span><span class="n">ast</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">_decls</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">ast</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">sz</span><span class="p">,</span> <span class="n">_names</span><span class="p">,</span> <span class="n">_decls</span>

<span class="k">class</span> <span class="nc">ParserContext</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ctx</span><span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span> <span class="o">=</span> <span class="n">_get_ctx</span><span class="p">(</span><span class="n">ctx</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pctx</span> <span class="o">=</span> <span class="n">Z3_mk_parser_context</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">())</span>
        <span class="n">Z3_parser_context_inc_ref</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">pctx</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__del__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">()</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">pctx</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">Z3_parser_context_dec_ref</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">Z3_parser_context_dec_ref</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">pctx</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pctx</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">add_sort</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sort</span><span class="p">):</span>
        <span class="n">Z3_parser_context_add_sort</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">pctx</span><span class="p">,</span> <span class="n">sort</span><span class="o">.</span><span class="n">as_ast</span><span class="p">())</span>

    <span class="k">def</span> <span class="nf">add_decl</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">decl</span><span class="p">):</span>
        <span class="n">Z3_parser_context_add_decl</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">pctx</span><span class="p">,</span> <span class="n">decl</span><span class="o">.</span><span class="n">as_ast</span><span class="p">())</span>

    <span class="k">def</span> <span class="nf">from_string</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">AstVector</span><span class="p">(</span><span class="n">Z3_parser_context_from_string</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">pctx</span><span class="p">,</span> <span class="n">s</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">parse_smt2_string</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">sorts</span><span class="o">=</span><span class="p">{},</span> <span class="n">decls</span><span class="o">=</span><span class="p">{},</span> <span class="n">ctx</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Parse a string in SMT 2.0 format using the given sorts and decls.</span>

<span class="sd">    The arguments sorts and decls are Python dictionaries used to initialize</span>
<span class="sd">    the symbol table used for the SMT 2.0 parser.</span>

<span class="sd">    &gt;&gt;&gt; parse_smt2_string(&#39;(declare-const x Int) (assert (&gt; x 0)) (assert (&lt; x 10))&#39;)</span>
<span class="sd">    [x &gt; 0, x &lt; 10]</span>
<span class="sd">    &gt;&gt;&gt; x, y = Ints(&#39;x y&#39;)</span>
<span class="sd">    &gt;&gt;&gt; f = Function(&#39;f&#39;, IntSort(), IntSort())</span>
<span class="sd">    &gt;&gt;&gt; parse_smt2_string(&#39;(assert (&gt; (+ foo (g bar)) 0))&#39;, decls={ &#39;foo&#39; : x, &#39;bar&#39; : y, &#39;g&#39; : f})</span>
<span class="sd">    [x + f(y) &gt; 0]</span>
<span class="sd">    &gt;&gt;&gt; parse_smt2_string(&#39;(declare-const a U) (assert (&gt; a 0))&#39;, sorts={ &#39;U&#39; : IntSort() })</span>
<span class="sd">    [a &gt; 0]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ctx</span> <span class="o">=</span> <span class="n">_get_ctx</span><span class="p">(</span><span class="n">ctx</span><span class="p">)</span>
    <span class="n">ssz</span><span class="p">,</span> <span class="n">snames</span><span class="p">,</span> <span class="n">ssorts</span> <span class="o">=</span> <span class="n">_dict2sarray</span><span class="p">(</span><span class="n">sorts</span><span class="p">,</span> <span class="n">ctx</span><span class="p">)</span>
    <span class="n">dsz</span><span class="p">,</span> <span class="n">dnames</span><span class="p">,</span> <span class="n">ddecls</span> <span class="o">=</span> <span class="n">_dict2darray</span><span class="p">(</span><span class="n">decls</span><span class="p">,</span> <span class="n">ctx</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">AstVector</span><span class="p">(</span><span class="n">Z3_parse_smtlib2_string</span><span class="p">(</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="n">s</span><span class="p">,</span> <span class="n">ssz</span><span class="p">,</span> <span class="n">snames</span><span class="p">,</span> <span class="n">ssorts</span><span class="p">,</span> <span class="n">dsz</span><span class="p">,</span> <span class="n">dnames</span><span class="p">,</span> <span class="n">ddecls</span><span class="p">),</span> <span class="n">ctx</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">parse_smt2_file</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">sorts</span><span class="o">=</span><span class="p">{},</span> <span class="n">decls</span><span class="o">=</span><span class="p">{},</span> <span class="n">ctx</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Parse a file in SMT 2.0 format using the given sorts and decls.</span>

<span class="sd">    This function is similar to parse_smt2_string().</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ctx</span> <span class="o">=</span> <span class="n">_get_ctx</span><span class="p">(</span><span class="n">ctx</span><span class="p">)</span>
    <span class="n">ssz</span><span class="p">,</span> <span class="n">snames</span><span class="p">,</span> <span class="n">ssorts</span> <span class="o">=</span> <span class="n">_dict2sarray</span><span class="p">(</span><span class="n">sorts</span><span class="p">,</span> <span class="n">ctx</span><span class="p">)</span>
    <span class="n">dsz</span><span class="p">,</span> <span class="n">dnames</span><span class="p">,</span> <span class="n">ddecls</span> <span class="o">=</span> <span class="n">_dict2darray</span><span class="p">(</span><span class="n">decls</span><span class="p">,</span> <span class="n">ctx</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">AstVector</span><span class="p">(</span><span class="n">Z3_parse_smtlib2_file</span><span class="p">(</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="n">f</span><span class="p">,</span> <span class="n">ssz</span><span class="p">,</span> <span class="n">snames</span><span class="p">,</span> <span class="n">ssorts</span><span class="p">,</span> <span class="n">dsz</span><span class="p">,</span> <span class="n">dnames</span><span class="p">,</span> <span class="n">ddecls</span><span class="p">),</span> <span class="n">ctx</span><span class="p">)</span>


<span class="c1">#########################################</span>
<span class="c1">#</span>
<span class="c1"># Floating-Point Arithmetic</span>
<span class="c1">#</span>
<span class="c1">#########################################</span>


<span class="c1"># Global default rounding mode</span>
<span class="n">_dflt_rounding_mode</span> <span class="o">=</span> <span class="n">Z3_OP_FPA_RM_NEAREST_TIES_TO_EVEN</span>
<span class="n">_dflt_fpsort_ebits</span> <span class="o">=</span> <span class="mi">11</span>
<span class="n">_dflt_fpsort_sbits</span> <span class="o">=</span> <span class="mi">53</span>


<span class="k">def</span> <span class="nf">get_default_rounding_mode</span><span class="p">(</span><span class="n">ctx</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Retrieves the global default rounding mode.&quot;&quot;&quot;</span>
    <span class="k">global</span> <span class="n">_dflt_rounding_mode</span>
    <span class="k">if</span> <span class="n">_dflt_rounding_mode</span> <span class="o">==</span> <span class="n">Z3_OP_FPA_RM_TOWARD_ZERO</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">RTZ</span><span class="p">(</span><span class="n">ctx</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">_dflt_rounding_mode</span> <span class="o">==</span> <span class="n">Z3_OP_FPA_RM_TOWARD_NEGATIVE</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">RTN</span><span class="p">(</span><span class="n">ctx</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">_dflt_rounding_mode</span> <span class="o">==</span> <span class="n">Z3_OP_FPA_RM_TOWARD_POSITIVE</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">RTP</span><span class="p">(</span><span class="n">ctx</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">_dflt_rounding_mode</span> <span class="o">==</span> <span class="n">Z3_OP_FPA_RM_NEAREST_TIES_TO_EVEN</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">RNE</span><span class="p">(</span><span class="n">ctx</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">_dflt_rounding_mode</span> <span class="o">==</span> <span class="n">Z3_OP_FPA_RM_NEAREST_TIES_TO_AWAY</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">RNA</span><span class="p">(</span><span class="n">ctx</span><span class="p">)</span>


<span class="n">_ROUNDING_MODES</span> <span class="o">=</span> <span class="nb">frozenset</span><span class="p">({</span>
    <span class="n">Z3_OP_FPA_RM_TOWARD_ZERO</span><span class="p">,</span>
    <span class="n">Z3_OP_FPA_RM_TOWARD_NEGATIVE</span><span class="p">,</span>
    <span class="n">Z3_OP_FPA_RM_TOWARD_POSITIVE</span><span class="p">,</span>
    <span class="n">Z3_OP_FPA_RM_NEAREST_TIES_TO_EVEN</span><span class="p">,</span>
    <span class="n">Z3_OP_FPA_RM_NEAREST_TIES_TO_AWAY</span>
<span class="p">})</span>


<span class="k">def</span> <span class="nf">set_default_rounding_mode</span><span class="p">(</span><span class="n">rm</span><span class="p">,</span> <span class="n">ctx</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="k">global</span> <span class="n">_dflt_rounding_mode</span>
    <span class="k">if</span> <span class="n">is_fprm_value</span><span class="p">(</span><span class="n">rm</span><span class="p">):</span>
        <span class="n">_dflt_rounding_mode</span> <span class="o">=</span> <span class="n">rm</span><span class="o">.</span><span class="n">decl</span><span class="p">()</span><span class="o">.</span><span class="n">kind</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">_z3_assert</span><span class="p">(</span><span class="n">_dflt_rounding_mode</span> <span class="ow">in</span> <span class="n">_ROUNDING_MODES</span><span class="p">,</span> <span class="s2">&quot;illegal rounding mode&quot;</span><span class="p">)</span>
        <span class="n">_dflt_rounding_mode</span> <span class="o">=</span> <span class="n">rm</span>


<span class="k">def</span> <span class="nf">get_default_fp_sort</span><span class="p">(</span><span class="n">ctx</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">FPSort</span><span class="p">(</span><span class="n">_dflt_fpsort_ebits</span><span class="p">,</span> <span class="n">_dflt_fpsort_sbits</span><span class="p">,</span> <span class="n">ctx</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">set_default_fp_sort</span><span class="p">(</span><span class="n">ebits</span><span class="p">,</span> <span class="n">sbits</span><span class="p">,</span> <span class="n">ctx</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="k">global</span> <span class="n">_dflt_fpsort_ebits</span>
    <span class="k">global</span> <span class="n">_dflt_fpsort_sbits</span>
    <span class="n">_dflt_fpsort_ebits</span> <span class="o">=</span> <span class="n">ebits</span>
    <span class="n">_dflt_fpsort_sbits</span> <span class="o">=</span> <span class="n">sbits</span>


<span class="k">def</span> <span class="nf">_dflt_rm</span><span class="p">(</span><span class="n">ctx</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">get_default_rounding_mode</span><span class="p">(</span><span class="n">ctx</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_dflt_fps</span><span class="p">(</span><span class="n">ctx</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">get_default_fp_sort</span><span class="p">(</span><span class="n">ctx</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_coerce_fp_expr_list</span><span class="p">(</span><span class="n">alist</span><span class="p">,</span> <span class="n">ctx</span><span class="p">):</span>
    <span class="n">first_fp_sort</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">alist</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">is_fp</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">first_fp_sort</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">first_fp_sort</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
            <span class="k">elif</span> <span class="n">first_fp_sort</span> <span class="o">==</span> <span class="n">a</span><span class="o">.</span><span class="n">sort</span><span class="p">():</span>
                <span class="k">pass</span>  <span class="c1"># OK, same as before</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># we saw at least 2 different float sorts; something will</span>
                <span class="c1"># throw a sort mismatch later, for now assume None.</span>
                <span class="n">first_fp_sort</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="k">break</span>

    <span class="n">r</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">alist</span><span class="p">)):</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">alist</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">is_repr</span> <span class="o">=</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">and</span> <span class="n">a</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="s2">&quot;2**(&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">a</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s2">&quot;)&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">is_repr</span> <span class="ow">or</span> <span class="n">_is_int</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="nb">bool</span><span class="p">)):</span>
            <span class="n">r</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">FPVal</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">first_fp_sort</span><span class="p">,</span> <span class="n">ctx</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">r</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">_coerce_expr_list</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">ctx</span><span class="p">)</span>


<span class="c1"># FP Sorts</span>

<span class="k">class</span> <span class="nc">FPSortRef</span><span class="p">(</span><span class="n">SortRef</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Floating-point sort.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">ebits</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Retrieves the number of bits reserved for the exponent in the FloatingPoint sort `self`.</span>
<span class="sd">        &gt;&gt;&gt; b = FPSort(8, 24)</span>
<span class="sd">        &gt;&gt;&gt; b.ebits()</span>
<span class="sd">        8</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">Z3_fpa_get_ebits</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx_ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">ast</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">sbits</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Retrieves the number of bits reserved for the significand in the FloatingPoint sort `self`.</span>
<span class="sd">        &gt;&gt;&gt; b = FPSort(8, 24)</span>
<span class="sd">        &gt;&gt;&gt; b.sbits()</span>
<span class="sd">        24</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">Z3_fpa_get_sbits</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx_ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">ast</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">cast</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Try to cast `val` as a floating-point expression.</span>
<span class="sd">        &gt;&gt;&gt; b = FPSort(8, 24)</span>
<span class="sd">        &gt;&gt;&gt; b.cast(1.0)</span>
<span class="sd">        1</span>
<span class="sd">        &gt;&gt;&gt; b.cast(1.0).sexpr()</span>
<span class="sd">        &#39;(fp #b0 #x7f #b00000000000000000000000)&#39;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">is_expr</span><span class="p">(</span><span class="n">val</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">z3_debug</span><span class="p">():</span>
                <span class="n">_z3_assert</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span> <span class="o">==</span> <span class="n">val</span><span class="o">.</span><span class="n">ctx</span><span class="p">,</span> <span class="s2">&quot;Context mismatch&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">val</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">FPVal</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">Float16</span><span class="p">(</span><span class="n">ctx</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Floating-point 16-bit (half) sort.&quot;&quot;&quot;</span>
    <span class="n">ctx</span> <span class="o">=</span> <span class="n">_get_ctx</span><span class="p">(</span><span class="n">ctx</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">FPSortRef</span><span class="p">(</span><span class="n">Z3_mk_fpa_sort_16</span><span class="p">(</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">()),</span> <span class="n">ctx</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">FloatHalf</span><span class="p">(</span><span class="n">ctx</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Floating-point 16-bit (half) sort.&quot;&quot;&quot;</span>
    <span class="n">ctx</span> <span class="o">=</span> <span class="n">_get_ctx</span><span class="p">(</span><span class="n">ctx</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">FPSortRef</span><span class="p">(</span><span class="n">Z3_mk_fpa_sort_half</span><span class="p">(</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">()),</span> <span class="n">ctx</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">Float32</span><span class="p">(</span><span class="n">ctx</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Floating-point 32-bit (single) sort.&quot;&quot;&quot;</span>
    <span class="n">ctx</span> <span class="o">=</span> <span class="n">_get_ctx</span><span class="p">(</span><span class="n">ctx</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">FPSortRef</span><span class="p">(</span><span class="n">Z3_mk_fpa_sort_32</span><span class="p">(</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">()),</span> <span class="n">ctx</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">FloatSingle</span><span class="p">(</span><span class="n">ctx</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Floating-point 32-bit (single) sort.&quot;&quot;&quot;</span>
    <span class="n">ctx</span> <span class="o">=</span> <span class="n">_get_ctx</span><span class="p">(</span><span class="n">ctx</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">FPSortRef</span><span class="p">(</span><span class="n">Z3_mk_fpa_sort_single</span><span class="p">(</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">()),</span> <span class="n">ctx</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">Float64</span><span class="p">(</span><span class="n">ctx</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Floating-point 64-bit (double) sort.&quot;&quot;&quot;</span>
    <span class="n">ctx</span> <span class="o">=</span> <span class="n">_get_ctx</span><span class="p">(</span><span class="n">ctx</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">FPSortRef</span><span class="p">(</span><span class="n">Z3_mk_fpa_sort_64</span><span class="p">(</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">()),</span> <span class="n">ctx</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">FloatDouble</span><span class="p">(</span><span class="n">ctx</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Floating-point 64-bit (double) sort.&quot;&quot;&quot;</span>
    <span class="n">ctx</span> <span class="o">=</span> <span class="n">_get_ctx</span><span class="p">(</span><span class="n">ctx</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">FPSortRef</span><span class="p">(</span><span class="n">Z3_mk_fpa_sort_double</span><span class="p">(</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">()),</span> <span class="n">ctx</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">Float128</span><span class="p">(</span><span class="n">ctx</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Floating-point 128-bit (quadruple) sort.&quot;&quot;&quot;</span>
    <span class="n">ctx</span> <span class="o">=</span> <span class="n">_get_ctx</span><span class="p">(</span><span class="n">ctx</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">FPSortRef</span><span class="p">(</span><span class="n">Z3_mk_fpa_sort_128</span><span class="p">(</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">()),</span> <span class="n">ctx</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">FloatQuadruple</span><span class="p">(</span><span class="n">ctx</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Floating-point 128-bit (quadruple) sort.&quot;&quot;&quot;</span>
    <span class="n">ctx</span> <span class="o">=</span> <span class="n">_get_ctx</span><span class="p">(</span><span class="n">ctx</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">FPSortRef</span><span class="p">(</span><span class="n">Z3_mk_fpa_sort_quadruple</span><span class="p">(</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">()),</span> <span class="n">ctx</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">FPRMSortRef</span><span class="p">(</span><span class="n">SortRef</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;&quot;Floating-point rounding mode sort.&quot;&quot;&quot;</span>


<span class="k">def</span> <span class="nf">is_fp_sort</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return True if `s` is a Z3 floating-point sort.</span>

<span class="sd">    &gt;&gt;&gt; is_fp_sort(FPSort(8, 24))</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; is_fp_sort(IntSort())</span>
<span class="sd">    False</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">FPSortRef</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">is_fprm_sort</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return True if `s` is a Z3 floating-point rounding mode sort.</span>

<span class="sd">    &gt;&gt;&gt; is_fprm_sort(FPSort(8, 24))</span>
<span class="sd">    False</span>
<span class="sd">    &gt;&gt;&gt; is_fprm_sort(RNE().sort())</span>
<span class="sd">    True</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">FPRMSortRef</span><span class="p">)</span>

<span class="c1"># FP Expressions</span>


<span class="k">class</span> <span class="nc">FPRef</span><span class="p">(</span><span class="n">ExprRef</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Floating-point expressions.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">sort</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the sort of the floating-point expression `self`.</span>

<span class="sd">        &gt;&gt;&gt; x = FP(&#39;1.0&#39;, FPSort(8, 24))</span>
<span class="sd">        &gt;&gt;&gt; x.sort()</span>
<span class="sd">        FPSort(8, 24)</span>
<span class="sd">        &gt;&gt;&gt; x.sort() == FPSort(8, 24)</span>
<span class="sd">        True</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">FPSortRef</span><span class="p">(</span><span class="n">Z3_get_sort</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx_ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_ast</span><span class="p">()),</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">ebits</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Retrieves the number of bits reserved for the exponent in the FloatingPoint expression `self`.</span>
<span class="sd">        &gt;&gt;&gt; b = FPSort(8, 24)</span>
<span class="sd">        &gt;&gt;&gt; b.ebits()</span>
<span class="sd">        8</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span><span class="o">.</span><span class="n">ebits</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">sbits</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Retrieves the number of bits reserved for the exponent in the FloatingPoint expression `self`.</span>
<span class="sd">        &gt;&gt;&gt; b = FPSort(8, 24)</span>
<span class="sd">        &gt;&gt;&gt; b.sbits()</span>
<span class="sd">        24</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span><span class="o">.</span><span class="n">sbits</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">as_string</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a Z3 floating point expression as a Python string.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Z3_ast_to_string</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx_ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_ast</span><span class="p">())</span>

    <span class="k">def</span> <span class="fm">__le__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">fpLEQ</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__lt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">fpLT</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__ge__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">fpGEQ</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__gt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">fpGT</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create the Z3 expression `self + other`.</span>

<span class="sd">        &gt;&gt;&gt; x = FP(&#39;x&#39;, FPSort(8, 24))</span>
<span class="sd">        &gt;&gt;&gt; y = FP(&#39;y&#39;, FPSort(8, 24))</span>
<span class="sd">        &gt;&gt;&gt; x + y</span>
<span class="sd">        x + y</span>
<span class="sd">        &gt;&gt;&gt; (x + y).sort()</span>
<span class="sd">        FPSort(8, 24)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="p">[</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">]</span> <span class="o">=</span> <span class="n">_coerce_fp_expr_list</span><span class="p">([</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">fpAdd</span><span class="p">(</span><span class="n">_dflt_rm</span><span class="p">(),</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__radd__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create the Z3 expression `other + self`.</span>

<span class="sd">        &gt;&gt;&gt; x = FP(&#39;x&#39;, FPSort(8, 24))</span>
<span class="sd">        &gt;&gt;&gt; 10 + x</span>
<span class="sd">        1.25*(2**3) + x</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="p">[</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">]</span> <span class="o">=</span> <span class="n">_coerce_fp_expr_list</span><span class="p">([</span><span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">fpAdd</span><span class="p">(</span><span class="n">_dflt_rm</span><span class="p">(),</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__sub__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create the Z3 expression `self - other`.</span>

<span class="sd">        &gt;&gt;&gt; x = FP(&#39;x&#39;, FPSort(8, 24))</span>
<span class="sd">        &gt;&gt;&gt; y = FP(&#39;y&#39;, FPSort(8, 24))</span>
<span class="sd">        &gt;&gt;&gt; x - y</span>
<span class="sd">        x - y</span>
<span class="sd">        &gt;&gt;&gt; (x - y).sort()</span>
<span class="sd">        FPSort(8, 24)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="p">[</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">]</span> <span class="o">=</span> <span class="n">_coerce_fp_expr_list</span><span class="p">([</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">fpSub</span><span class="p">(</span><span class="n">_dflt_rm</span><span class="p">(),</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__rsub__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create the Z3 expression `other - self`.</span>

<span class="sd">        &gt;&gt;&gt; x = FP(&#39;x&#39;, FPSort(8, 24))</span>
<span class="sd">        &gt;&gt;&gt; 10 - x</span>
<span class="sd">        1.25*(2**3) - x</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="p">[</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">]</span> <span class="o">=</span> <span class="n">_coerce_fp_expr_list</span><span class="p">([</span><span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">fpSub</span><span class="p">(</span><span class="n">_dflt_rm</span><span class="p">(),</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__mul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create the Z3 expression `self * other`.</span>

<span class="sd">        &gt;&gt;&gt; x = FP(&#39;x&#39;, FPSort(8, 24))</span>
<span class="sd">        &gt;&gt;&gt; y = FP(&#39;y&#39;, FPSort(8, 24))</span>
<span class="sd">        &gt;&gt;&gt; x * y</span>
<span class="sd">        x * y</span>
<span class="sd">        &gt;&gt;&gt; (x * y).sort()</span>
<span class="sd">        FPSort(8, 24)</span>
<span class="sd">        &gt;&gt;&gt; 10 * y</span>
<span class="sd">        1.25*(2**3) * y</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="p">[</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">]</span> <span class="o">=</span> <span class="n">_coerce_fp_expr_list</span><span class="p">([</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">fpMul</span><span class="p">(</span><span class="n">_dflt_rm</span><span class="p">(),</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__rmul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create the Z3 expression `other * self`.</span>

<span class="sd">        &gt;&gt;&gt; x = FP(&#39;x&#39;, FPSort(8, 24))</span>
<span class="sd">        &gt;&gt;&gt; y = FP(&#39;y&#39;, FPSort(8, 24))</span>
<span class="sd">        &gt;&gt;&gt; x * y</span>
<span class="sd">        x * y</span>
<span class="sd">        &gt;&gt;&gt; x * 10</span>
<span class="sd">        x * 1.25*(2**3)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="p">[</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">]</span> <span class="o">=</span> <span class="n">_coerce_fp_expr_list</span><span class="p">([</span><span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">fpMul</span><span class="p">(</span><span class="n">_dflt_rm</span><span class="p">(),</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__pos__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create the Z3 expression `+self`.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="fm">__neg__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create the Z3 expression `-self`.</span>

<span class="sd">        &gt;&gt;&gt; x = FP(&#39;x&#39;, Float32())</span>
<span class="sd">        &gt;&gt;&gt; -x</span>
<span class="sd">        -x</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">fpNeg</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__div__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create the Z3 expression `self / other`.</span>

<span class="sd">        &gt;&gt;&gt; x = FP(&#39;x&#39;, FPSort(8, 24))</span>
<span class="sd">        &gt;&gt;&gt; y = FP(&#39;y&#39;, FPSort(8, 24))</span>
<span class="sd">        &gt;&gt;&gt; x / y</span>
<span class="sd">        x / y</span>
<span class="sd">        &gt;&gt;&gt; (x / y).sort()</span>
<span class="sd">        FPSort(8, 24)</span>
<span class="sd">        &gt;&gt;&gt; 10 / y</span>
<span class="sd">        1.25*(2**3) / y</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="p">[</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">]</span> <span class="o">=</span> <span class="n">_coerce_fp_expr_list</span><span class="p">([</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">fpDiv</span><span class="p">(</span><span class="n">_dflt_rm</span><span class="p">(),</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__rdiv__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create the Z3 expression `other / self`.</span>

<span class="sd">        &gt;&gt;&gt; x = FP(&#39;x&#39;, FPSort(8, 24))</span>
<span class="sd">        &gt;&gt;&gt; y = FP(&#39;y&#39;, FPSort(8, 24))</span>
<span class="sd">        &gt;&gt;&gt; x / y</span>
<span class="sd">        x / y</span>
<span class="sd">        &gt;&gt;&gt; x / 10</span>
<span class="sd">        x / 1.25*(2**3)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="p">[</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">]</span> <span class="o">=</span> <span class="n">_coerce_fp_expr_list</span><span class="p">([</span><span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">fpDiv</span><span class="p">(</span><span class="n">_dflt_rm</span><span class="p">(),</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__truediv__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create the Z3 expression division `self / other`.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__div__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__rtruediv__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create the Z3 expression division `other / self`.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__rdiv__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__mod__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create the Z3 expression mod `self % other`.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">fpRem</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__rmod__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create the Z3 expression mod `other % self`.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">fpRem</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">FPRMRef</span><span class="p">(</span><span class="n">ExprRef</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Floating-point rounding mode expressions&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">as_string</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a Z3 floating point expression as a Python string.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Z3_ast_to_string</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx_ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_ast</span><span class="p">())</span>


<span class="k">def</span> <span class="nf">RoundNearestTiesToEven</span><span class="p">(</span><span class="n">ctx</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="n">ctx</span> <span class="o">=</span> <span class="n">_get_ctx</span><span class="p">(</span><span class="n">ctx</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">FPRMRef</span><span class="p">(</span><span class="n">Z3_mk_fpa_round_nearest_ties_to_even</span><span class="p">(</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">()),</span> <span class="n">ctx</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">RNE</span><span class="p">(</span><span class="n">ctx</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="n">ctx</span> <span class="o">=</span> <span class="n">_get_ctx</span><span class="p">(</span><span class="n">ctx</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">FPRMRef</span><span class="p">(</span><span class="n">Z3_mk_fpa_round_nearest_ties_to_even</span><span class="p">(</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">()),</span> <span class="n">ctx</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">RoundNearestTiesToAway</span><span class="p">(</span><span class="n">ctx</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="n">ctx</span> <span class="o">=</span> <span class="n">_get_ctx</span><span class="p">(</span><span class="n">ctx</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">FPRMRef</span><span class="p">(</span><span class="n">Z3_mk_fpa_round_nearest_ties_to_away</span><span class="p">(</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">()),</span> <span class="n">ctx</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">RNA</span><span class="p">(</span><span class="n">ctx</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="n">ctx</span> <span class="o">=</span> <span class="n">_get_ctx</span><span class="p">(</span><span class="n">ctx</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">FPRMRef</span><span class="p">(</span><span class="n">Z3_mk_fpa_round_nearest_ties_to_away</span><span class="p">(</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">()),</span> <span class="n">ctx</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">RoundTowardPositive</span><span class="p">(</span><span class="n">ctx</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="n">ctx</span> <span class="o">=</span> <span class="n">_get_ctx</span><span class="p">(</span><span class="n">ctx</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">FPRMRef</span><span class="p">(</span><span class="n">Z3_mk_fpa_round_toward_positive</span><span class="p">(</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">()),</span> <span class="n">ctx</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">RTP</span><span class="p">(</span><span class="n">ctx</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="n">ctx</span> <span class="o">=</span> <span class="n">_get_ctx</span><span class="p">(</span><span class="n">ctx</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">FPRMRef</span><span class="p">(</span><span class="n">Z3_mk_fpa_round_toward_positive</span><span class="p">(</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">()),</span> <span class="n">ctx</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">RoundTowardNegative</span><span class="p">(</span><span class="n">ctx</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="n">ctx</span> <span class="o">=</span> <span class="n">_get_ctx</span><span class="p">(</span><span class="n">ctx</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">FPRMRef</span><span class="p">(</span><span class="n">Z3_mk_fpa_round_toward_negative</span><span class="p">(</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">()),</span> <span class="n">ctx</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">RTN</span><span class="p">(</span><span class="n">ctx</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="n">ctx</span> <span class="o">=</span> <span class="n">_get_ctx</span><span class="p">(</span><span class="n">ctx</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">FPRMRef</span><span class="p">(</span><span class="n">Z3_mk_fpa_round_toward_negative</span><span class="p">(</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">()),</span> <span class="n">ctx</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">RoundTowardZero</span><span class="p">(</span><span class="n">ctx</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="n">ctx</span> <span class="o">=</span> <span class="n">_get_ctx</span><span class="p">(</span><span class="n">ctx</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">FPRMRef</span><span class="p">(</span><span class="n">Z3_mk_fpa_round_toward_zero</span><span class="p">(</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">()),</span> <span class="n">ctx</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">RTZ</span><span class="p">(</span><span class="n">ctx</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="n">ctx</span> <span class="o">=</span> <span class="n">_get_ctx</span><span class="p">(</span><span class="n">ctx</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">FPRMRef</span><span class="p">(</span><span class="n">Z3_mk_fpa_round_toward_zero</span><span class="p">(</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">()),</span> <span class="n">ctx</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">is_fprm</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return `True` if `a` is a Z3 floating-point rounding mode expression.</span>

<span class="sd">    &gt;&gt;&gt; rm = RNE()</span>
<span class="sd">    &gt;&gt;&gt; is_fprm(rm)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; rm = 1.0</span>
<span class="sd">    &gt;&gt;&gt; is_fprm(rm)</span>
<span class="sd">    False</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">FPRMRef</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">is_fprm_value</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return `True` if `a` is a Z3 floating-point rounding mode numeral value.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">is_fprm</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="ow">and</span> <span class="n">_is_numeral</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">ctx</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">ast</span><span class="p">)</span>

<span class="c1"># FP Numerals</span>


<span class="k">class</span> <span class="nc">FPNumRef</span><span class="p">(</span><span class="n">FPRef</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;The sign of the numeral.</span>

<span class="sd">    &gt;&gt;&gt; x = FPVal(+1.0, FPSort(8, 24))</span>
<span class="sd">    &gt;&gt;&gt; x.sign()</span>
<span class="sd">    False</span>
<span class="sd">    &gt;&gt;&gt; x = FPVal(-1.0, FPSort(8, 24))</span>
<span class="sd">    &gt;&gt;&gt; x.sign()</span>
<span class="sd">    True</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">sign</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">num</span> <span class="o">=</span> <span class="p">(</span><span class="n">ctypes</span><span class="o">.</span><span class="n">c_int</span><span class="p">)()</span>
        <span class="n">nsign</span> <span class="o">=</span> <span class="n">Z3_fpa_get_numeral_sign</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_ast</span><span class="p">(),</span> <span class="n">byref</span><span class="p">(</span><span class="n">num</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">nsign</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">Z3Exception</span><span class="p">(</span><span class="s2">&quot;error retrieving the sign of a numeral.&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">num</span><span class="o">.</span><span class="n">value</span> <span class="o">!=</span> <span class="mi">0</span>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;The sign of a floating-point numeral as a bit-vector expression.</span>

<span class="sd">    Remark: NaN&#39;s are invalid arguments.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">sign_as_bv</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">BitVecNumRef</span><span class="p">(</span><span class="n">Z3_fpa_get_numeral_sign_bv</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_ast</span><span class="p">()),</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;The significand of the numeral.</span>

<span class="sd">    &gt;&gt;&gt; x = FPVal(2.5, FPSort(8, 24))</span>
<span class="sd">    &gt;&gt;&gt; x.significand()</span>
<span class="sd">    1.25</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">significand</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Z3_fpa_get_numeral_significand_string</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_ast</span><span class="p">())</span>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;The significand of the numeral as a long.</span>

<span class="sd">    &gt;&gt;&gt; x = FPVal(2.5, FPSort(8, 24))</span>
<span class="sd">    &gt;&gt;&gt; x.significand_as_long()</span>
<span class="sd">    1.25</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">significand_as_long</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">ptr</span> <span class="o">=</span> <span class="p">(</span><span class="n">ctypes</span><span class="o">.</span><span class="n">c_ulonglong</span> <span class="o">*</span> <span class="mi">1</span><span class="p">)()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">Z3_fpa_get_numeral_significand_uint64</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_ast</span><span class="p">(),</span> <span class="n">ptr</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">Z3Exception</span><span class="p">(</span><span class="s2">&quot;error retrieving the significand of a numeral.&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ptr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;The significand of the numeral as a bit-vector expression.</span>

<span class="sd">    Remark: NaN are invalid arguments.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">significand_as_bv</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">BitVecNumRef</span><span class="p">(</span><span class="n">Z3_fpa_get_numeral_significand_bv</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_ast</span><span class="p">()),</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;The exponent of the numeral.</span>

<span class="sd">    &gt;&gt;&gt; x = FPVal(2.5, FPSort(8, 24))</span>
<span class="sd">    &gt;&gt;&gt; x.exponent()</span>
<span class="sd">    1</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">exponent</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">biased</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Z3_fpa_get_numeral_exponent_string</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_ast</span><span class="p">(),</span> <span class="n">biased</span><span class="p">)</span>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;The exponent of the numeral as a long.</span>

<span class="sd">    &gt;&gt;&gt; x = FPVal(2.5, FPSort(8, 24))</span>
<span class="sd">    &gt;&gt;&gt; x.exponent_as_long()</span>
<span class="sd">    1</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">exponent_as_long</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">biased</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="n">ptr</span> <span class="o">=</span> <span class="p">(</span><span class="n">ctypes</span><span class="o">.</span><span class="n">c_longlong</span> <span class="o">*</span> <span class="mi">1</span><span class="p">)()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">Z3_fpa_get_numeral_exponent_int64</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_ast</span><span class="p">(),</span> <span class="n">ptr</span><span class="p">,</span> <span class="n">biased</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">Z3Exception</span><span class="p">(</span><span class="s2">&quot;error retrieving the exponent of a numeral.&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ptr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;The exponent of the numeral as a bit-vector expression.</span>

<span class="sd">    Remark: NaNs are invalid arguments.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">exponent_as_bv</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">biased</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">BitVecNumRef</span><span class="p">(</span><span class="n">Z3_fpa_get_numeral_exponent_bv</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_ast</span><span class="p">(),</span> <span class="n">biased</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;Indicates whether the numeral is a NaN.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">isNaN</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Z3_fpa_is_numeral_nan</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_ast</span><span class="p">())</span>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;Indicates whether the numeral is +oo or -oo.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">isInf</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Z3_fpa_is_numeral_inf</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_ast</span><span class="p">())</span>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;Indicates whether the numeral is +zero or -zero.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">isZero</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Z3_fpa_is_numeral_zero</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_ast</span><span class="p">())</span>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;Indicates whether the numeral is normal.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">isNormal</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Z3_fpa_is_numeral_normal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_ast</span><span class="p">())</span>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;Indicates whether the numeral is subnormal.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">isSubnormal</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Z3_fpa_is_numeral_subnormal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_ast</span><span class="p">())</span>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;Indicates whether the numeral is positive.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">isPositive</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Z3_fpa_is_numeral_positive</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_ast</span><span class="p">())</span>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;Indicates whether the numeral is negative.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">isNegative</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Z3_fpa_is_numeral_negative</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_ast</span><span class="p">())</span>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The string representation of the numeral.</span>

<span class="sd">    &gt;&gt;&gt; x = FPVal(20, FPSort(8, 24))</span>
<span class="sd">    &gt;&gt;&gt; x.as_string()</span>
<span class="sd">    1.25*(2**4)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">as_string</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">Z3_get_numeral_string</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_ast</span><span class="p">())</span>
        <span class="k">return</span> <span class="p">(</span><span class="s2">&quot;FPVal(</span><span class="si">%s</span><span class="s2">, </span><span class="si">%s</span><span class="s2">)&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sort</span><span class="p">()))</span>


<span class="k">def</span> <span class="nf">is_fp</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return `True` if `a` is a Z3 floating-point expression.</span>

<span class="sd">    &gt;&gt;&gt; b = FP(&#39;b&#39;, FPSort(8, 24))</span>
<span class="sd">    &gt;&gt;&gt; is_fp(b)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; is_fp(b + 1.0)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; is_fp(Int(&#39;x&#39;))</span>
<span class="sd">    False</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">FPRef</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">is_fp_value</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return `True` if `a` is a Z3 floating-point numeral value.</span>

<span class="sd">    &gt;&gt;&gt; b = FP(&#39;b&#39;, FPSort(8, 24))</span>
<span class="sd">    &gt;&gt;&gt; is_fp_value(b)</span>
<span class="sd">    False</span>
<span class="sd">    &gt;&gt;&gt; b = FPVal(1.0, FPSort(8, 24))</span>
<span class="sd">    &gt;&gt;&gt; b</span>
<span class="sd">    1</span>
<span class="sd">    &gt;&gt;&gt; is_fp_value(b)</span>
<span class="sd">    True</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">is_fp</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="ow">and</span> <span class="n">_is_numeral</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">ctx</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">ast</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">FPSort</span><span class="p">(</span><span class="n">ebits</span><span class="p">,</span> <span class="n">sbits</span><span class="p">,</span> <span class="n">ctx</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return a Z3 floating-point sort of the given sizes. If `ctx=None`, then the global context is used.</span>

<span class="sd">    &gt;&gt;&gt; Single = FPSort(8, 24)</span>
<span class="sd">    &gt;&gt;&gt; Double = FPSort(11, 53)</span>
<span class="sd">    &gt;&gt;&gt; Single</span>
<span class="sd">    FPSort(8, 24)</span>
<span class="sd">    &gt;&gt;&gt; x = Const(&#39;x&#39;, Single)</span>
<span class="sd">    &gt;&gt;&gt; eq(x, FP(&#39;x&#39;, FPSort(8, 24)))</span>
<span class="sd">    True</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ctx</span> <span class="o">=</span> <span class="n">_get_ctx</span><span class="p">(</span><span class="n">ctx</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">FPSortRef</span><span class="p">(</span><span class="n">Z3_mk_fpa_sort</span><span class="p">(</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="n">ebits</span><span class="p">,</span> <span class="n">sbits</span><span class="p">),</span> <span class="n">ctx</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_to_float_str</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">exp</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="nb">float</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">math</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">val</span><span class="p">):</span>
            <span class="n">res</span> <span class="o">=</span> <span class="s2">&quot;NaN&quot;</span>
        <span class="k">elif</span> <span class="n">val</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">:</span>
            <span class="n">sone</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">copysign</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">sone</span> <span class="o">&lt;</span> <span class="mf">0.0</span><span class="p">:</span>
                <span class="k">return</span> <span class="s2">&quot;-0.0&quot;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="s2">&quot;+0.0&quot;</span>
        <span class="k">elif</span> <span class="n">val</span> <span class="o">==</span> <span class="nb">float</span><span class="p">(</span><span class="s2">&quot;+inf&quot;</span><span class="p">):</span>
            <span class="n">res</span> <span class="o">=</span> <span class="s2">&quot;+oo&quot;</span>
        <span class="k">elif</span> <span class="n">val</span> <span class="o">==</span> <span class="nb">float</span><span class="p">(</span><span class="s2">&quot;-inf&quot;</span><span class="p">):</span>
            <span class="n">res</span> <span class="o">=</span> <span class="s2">&quot;-oo&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">v</span> <span class="o">=</span> <span class="n">val</span><span class="o">.</span><span class="n">as_integer_ratio</span><span class="p">()</span>
            <span class="n">num</span> <span class="o">=</span> <span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">den</span> <span class="o">=</span> <span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">rvs</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">num</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;/&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">den</span><span class="p">)</span>
            <span class="n">res</span> <span class="o">=</span> <span class="n">rvs</span> <span class="o">+</span> <span class="s2">&quot;p&quot;</span> <span class="o">+</span> <span class="n">_to_int_str</span><span class="p">(</span><span class="n">exp</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">val</span><span class="p">:</span>
            <span class="n">res</span> <span class="o">=</span> <span class="s2">&quot;1.0&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">res</span> <span class="o">=</span> <span class="s2">&quot;0.0&quot;</span>
    <span class="k">elif</span> <span class="n">_is_int</span><span class="p">(</span><span class="n">val</span><span class="p">):</span>
        <span class="n">res</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="n">inx</span> <span class="o">=</span> <span class="n">val</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s2">&quot;*(2**&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">inx</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">res</span> <span class="o">=</span> <span class="n">val</span>
        <span class="k">elif</span> <span class="n">val</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;)&quot;</span><span class="p">:</span>
            <span class="n">res</span> <span class="o">=</span> <span class="n">val</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">inx</span><span class="p">]</span>
            <span class="n">exp</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">val</span><span class="p">[</span><span class="n">inx</span> <span class="o">+</span> <span class="mi">5</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="nb">int</span><span class="p">(</span><span class="n">exp</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">_z3_assert</span><span class="p">(</span><span class="kc">False</span><span class="p">,</span> <span class="s2">&quot;String does not have floating-point numeral form.&quot;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">z3_debug</span><span class="p">():</span>
        <span class="n">_z3_assert</span><span class="p">(</span><span class="kc">False</span><span class="p">,</span> <span class="s2">&quot;Python value cannot be used to create floating-point numerals.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">exp</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">res</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">res</span> <span class="o">+</span> <span class="s2">&quot;p&quot;</span> <span class="o">+</span> <span class="n">exp</span>


<span class="k">def</span> <span class="nf">fpNaN</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Create a Z3 floating-point NaN term.</span>

<span class="sd">    &gt;&gt;&gt; s = FPSort(8, 24)</span>
<span class="sd">    &gt;&gt;&gt; set_fpa_pretty(True)</span>
<span class="sd">    &gt;&gt;&gt; fpNaN(s)</span>
<span class="sd">    NaN</span>
<span class="sd">    &gt;&gt;&gt; pb = get_fpa_pretty()</span>
<span class="sd">    &gt;&gt;&gt; set_fpa_pretty(False)</span>
<span class="sd">    &gt;&gt;&gt; fpNaN(s)</span>
<span class="sd">    fpNaN(FPSort(8, 24))</span>
<span class="sd">    &gt;&gt;&gt; set_fpa_pretty(pb)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_z3_assert</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">FPSortRef</span><span class="p">),</span> <span class="s2">&quot;sort mismatch&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">FPNumRef</span><span class="p">(</span><span class="n">Z3_mk_fpa_nan</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">ctx_ref</span><span class="p">(),</span> <span class="n">s</span><span class="o">.</span><span class="n">ast</span><span class="p">),</span> <span class="n">s</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">fpPlusInfinity</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Create a Z3 floating-point +oo term.</span>

<span class="sd">    &gt;&gt;&gt; s = FPSort(8, 24)</span>
<span class="sd">    &gt;&gt;&gt; pb = get_fpa_pretty()</span>
<span class="sd">    &gt;&gt;&gt; set_fpa_pretty(True)</span>
<span class="sd">    &gt;&gt;&gt; fpPlusInfinity(s)</span>
<span class="sd">    +oo</span>
<span class="sd">    &gt;&gt;&gt; set_fpa_pretty(False)</span>
<span class="sd">    &gt;&gt;&gt; fpPlusInfinity(s)</span>
<span class="sd">    fpPlusInfinity(FPSort(8, 24))</span>
<span class="sd">    &gt;&gt;&gt; set_fpa_pretty(pb)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_z3_assert</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">FPSortRef</span><span class="p">),</span> <span class="s2">&quot;sort mismatch&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">FPNumRef</span><span class="p">(</span><span class="n">Z3_mk_fpa_inf</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">ctx_ref</span><span class="p">(),</span> <span class="n">s</span><span class="o">.</span><span class="n">ast</span><span class="p">,</span> <span class="kc">False</span><span class="p">),</span> <span class="n">s</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">fpMinusInfinity</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Create a Z3 floating-point -oo term.&quot;&quot;&quot;</span>
    <span class="n">_z3_assert</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">FPSortRef</span><span class="p">),</span> <span class="s2">&quot;sort mismatch&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">FPNumRef</span><span class="p">(</span><span class="n">Z3_mk_fpa_inf</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">ctx_ref</span><span class="p">(),</span> <span class="n">s</span><span class="o">.</span><span class="n">ast</span><span class="p">,</span> <span class="kc">True</span><span class="p">),</span> <span class="n">s</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">fpInfinity</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">negative</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Create a Z3 floating-point +oo or -oo term.&quot;&quot;&quot;</span>
    <span class="n">_z3_assert</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">FPSortRef</span><span class="p">),</span> <span class="s2">&quot;sort mismatch&quot;</span><span class="p">)</span>
    <span class="n">_z3_assert</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">negative</span><span class="p">,</span> <span class="nb">bool</span><span class="p">),</span> <span class="s2">&quot;expected Boolean flag&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">FPNumRef</span><span class="p">(</span><span class="n">Z3_mk_fpa_inf</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">ctx_ref</span><span class="p">(),</span> <span class="n">s</span><span class="o">.</span><span class="n">ast</span><span class="p">,</span> <span class="n">negative</span><span class="p">),</span> <span class="n">s</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">fpPlusZero</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Create a Z3 floating-point +0.0 term.&quot;&quot;&quot;</span>
    <span class="n">_z3_assert</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">FPSortRef</span><span class="p">),</span> <span class="s2">&quot;sort mismatch&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">FPNumRef</span><span class="p">(</span><span class="n">Z3_mk_fpa_zero</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">ctx_ref</span><span class="p">(),</span> <span class="n">s</span><span class="o">.</span><span class="n">ast</span><span class="p">,</span> <span class="kc">False</span><span class="p">),</span> <span class="n">s</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">fpMinusZero</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Create a Z3 floating-point -0.0 term.&quot;&quot;&quot;</span>
    <span class="n">_z3_assert</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">FPSortRef</span><span class="p">),</span> <span class="s2">&quot;sort mismatch&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">FPNumRef</span><span class="p">(</span><span class="n">Z3_mk_fpa_zero</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">ctx_ref</span><span class="p">(),</span> <span class="n">s</span><span class="o">.</span><span class="n">ast</span><span class="p">,</span> <span class="kc">True</span><span class="p">),</span> <span class="n">s</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">fpZero</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">negative</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Create a Z3 floating-point +0.0 or -0.0 term.&quot;&quot;&quot;</span>
    <span class="n">_z3_assert</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">FPSortRef</span><span class="p">),</span> <span class="s2">&quot;sort mismatch&quot;</span><span class="p">)</span>
    <span class="n">_z3_assert</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">negative</span><span class="p">,</span> <span class="nb">bool</span><span class="p">),</span> <span class="s2">&quot;expected Boolean flag&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">FPNumRef</span><span class="p">(</span><span class="n">Z3_mk_fpa_zero</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">ctx_ref</span><span class="p">(),</span> <span class="n">s</span><span class="o">.</span><span class="n">ast</span><span class="p">,</span> <span class="n">negative</span><span class="p">),</span> <span class="n">s</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">FPVal</span><span class="p">(</span><span class="n">sig</span><span class="p">,</span> <span class="n">exp</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">fps</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ctx</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return a floating-point value of value `val` and sort `fps`.</span>
<span class="sd">    If `ctx=None`, then the global context is used.</span>

<span class="sd">    &gt;&gt;&gt; v = FPVal(20.0, FPSort(8, 24))</span>
<span class="sd">    &gt;&gt;&gt; v</span>
<span class="sd">    1.25*(2**4)</span>
<span class="sd">    &gt;&gt;&gt; print(&quot;0x%.8x&quot; % v.exponent_as_long(False))</span>
<span class="sd">    0x00000004</span>
<span class="sd">    &gt;&gt;&gt; v = FPVal(2.25, FPSort(8, 24))</span>
<span class="sd">    &gt;&gt;&gt; v</span>
<span class="sd">    1.125*(2**1)</span>
<span class="sd">    &gt;&gt;&gt; v = FPVal(-2.25, FPSort(8, 24))</span>
<span class="sd">    &gt;&gt;&gt; v</span>
<span class="sd">    -1.125*(2**1)</span>
<span class="sd">    &gt;&gt;&gt; FPVal(-0.0, FPSort(8, 24))</span>
<span class="sd">    -0.0</span>
<span class="sd">    &gt;&gt;&gt; FPVal(0.0, FPSort(8, 24))</span>
<span class="sd">    +0.0</span>
<span class="sd">    &gt;&gt;&gt; FPVal(+0.0, FPSort(8, 24))</span>
<span class="sd">    +0.0</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ctx</span> <span class="o">=</span> <span class="n">_get_ctx</span><span class="p">(</span><span class="n">ctx</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">is_fp_sort</span><span class="p">(</span><span class="n">exp</span><span class="p">):</span>
        <span class="n">fps</span> <span class="o">=</span> <span class="n">exp</span>
        <span class="n">exp</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">elif</span> <span class="n">fps</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">fps</span> <span class="o">=</span> <span class="n">_dflt_fps</span><span class="p">(</span><span class="n">ctx</span><span class="p">)</span>
    <span class="n">_z3_assert</span><span class="p">(</span><span class="n">is_fp_sort</span><span class="p">(</span><span class="n">fps</span><span class="p">),</span> <span class="s2">&quot;sort mismatch&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">exp</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">exp</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">val</span> <span class="o">=</span> <span class="n">_to_float_str</span><span class="p">(</span><span class="n">sig</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">val</span> <span class="o">==</span> <span class="s2">&quot;NaN&quot;</span> <span class="ow">or</span> <span class="n">val</span> <span class="o">==</span> <span class="s2">&quot;nan&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">fpNaN</span><span class="p">(</span><span class="n">fps</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">val</span> <span class="o">==</span> <span class="s2">&quot;-0.0&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">fpMinusZero</span><span class="p">(</span><span class="n">fps</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">val</span> <span class="o">==</span> <span class="s2">&quot;0.0&quot;</span> <span class="ow">or</span> <span class="n">val</span> <span class="o">==</span> <span class="s2">&quot;+0.0&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">fpPlusZero</span><span class="p">(</span><span class="n">fps</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">val</span> <span class="o">==</span> <span class="s2">&quot;+oo&quot;</span> <span class="ow">or</span> <span class="n">val</span> <span class="o">==</span> <span class="s2">&quot;+inf&quot;</span> <span class="ow">or</span> <span class="n">val</span> <span class="o">==</span> <span class="s2">&quot;+Inf&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">fpPlusInfinity</span><span class="p">(</span><span class="n">fps</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">val</span> <span class="o">==</span> <span class="s2">&quot;-oo&quot;</span> <span class="ow">or</span> <span class="n">val</span> <span class="o">==</span> <span class="s2">&quot;-inf&quot;</span> <span class="ow">or</span> <span class="n">val</span> <span class="o">==</span> <span class="s2">&quot;-Inf&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">fpMinusInfinity</span><span class="p">(</span><span class="n">fps</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">FPNumRef</span><span class="p">(</span><span class="n">Z3_mk_numeral</span><span class="p">(</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="n">val</span><span class="p">,</span> <span class="n">fps</span><span class="o">.</span><span class="n">ast</span><span class="p">),</span> <span class="n">ctx</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">FP</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">fpsort</span><span class="p">,</span> <span class="n">ctx</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return a floating-point constant named `name`.</span>
<span class="sd">    `fpsort` is the floating-point sort.</span>
<span class="sd">    If `ctx=None`, then the global context is used.</span>

<span class="sd">    &gt;&gt;&gt; x  = FP(&#39;x&#39;, FPSort(8, 24))</span>
<span class="sd">    &gt;&gt;&gt; is_fp(x)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; x.ebits()</span>
<span class="sd">    8</span>
<span class="sd">    &gt;&gt;&gt; x.sort()</span>
<span class="sd">    FPSort(8, 24)</span>
<span class="sd">    &gt;&gt;&gt; word = FPSort(8, 24)</span>
<span class="sd">    &gt;&gt;&gt; x2 = FP(&#39;x&#39;, word)</span>
<span class="sd">    &gt;&gt;&gt; eq(x, x2)</span>
<span class="sd">    True</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fpsort</span><span class="p">,</span> <span class="n">FPSortRef</span><span class="p">)</span> <span class="ow">and</span> <span class="n">ctx</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">ctx</span> <span class="o">=</span> <span class="n">fpsort</span><span class="o">.</span><span class="n">ctx</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">ctx</span> <span class="o">=</span> <span class="n">_get_ctx</span><span class="p">(</span><span class="n">ctx</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">FPRef</span><span class="p">(</span><span class="n">Z3_mk_const</span><span class="p">(</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="n">to_symbol</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">ctx</span><span class="p">),</span> <span class="n">fpsort</span><span class="o">.</span><span class="n">ast</span><span class="p">),</span> <span class="n">ctx</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">FPs</span><span class="p">(</span><span class="n">names</span><span class="p">,</span> <span class="n">fpsort</span><span class="p">,</span> <span class="n">ctx</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return an array of floating-point constants.</span>

<span class="sd">    &gt;&gt;&gt; x, y, z = FPs(&#39;x y z&#39;, FPSort(8, 24))</span>
<span class="sd">    &gt;&gt;&gt; x.sort()</span>
<span class="sd">    FPSort(8, 24)</span>
<span class="sd">    &gt;&gt;&gt; x.sbits()</span>
<span class="sd">    24</span>
<span class="sd">    &gt;&gt;&gt; x.ebits()</span>
<span class="sd">    8</span>
<span class="sd">    &gt;&gt;&gt; fpMul(RNE(), fpAdd(RNE(), x, y), z)</span>
<span class="sd">    x + y * z</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ctx</span> <span class="o">=</span> <span class="n">_get_ctx</span><span class="p">(</span><span class="n">ctx</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">names</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="n">names</span> <span class="o">=</span> <span class="n">names</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot; &quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">FP</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">fpsort</span><span class="p">,</span> <span class="n">ctx</span><span class="p">)</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">names</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">fpAbs</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">ctx</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Create a Z3 floating-point absolute value expression.</span>

<span class="sd">    &gt;&gt;&gt; s = FPSort(8, 24)</span>
<span class="sd">    &gt;&gt;&gt; rm = RNE()</span>
<span class="sd">    &gt;&gt;&gt; x = FPVal(1.0, s)</span>
<span class="sd">    &gt;&gt;&gt; fpAbs(x)</span>
<span class="sd">    fpAbs(1)</span>
<span class="sd">    &gt;&gt;&gt; y = FPVal(-20.0, s)</span>
<span class="sd">    &gt;&gt;&gt; y</span>
<span class="sd">    -1.25*(2**4)</span>
<span class="sd">    &gt;&gt;&gt; fpAbs(y)</span>
<span class="sd">    fpAbs(-1.25*(2**4))</span>
<span class="sd">    &gt;&gt;&gt; fpAbs(-1.25*(2**4))</span>
<span class="sd">    fpAbs(-1.25*(2**4))</span>
<span class="sd">    &gt;&gt;&gt; fpAbs(x).sort()</span>
<span class="sd">    FPSort(8, 24)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ctx</span> <span class="o">=</span> <span class="n">_get_ctx</span><span class="p">(</span><span class="n">ctx</span><span class="p">)</span>
    <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">=</span> <span class="n">_coerce_fp_expr_list</span><span class="p">([</span><span class="n">a</span><span class="p">],</span> <span class="n">ctx</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">FPRef</span><span class="p">(</span><span class="n">Z3_mk_fpa_abs</span><span class="p">(</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="n">a</span><span class="o">.</span><span class="n">as_ast</span><span class="p">()),</span> <span class="n">ctx</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">fpNeg</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">ctx</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Create a Z3 floating-point addition expression.</span>

<span class="sd">    &gt;&gt;&gt; s = FPSort(8, 24)</span>
<span class="sd">    &gt;&gt;&gt; rm = RNE()</span>
<span class="sd">    &gt;&gt;&gt; x = FP(&#39;x&#39;, s)</span>
<span class="sd">    &gt;&gt;&gt; fpNeg(x)</span>
<span class="sd">    -x</span>
<span class="sd">    &gt;&gt;&gt; fpNeg(x).sort()</span>
<span class="sd">    FPSort(8, 24)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ctx</span> <span class="o">=</span> <span class="n">_get_ctx</span><span class="p">(</span><span class="n">ctx</span><span class="p">)</span>
    <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">=</span> <span class="n">_coerce_fp_expr_list</span><span class="p">([</span><span class="n">a</span><span class="p">],</span> <span class="n">ctx</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">FPRef</span><span class="p">(</span><span class="n">Z3_mk_fpa_neg</span><span class="p">(</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="n">a</span><span class="o">.</span><span class="n">as_ast</span><span class="p">()),</span> <span class="n">ctx</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_mk_fp_unary</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">rm</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">ctx</span><span class="p">):</span>
    <span class="n">ctx</span> <span class="o">=</span> <span class="n">_get_ctx</span><span class="p">(</span><span class="n">ctx</span><span class="p">)</span>
    <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">=</span> <span class="n">_coerce_fp_expr_list</span><span class="p">([</span><span class="n">a</span><span class="p">],</span> <span class="n">ctx</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">z3_debug</span><span class="p">():</span>
        <span class="n">_z3_assert</span><span class="p">(</span><span class="n">is_fprm</span><span class="p">(</span><span class="n">rm</span><span class="p">),</span> <span class="s2">&quot;First argument must be a Z3 floating-point rounding mode expression&quot;</span><span class="p">)</span>
        <span class="n">_z3_assert</span><span class="p">(</span><span class="n">is_fp</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="s2">&quot;Second argument must be a Z3 floating-point expression&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">FPRef</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="n">rm</span><span class="o">.</span><span class="n">as_ast</span><span class="p">(),</span> <span class="n">a</span><span class="o">.</span><span class="n">as_ast</span><span class="p">()),</span> <span class="n">ctx</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_mk_fp_unary_pred</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">ctx</span><span class="p">):</span>
    <span class="n">ctx</span> <span class="o">=</span> <span class="n">_get_ctx</span><span class="p">(</span><span class="n">ctx</span><span class="p">)</span>
    <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">=</span> <span class="n">_coerce_fp_expr_list</span><span class="p">([</span><span class="n">a</span><span class="p">],</span> <span class="n">ctx</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">z3_debug</span><span class="p">():</span>
        <span class="n">_z3_assert</span><span class="p">(</span><span class="n">is_fp</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="s2">&quot;First argument must be a Z3 floating-point expression&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">BoolRef</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="n">a</span><span class="o">.</span><span class="n">as_ast</span><span class="p">()),</span> <span class="n">ctx</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_mk_fp_bin</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">rm</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">ctx</span><span class="p">):</span>
    <span class="n">ctx</span> <span class="o">=</span> <span class="n">_get_ctx</span><span class="p">(</span><span class="n">ctx</span><span class="p">)</span>
    <span class="p">[</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">]</span> <span class="o">=</span> <span class="n">_coerce_fp_expr_list</span><span class="p">([</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">],</span> <span class="n">ctx</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">z3_debug</span><span class="p">():</span>
        <span class="n">_z3_assert</span><span class="p">(</span><span class="n">is_fprm</span><span class="p">(</span><span class="n">rm</span><span class="p">),</span> <span class="s2">&quot;First argument must be a Z3 floating-point rounding mode expression&quot;</span><span class="p">)</span>
        <span class="n">_z3_assert</span><span class="p">(</span><span class="n">is_fp</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="ow">or</span> <span class="n">is_fp</span><span class="p">(</span><span class="n">b</span><span class="p">),</span> <span class="s2">&quot;Second or third argument must be a Z3 floating-point expression&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">FPRef</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="n">rm</span><span class="o">.</span><span class="n">as_ast</span><span class="p">(),</span> <span class="n">a</span><span class="o">.</span><span class="n">as_ast</span><span class="p">(),</span> <span class="n">b</span><span class="o">.</span><span class="n">as_ast</span><span class="p">()),</span> <span class="n">ctx</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_mk_fp_bin_norm</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">ctx</span><span class="p">):</span>
    <span class="n">ctx</span> <span class="o">=</span> <span class="n">_get_ctx</span><span class="p">(</span><span class="n">ctx</span><span class="p">)</span>
    <span class="p">[</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">]</span> <span class="o">=</span> <span class="n">_coerce_fp_expr_list</span><span class="p">([</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">],</span> <span class="n">ctx</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">z3_debug</span><span class="p">():</span>
        <span class="n">_z3_assert</span><span class="p">(</span><span class="n">is_fp</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="ow">or</span> <span class="n">is_fp</span><span class="p">(</span><span class="n">b</span><span class="p">),</span> <span class="s2">&quot;First or second argument must be a Z3 floating-point expression&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">FPRef</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="n">a</span><span class="o">.</span><span class="n">as_ast</span><span class="p">(),</span> <span class="n">b</span><span class="o">.</span><span class="n">as_ast</span><span class="p">()),</span> <span class="n">ctx</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_mk_fp_bin_pred</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">ctx</span><span class="p">):</span>
    <span class="n">ctx</span> <span class="o">=</span> <span class="n">_get_ctx</span><span class="p">(</span><span class="n">ctx</span><span class="p">)</span>
    <span class="p">[</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">]</span> <span class="o">=</span> <span class="n">_coerce_fp_expr_list</span><span class="p">([</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">],</span> <span class="n">ctx</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">z3_debug</span><span class="p">():</span>
        <span class="n">_z3_assert</span><span class="p">(</span><span class="n">is_fp</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="ow">or</span> <span class="n">is_fp</span><span class="p">(</span><span class="n">b</span><span class="p">),</span> <span class="s2">&quot;First or second argument must be a Z3 floating-point expression&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">BoolRef</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="n">a</span><span class="o">.</span><span class="n">as_ast</span><span class="p">(),</span> <span class="n">b</span><span class="o">.</span><span class="n">as_ast</span><span class="p">()),</span> <span class="n">ctx</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_mk_fp_tern</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">rm</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">ctx</span><span class="p">):</span>
    <span class="n">ctx</span> <span class="o">=</span> <span class="n">_get_ctx</span><span class="p">(</span><span class="n">ctx</span><span class="p">)</span>
    <span class="p">[</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">_coerce_fp_expr_list</span><span class="p">([</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">],</span> <span class="n">ctx</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">z3_debug</span><span class="p">():</span>
        <span class="n">_z3_assert</span><span class="p">(</span><span class="n">is_fprm</span><span class="p">(</span><span class="n">rm</span><span class="p">),</span> <span class="s2">&quot;First argument must be a Z3 floating-point rounding mode expression&quot;</span><span class="p">)</span>
        <span class="n">_z3_assert</span><span class="p">(</span><span class="n">is_fp</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="ow">or</span> <span class="n">is_fp</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="ow">or</span> <span class="n">is_fp</span><span class="p">(</span>
            <span class="n">c</span><span class="p">),</span> <span class="s2">&quot;Second, third or fourth argument must be a Z3 floating-point expression&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">FPRef</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="n">rm</span><span class="o">.</span><span class="n">as_ast</span><span class="p">(),</span> <span class="n">a</span><span class="o">.</span><span class="n">as_ast</span><span class="p">(),</span> <span class="n">b</span><span class="o">.</span><span class="n">as_ast</span><span class="p">(),</span> <span class="n">c</span><span class="o">.</span><span class="n">as_ast</span><span class="p">()),</span> <span class="n">ctx</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">fpAdd</span><span class="p">(</span><span class="n">rm</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">ctx</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Create a Z3 floating-point addition expression.</span>

<span class="sd">    &gt;&gt;&gt; s = FPSort(8, 24)</span>
<span class="sd">    &gt;&gt;&gt; rm = RNE()</span>
<span class="sd">    &gt;&gt;&gt; x = FP(&#39;x&#39;, s)</span>
<span class="sd">    &gt;&gt;&gt; y = FP(&#39;y&#39;, s)</span>
<span class="sd">    &gt;&gt;&gt; fpAdd(rm, x, y)</span>
<span class="sd">    x + y</span>
<span class="sd">    &gt;&gt;&gt; fpAdd(RTZ(), x, y) # default rounding mode is RTZ</span>
<span class="sd">    fpAdd(RTZ(), x, y)</span>
<span class="sd">    &gt;&gt;&gt; fpAdd(rm, x, y).sort()</span>
<span class="sd">    FPSort(8, 24)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_mk_fp_bin</span><span class="p">(</span><span class="n">Z3_mk_fpa_add</span><span class="p">,</span> <span class="n">rm</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">ctx</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">fpSub</span><span class="p">(</span><span class="n">rm</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">ctx</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Create a Z3 floating-point subtraction expression.</span>

<span class="sd">    &gt;&gt;&gt; s = FPSort(8, 24)</span>
<span class="sd">    &gt;&gt;&gt; rm = RNE()</span>
<span class="sd">    &gt;&gt;&gt; x = FP(&#39;x&#39;, s)</span>
<span class="sd">    &gt;&gt;&gt; y = FP(&#39;y&#39;, s)</span>
<span class="sd">    &gt;&gt;&gt; fpSub(rm, x, y)</span>
<span class="sd">    x - y</span>
<span class="sd">    &gt;&gt;&gt; fpSub(rm, x, y).sort()</span>
<span class="sd">    FPSort(8, 24)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_mk_fp_bin</span><span class="p">(</span><span class="n">Z3_mk_fpa_sub</span><span class="p">,</span> <span class="n">rm</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">ctx</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">fpMul</span><span class="p">(</span><span class="n">rm</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">ctx</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Create a Z3 floating-point multiplication expression.</span>

<span class="sd">    &gt;&gt;&gt; s = FPSort(8, 24)</span>
<span class="sd">    &gt;&gt;&gt; rm = RNE()</span>
<span class="sd">    &gt;&gt;&gt; x = FP(&#39;x&#39;, s)</span>
<span class="sd">    &gt;&gt;&gt; y = FP(&#39;y&#39;, s)</span>
<span class="sd">    &gt;&gt;&gt; fpMul(rm, x, y)</span>
<span class="sd">    x * y</span>
<span class="sd">    &gt;&gt;&gt; fpMul(rm, x, y).sort()</span>
<span class="sd">    FPSort(8, 24)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_mk_fp_bin</span><span class="p">(</span><span class="n">Z3_mk_fpa_mul</span><span class="p">,</span> <span class="n">rm</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">ctx</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">fpDiv</span><span class="p">(</span><span class="n">rm</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">ctx</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Create a Z3 floating-point division expression.</span>

<span class="sd">    &gt;&gt;&gt; s = FPSort(8, 24)</span>
<span class="sd">    &gt;&gt;&gt; rm = RNE()</span>
<span class="sd">    &gt;&gt;&gt; x = FP(&#39;x&#39;, s)</span>
<span class="sd">    &gt;&gt;&gt; y = FP(&#39;y&#39;, s)</span>
<span class="sd">    &gt;&gt;&gt; fpDiv(rm, x, y)</span>
<span class="sd">    x / y</span>
<span class="sd">    &gt;&gt;&gt; fpDiv(rm, x, y).sort()</span>
<span class="sd">    FPSort(8, 24)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_mk_fp_bin</span><span class="p">(</span><span class="n">Z3_mk_fpa_div</span><span class="p">,</span> <span class="n">rm</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">ctx</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">fpRem</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">ctx</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Create a Z3 floating-point remainder expression.</span>

<span class="sd">    &gt;&gt;&gt; s = FPSort(8, 24)</span>
<span class="sd">    &gt;&gt;&gt; x = FP(&#39;x&#39;, s)</span>
<span class="sd">    &gt;&gt;&gt; y = FP(&#39;y&#39;, s)</span>
<span class="sd">    &gt;&gt;&gt; fpRem(x, y)</span>
<span class="sd">    fpRem(x, y)</span>
<span class="sd">    &gt;&gt;&gt; fpRem(x, y).sort()</span>
<span class="sd">    FPSort(8, 24)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_mk_fp_bin_norm</span><span class="p">(</span><span class="n">Z3_mk_fpa_rem</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">ctx</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">fpMin</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">ctx</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Create a Z3 floating-point minimum expression.</span>

<span class="sd">    &gt;&gt;&gt; s = FPSort(8, 24)</span>
<span class="sd">    &gt;&gt;&gt; rm = RNE()</span>
<span class="sd">    &gt;&gt;&gt; x = FP(&#39;x&#39;, s)</span>
<span class="sd">    &gt;&gt;&gt; y = FP(&#39;y&#39;, s)</span>
<span class="sd">    &gt;&gt;&gt; fpMin(x, y)</span>
<span class="sd">    fpMin(x, y)</span>
<span class="sd">    &gt;&gt;&gt; fpMin(x, y).sort()</span>
<span class="sd">    FPSort(8, 24)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_mk_fp_bin_norm</span><span class="p">(</span><span class="n">Z3_mk_fpa_min</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">ctx</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">fpMax</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">ctx</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Create a Z3 floating-point maximum expression.</span>

<span class="sd">    &gt;&gt;&gt; s = FPSort(8, 24)</span>
<span class="sd">    &gt;&gt;&gt; rm = RNE()</span>
<span class="sd">    &gt;&gt;&gt; x = FP(&#39;x&#39;, s)</span>
<span class="sd">    &gt;&gt;&gt; y = FP(&#39;y&#39;, s)</span>
<span class="sd">    &gt;&gt;&gt; fpMax(x, y)</span>
<span class="sd">    fpMax(x, y)</span>
<span class="sd">    &gt;&gt;&gt; fpMax(x, y).sort()</span>
<span class="sd">    FPSort(8, 24)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_mk_fp_bin_norm</span><span class="p">(</span><span class="n">Z3_mk_fpa_max</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">ctx</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">fpFMA</span><span class="p">(</span><span class="n">rm</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">ctx</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Create a Z3 floating-point fused multiply-add expression.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_mk_fp_tern</span><span class="p">(</span><span class="n">Z3_mk_fpa_fma</span><span class="p">,</span> <span class="n">rm</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">ctx</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">fpSqrt</span><span class="p">(</span><span class="n">rm</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">ctx</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Create a Z3 floating-point square root expression.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_mk_fp_unary</span><span class="p">(</span><span class="n">Z3_mk_fpa_sqrt</span><span class="p">,</span> <span class="n">rm</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">ctx</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">fpRoundToIntegral</span><span class="p">(</span><span class="n">rm</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">ctx</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Create a Z3 floating-point roundToIntegral expression.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_mk_fp_unary</span><span class="p">(</span><span class="n">Z3_mk_fpa_round_to_integral</span><span class="p">,</span> <span class="n">rm</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">ctx</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">fpIsNaN</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">ctx</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Create a Z3 floating-point isNaN expression.</span>

<span class="sd">    &gt;&gt;&gt; s = FPSort(8, 24)</span>
<span class="sd">    &gt;&gt;&gt; x = FP(&#39;x&#39;, s)</span>
<span class="sd">    &gt;&gt;&gt; y = FP(&#39;y&#39;, s)</span>
<span class="sd">    &gt;&gt;&gt; fpIsNaN(x)</span>
<span class="sd">    fpIsNaN(x)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_mk_fp_unary_pred</span><span class="p">(</span><span class="n">Z3_mk_fpa_is_nan</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">ctx</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">fpIsInf</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">ctx</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Create a Z3 floating-point isInfinite expression.</span>

<span class="sd">    &gt;&gt;&gt; s = FPSort(8, 24)</span>
<span class="sd">    &gt;&gt;&gt; x = FP(&#39;x&#39;, s)</span>
<span class="sd">    &gt;&gt;&gt; fpIsInf(x)</span>
<span class="sd">    fpIsInf(x)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_mk_fp_unary_pred</span><span class="p">(</span><span class="n">Z3_mk_fpa_is_infinite</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">ctx</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">fpIsZero</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">ctx</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Create a Z3 floating-point isZero expression.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_mk_fp_unary_pred</span><span class="p">(</span><span class="n">Z3_mk_fpa_is_zero</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">ctx</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">fpIsNormal</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">ctx</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Create a Z3 floating-point isNormal expression.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_mk_fp_unary_pred</span><span class="p">(</span><span class="n">Z3_mk_fpa_is_normal</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">ctx</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">fpIsSubnormal</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">ctx</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Create a Z3 floating-point isSubnormal expression.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_mk_fp_unary_pred</span><span class="p">(</span><span class="n">Z3_mk_fpa_is_subnormal</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">ctx</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">fpIsNegative</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">ctx</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Create a Z3 floating-point isNegative expression.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_mk_fp_unary_pred</span><span class="p">(</span><span class="n">Z3_mk_fpa_is_negative</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">ctx</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">fpIsPositive</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">ctx</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Create a Z3 floating-point isPositive expression.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_mk_fp_unary_pred</span><span class="p">(</span><span class="n">Z3_mk_fpa_is_positive</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">ctx</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_check_fp_args</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">z3_debug</span><span class="p">():</span>
        <span class="n">_z3_assert</span><span class="p">(</span><span class="n">is_fp</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="ow">or</span> <span class="n">is_fp</span><span class="p">(</span><span class="n">b</span><span class="p">),</span> <span class="s2">&quot;First or second argument must be a Z3 floating-point expression&quot;</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">fpLT</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">ctx</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Create the Z3 floating-point expression `other &lt; self`.</span>

<span class="sd">    &gt;&gt;&gt; x, y = FPs(&#39;x y&#39;, FPSort(8, 24))</span>
<span class="sd">    &gt;&gt;&gt; fpLT(x, y)</span>
<span class="sd">    x &lt; y</span>
<span class="sd">    &gt;&gt;&gt; (x &lt; y).sexpr()</span>
<span class="sd">    &#39;(fp.lt x y)&#39;</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_mk_fp_bin_pred</span><span class="p">(</span><span class="n">Z3_mk_fpa_lt</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">ctx</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">fpLEQ</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">ctx</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Create the Z3 floating-point expression `other &lt;= self`.</span>

<span class="sd">    &gt;&gt;&gt; x, y = FPs(&#39;x y&#39;, FPSort(8, 24))</span>
<span class="sd">    &gt;&gt;&gt; fpLEQ(x, y)</span>
<span class="sd">    x &lt;= y</span>
<span class="sd">    &gt;&gt;&gt; (x &lt;= y).sexpr()</span>
<span class="sd">    &#39;(fp.leq x y)&#39;</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_mk_fp_bin_pred</span><span class="p">(</span><span class="n">Z3_mk_fpa_leq</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">ctx</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">fpGT</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">ctx</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Create the Z3 floating-point expression `other &gt; self`.</span>

<span class="sd">    &gt;&gt;&gt; x, y = FPs(&#39;x y&#39;, FPSort(8, 24))</span>
<span class="sd">    &gt;&gt;&gt; fpGT(x, y)</span>
<span class="sd">    x &gt; y</span>
<span class="sd">    &gt;&gt;&gt; (x &gt; y).sexpr()</span>
<span class="sd">    &#39;(fp.gt x y)&#39;</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_mk_fp_bin_pred</span><span class="p">(</span><span class="n">Z3_mk_fpa_gt</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">ctx</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">fpGEQ</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">ctx</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Create the Z3 floating-point expression `other &gt;= self`.</span>

<span class="sd">    &gt;&gt;&gt; x, y = FPs(&#39;x y&#39;, FPSort(8, 24))</span>
<span class="sd">    &gt;&gt;&gt; fpGEQ(x, y)</span>
<span class="sd">    x &gt;= y</span>
<span class="sd">    &gt;&gt;&gt; (x &gt;= y).sexpr()</span>
<span class="sd">    &#39;(fp.geq x y)&#39;</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_mk_fp_bin_pred</span><span class="p">(</span><span class="n">Z3_mk_fpa_geq</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">ctx</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">fpEQ</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">ctx</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Create the Z3 floating-point expression `fpEQ(other, self)`.</span>

<span class="sd">    &gt;&gt;&gt; x, y = FPs(&#39;x y&#39;, FPSort(8, 24))</span>
<span class="sd">    &gt;&gt;&gt; fpEQ(x, y)</span>
<span class="sd">    fpEQ(x, y)</span>
<span class="sd">    &gt;&gt;&gt; fpEQ(x, y).sexpr()</span>
<span class="sd">    &#39;(fp.eq x y)&#39;</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_mk_fp_bin_pred</span><span class="p">(</span><span class="n">Z3_mk_fpa_eq</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">ctx</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">fpNEQ</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">ctx</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Create the Z3 floating-point expression `Not(fpEQ(other, self))`.</span>

<span class="sd">    &gt;&gt;&gt; x, y = FPs(&#39;x y&#39;, FPSort(8, 24))</span>
<span class="sd">    &gt;&gt;&gt; fpNEQ(x, y)</span>
<span class="sd">    Not(fpEQ(x, y))</span>
<span class="sd">    &gt;&gt;&gt; (x != y).sexpr()</span>
<span class="sd">    &#39;(distinct x y)&#39;</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">Not</span><span class="p">(</span><span class="n">fpEQ</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">ctx</span><span class="p">))</span>


<span class="k">def</span> <span class="nf">fpFP</span><span class="p">(</span><span class="n">sgn</span><span class="p">,</span> <span class="n">exp</span><span class="p">,</span> <span class="n">sig</span><span class="p">,</span> <span class="n">ctx</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Create the Z3 floating-point value `fpFP(sgn, sig, exp)` from the three bit-vectors sgn, sig, and exp.</span>

<span class="sd">    &gt;&gt;&gt; s = FPSort(8, 24)</span>
<span class="sd">    &gt;&gt;&gt; x = fpFP(BitVecVal(1, 1), BitVecVal(2**7-1, 8), BitVecVal(2**22, 23))</span>
<span class="sd">    &gt;&gt;&gt; print(x)</span>
<span class="sd">    fpFP(1, 127, 4194304)</span>
<span class="sd">    &gt;&gt;&gt; xv = FPVal(-1.5, s)</span>
<span class="sd">    &gt;&gt;&gt; print(xv)</span>
<span class="sd">    -1.5</span>
<span class="sd">    &gt;&gt;&gt; slvr = Solver()</span>
<span class="sd">    &gt;&gt;&gt; slvr.add(fpEQ(x, xv))</span>
<span class="sd">    &gt;&gt;&gt; slvr.check()</span>
<span class="sd">    sat</span>
<span class="sd">    &gt;&gt;&gt; xv = FPVal(+1.5, s)</span>
<span class="sd">    &gt;&gt;&gt; print(xv)</span>
<span class="sd">    1.5</span>
<span class="sd">    &gt;&gt;&gt; slvr = Solver()</span>
<span class="sd">    &gt;&gt;&gt; slvr.add(fpEQ(x, xv))</span>
<span class="sd">    &gt;&gt;&gt; slvr.check()</span>
<span class="sd">    unsat</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_z3_assert</span><span class="p">(</span><span class="n">is_bv</span><span class="p">(</span><span class="n">sgn</span><span class="p">)</span> <span class="ow">and</span> <span class="n">is_bv</span><span class="p">(</span><span class="n">exp</span><span class="p">)</span> <span class="ow">and</span> <span class="n">is_bv</span><span class="p">(</span><span class="n">sig</span><span class="p">),</span> <span class="s2">&quot;sort mismatch&quot;</span><span class="p">)</span>
    <span class="n">_z3_assert</span><span class="p">(</span><span class="n">sgn</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span><span class="o">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;sort mismatch&quot;</span><span class="p">)</span>
    <span class="n">ctx</span> <span class="o">=</span> <span class="n">_get_ctx</span><span class="p">(</span><span class="n">ctx</span><span class="p">)</span>
    <span class="n">_z3_assert</span><span class="p">(</span><span class="n">ctx</span> <span class="o">==</span> <span class="n">sgn</span><span class="o">.</span><span class="n">ctx</span> <span class="o">==</span> <span class="n">exp</span><span class="o">.</span><span class="n">ctx</span> <span class="o">==</span> <span class="n">sig</span><span class="o">.</span><span class="n">ctx</span><span class="p">,</span> <span class="s2">&quot;context mismatch&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">FPRef</span><span class="p">(</span><span class="n">Z3_mk_fpa_fp</span><span class="p">(</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="n">sgn</span><span class="o">.</span><span class="n">ast</span><span class="p">,</span> <span class="n">exp</span><span class="o">.</span><span class="n">ast</span><span class="p">,</span> <span class="n">sig</span><span class="o">.</span><span class="n">ast</span><span class="p">),</span> <span class="n">ctx</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">fpToFP</span><span class="p">(</span><span class="n">a1</span><span class="p">,</span> <span class="n">a2</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">a3</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ctx</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Create a Z3 floating-point conversion expression from other term sorts</span>
<span class="sd">    to floating-point.</span>

<span class="sd">    From a bit-vector term in IEEE 754-2008 format:</span>
<span class="sd">    &gt;&gt;&gt; x = FPVal(1.0, Float32())</span>
<span class="sd">    &gt;&gt;&gt; x_bv = fpToIEEEBV(x)</span>
<span class="sd">    &gt;&gt;&gt; simplify(fpToFP(x_bv, Float32()))</span>
<span class="sd">    1</span>

<span class="sd">    From a floating-point term with different precision:</span>
<span class="sd">    &gt;&gt;&gt; x = FPVal(1.0, Float32())</span>
<span class="sd">    &gt;&gt;&gt; x_db = fpToFP(RNE(), x, Float64())</span>
<span class="sd">    &gt;&gt;&gt; x_db.sort()</span>
<span class="sd">    FPSort(11, 53)</span>

<span class="sd">    From a real term:</span>
<span class="sd">    &gt;&gt;&gt; x_r = RealVal(1.5)</span>
<span class="sd">    &gt;&gt;&gt; simplify(fpToFP(RNE(), x_r, Float32()))</span>
<span class="sd">    1.5</span>

<span class="sd">    From a signed bit-vector term:</span>
<span class="sd">    &gt;&gt;&gt; x_signed = BitVecVal(-5, BitVecSort(32))</span>
<span class="sd">    &gt;&gt;&gt; simplify(fpToFP(RNE(), x_signed, Float32()))</span>
<span class="sd">    -1.25*(2**2)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ctx</span> <span class="o">=</span> <span class="n">_get_ctx</span><span class="p">(</span><span class="n">ctx</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">is_bv</span><span class="p">(</span><span class="n">a1</span><span class="p">)</span> <span class="ow">and</span> <span class="n">is_fp_sort</span><span class="p">(</span><span class="n">a2</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">FPRef</span><span class="p">(</span><span class="n">Z3_mk_fpa_to_fp_bv</span><span class="p">(</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="n">a1</span><span class="o">.</span><span class="n">ast</span><span class="p">,</span> <span class="n">a2</span><span class="o">.</span><span class="n">ast</span><span class="p">),</span> <span class="n">ctx</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">is_fprm</span><span class="p">(</span><span class="n">a1</span><span class="p">)</span> <span class="ow">and</span> <span class="n">is_fp</span><span class="p">(</span><span class="n">a2</span><span class="p">)</span> <span class="ow">and</span> <span class="n">is_fp_sort</span><span class="p">(</span><span class="n">a3</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">FPRef</span><span class="p">(</span><span class="n">Z3_mk_fpa_to_fp_float</span><span class="p">(</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="n">a1</span><span class="o">.</span><span class="n">ast</span><span class="p">,</span> <span class="n">a2</span><span class="o">.</span><span class="n">ast</span><span class="p">,</span> <span class="n">a3</span><span class="o">.</span><span class="n">ast</span><span class="p">),</span> <span class="n">ctx</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">is_fprm</span><span class="p">(</span><span class="n">a1</span><span class="p">)</span> <span class="ow">and</span> <span class="n">is_real</span><span class="p">(</span><span class="n">a2</span><span class="p">)</span> <span class="ow">and</span> <span class="n">is_fp_sort</span><span class="p">(</span><span class="n">a3</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">FPRef</span><span class="p">(</span><span class="n">Z3_mk_fpa_to_fp_real</span><span class="p">(</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="n">a1</span><span class="o">.</span><span class="n">ast</span><span class="p">,</span> <span class="n">a2</span><span class="o">.</span><span class="n">ast</span><span class="p">,</span> <span class="n">a3</span><span class="o">.</span><span class="n">ast</span><span class="p">),</span> <span class="n">ctx</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">is_fprm</span><span class="p">(</span><span class="n">a1</span><span class="p">)</span> <span class="ow">and</span> <span class="n">is_bv</span><span class="p">(</span><span class="n">a2</span><span class="p">)</span> <span class="ow">and</span> <span class="n">is_fp_sort</span><span class="p">(</span><span class="n">a3</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">FPRef</span><span class="p">(</span><span class="n">Z3_mk_fpa_to_fp_signed</span><span class="p">(</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="n">a1</span><span class="o">.</span><span class="n">ast</span><span class="p">,</span> <span class="n">a2</span><span class="o">.</span><span class="n">ast</span><span class="p">,</span> <span class="n">a3</span><span class="o">.</span><span class="n">ast</span><span class="p">),</span> <span class="n">ctx</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">Z3Exception</span><span class="p">(</span><span class="s2">&quot;Unsupported combination of arguments for conversion to floating-point term.&quot;</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">fpBVToFP</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">sort</span><span class="p">,</span> <span class="n">ctx</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Create a Z3 floating-point conversion expression that represents the</span>
<span class="sd">    conversion from a bit-vector term to a floating-point term.</span>

<span class="sd">    &gt;&gt;&gt; x_bv = BitVecVal(0x3F800000, 32)</span>
<span class="sd">    &gt;&gt;&gt; x_fp = fpBVToFP(x_bv, Float32())</span>
<span class="sd">    &gt;&gt;&gt; x_fp</span>
<span class="sd">    fpToFP(1065353216)</span>
<span class="sd">    &gt;&gt;&gt; simplify(x_fp)</span>
<span class="sd">    1</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_z3_assert</span><span class="p">(</span><span class="n">is_bv</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="s2">&quot;First argument must be a Z3 bit-vector expression&quot;</span><span class="p">)</span>
    <span class="n">_z3_assert</span><span class="p">(</span><span class="n">is_fp_sort</span><span class="p">(</span><span class="n">sort</span><span class="p">),</span> <span class="s2">&quot;Second argument must be a Z3 floating-point sort.&quot;</span><span class="p">)</span>
    <span class="n">ctx</span> <span class="o">=</span> <span class="n">_get_ctx</span><span class="p">(</span><span class="n">ctx</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">FPRef</span><span class="p">(</span><span class="n">Z3_mk_fpa_to_fp_bv</span><span class="p">(</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="n">v</span><span class="o">.</span><span class="n">ast</span><span class="p">,</span> <span class="n">sort</span><span class="o">.</span><span class="n">ast</span><span class="p">),</span> <span class="n">ctx</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">fpFPToFP</span><span class="p">(</span><span class="n">rm</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">sort</span><span class="p">,</span> <span class="n">ctx</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Create a Z3 floating-point conversion expression that represents the</span>
<span class="sd">    conversion from a floating-point term to a floating-point term of different precision.</span>

<span class="sd">    &gt;&gt;&gt; x_sgl = FPVal(1.0, Float32())</span>
<span class="sd">    &gt;&gt;&gt; x_dbl = fpFPToFP(RNE(), x_sgl, Float64())</span>
<span class="sd">    &gt;&gt;&gt; x_dbl</span>
<span class="sd">    fpToFP(RNE(), 1)</span>
<span class="sd">    &gt;&gt;&gt; simplify(x_dbl)</span>
<span class="sd">    1</span>
<span class="sd">    &gt;&gt;&gt; x_dbl.sort()</span>
<span class="sd">    FPSort(11, 53)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_z3_assert</span><span class="p">(</span><span class="n">is_fprm</span><span class="p">(</span><span class="n">rm</span><span class="p">),</span> <span class="s2">&quot;First argument must be a Z3 floating-point rounding mode expression.&quot;</span><span class="p">)</span>
    <span class="n">_z3_assert</span><span class="p">(</span><span class="n">is_fp</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="s2">&quot;Second argument must be a Z3 floating-point expression.&quot;</span><span class="p">)</span>
    <span class="n">_z3_assert</span><span class="p">(</span><span class="n">is_fp_sort</span><span class="p">(</span><span class="n">sort</span><span class="p">),</span> <span class="s2">&quot;Third argument must be a Z3 floating-point sort.&quot;</span><span class="p">)</span>
    <span class="n">ctx</span> <span class="o">=</span> <span class="n">_get_ctx</span><span class="p">(</span><span class="n">ctx</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">FPRef</span><span class="p">(</span><span class="n">Z3_mk_fpa_to_fp_float</span><span class="p">(</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="n">rm</span><span class="o">.</span><span class="n">ast</span><span class="p">,</span> <span class="n">v</span><span class="o">.</span><span class="n">ast</span><span class="p">,</span> <span class="n">sort</span><span class="o">.</span><span class="n">ast</span><span class="p">),</span> <span class="n">ctx</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">fpRealToFP</span><span class="p">(</span><span class="n">rm</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">sort</span><span class="p">,</span> <span class="n">ctx</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Create a Z3 floating-point conversion expression that represents the</span>
<span class="sd">    conversion from a real term to a floating-point term.</span>

<span class="sd">    &gt;&gt;&gt; x_r = RealVal(1.5)</span>
<span class="sd">    &gt;&gt;&gt; x_fp = fpRealToFP(RNE(), x_r, Float32())</span>
<span class="sd">    &gt;&gt;&gt; x_fp</span>
<span class="sd">    fpToFP(RNE(), 3/2)</span>
<span class="sd">    &gt;&gt;&gt; simplify(x_fp)</span>
<span class="sd">    1.5</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_z3_assert</span><span class="p">(</span><span class="n">is_fprm</span><span class="p">(</span><span class="n">rm</span><span class="p">),</span> <span class="s2">&quot;First argument must be a Z3 floating-point rounding mode expression.&quot;</span><span class="p">)</span>
    <span class="n">_z3_assert</span><span class="p">(</span><span class="n">is_real</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="s2">&quot;Second argument must be a Z3 expression or real sort.&quot;</span><span class="p">)</span>
    <span class="n">_z3_assert</span><span class="p">(</span><span class="n">is_fp_sort</span><span class="p">(</span><span class="n">sort</span><span class="p">),</span> <span class="s2">&quot;Third argument must be a Z3 floating-point sort.&quot;</span><span class="p">)</span>
    <span class="n">ctx</span> <span class="o">=</span> <span class="n">_get_ctx</span><span class="p">(</span><span class="n">ctx</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">FPRef</span><span class="p">(</span><span class="n">Z3_mk_fpa_to_fp_real</span><span class="p">(</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="n">rm</span><span class="o">.</span><span class="n">ast</span><span class="p">,</span> <span class="n">v</span><span class="o">.</span><span class="n">ast</span><span class="p">,</span> <span class="n">sort</span><span class="o">.</span><span class="n">ast</span><span class="p">),</span> <span class="n">ctx</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">fpSignedToFP</span><span class="p">(</span><span class="n">rm</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">sort</span><span class="p">,</span> <span class="n">ctx</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Create a Z3 floating-point conversion expression that represents the</span>
<span class="sd">    conversion from a signed bit-vector term (encoding an integer) to a floating-point term.</span>

<span class="sd">    &gt;&gt;&gt; x_signed = BitVecVal(-5, BitVecSort(32))</span>
<span class="sd">    &gt;&gt;&gt; x_fp = fpSignedToFP(RNE(), x_signed, Float32())</span>
<span class="sd">    &gt;&gt;&gt; x_fp</span>
<span class="sd">    fpToFP(RNE(), 4294967291)</span>
<span class="sd">    &gt;&gt;&gt; simplify(x_fp)</span>
<span class="sd">    -1.25*(2**2)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_z3_assert</span><span class="p">(</span><span class="n">is_fprm</span><span class="p">(</span><span class="n">rm</span><span class="p">),</span> <span class="s2">&quot;First argument must be a Z3 floating-point rounding mode expression.&quot;</span><span class="p">)</span>
    <span class="n">_z3_assert</span><span class="p">(</span><span class="n">is_bv</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="s2">&quot;Second argument must be a Z3 bit-vector expression&quot;</span><span class="p">)</span>
    <span class="n">_z3_assert</span><span class="p">(</span><span class="n">is_fp_sort</span><span class="p">(</span><span class="n">sort</span><span class="p">),</span> <span class="s2">&quot;Third argument must be a Z3 floating-point sort.&quot;</span><span class="p">)</span>
    <span class="n">ctx</span> <span class="o">=</span> <span class="n">_get_ctx</span><span class="p">(</span><span class="n">ctx</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">FPRef</span><span class="p">(</span><span class="n">Z3_mk_fpa_to_fp_signed</span><span class="p">(</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="n">rm</span><span class="o">.</span><span class="n">ast</span><span class="p">,</span> <span class="n">v</span><span class="o">.</span><span class="n">ast</span><span class="p">,</span> <span class="n">sort</span><span class="o">.</span><span class="n">ast</span><span class="p">),</span> <span class="n">ctx</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">fpUnsignedToFP</span><span class="p">(</span><span class="n">rm</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">sort</span><span class="p">,</span> <span class="n">ctx</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Create a Z3 floating-point conversion expression that represents the</span>
<span class="sd">    conversion from an unsigned bit-vector term (encoding an integer) to a floating-point term.</span>

<span class="sd">    &gt;&gt;&gt; x_signed = BitVecVal(-5, BitVecSort(32))</span>
<span class="sd">    &gt;&gt;&gt; x_fp = fpUnsignedToFP(RNE(), x_signed, Float32())</span>
<span class="sd">    &gt;&gt;&gt; x_fp</span>
<span class="sd">    fpToFPUnsigned(RNE(), 4294967291)</span>
<span class="sd">    &gt;&gt;&gt; simplify(x_fp)</span>
<span class="sd">    1*(2**32)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_z3_assert</span><span class="p">(</span><span class="n">is_fprm</span><span class="p">(</span><span class="n">rm</span><span class="p">),</span> <span class="s2">&quot;First argument must be a Z3 floating-point rounding mode expression.&quot;</span><span class="p">)</span>
    <span class="n">_z3_assert</span><span class="p">(</span><span class="n">is_bv</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="s2">&quot;Second argument must be a Z3 bit-vector expression&quot;</span><span class="p">)</span>
    <span class="n">_z3_assert</span><span class="p">(</span><span class="n">is_fp_sort</span><span class="p">(</span><span class="n">sort</span><span class="p">),</span> <span class="s2">&quot;Third argument must be a Z3 floating-point sort.&quot;</span><span class="p">)</span>
    <span class="n">ctx</span> <span class="o">=</span> <span class="n">_get_ctx</span><span class="p">(</span><span class="n">ctx</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">FPRef</span><span class="p">(</span><span class="n">Z3_mk_fpa_to_fp_unsigned</span><span class="p">(</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="n">rm</span><span class="o">.</span><span class="n">ast</span><span class="p">,</span> <span class="n">v</span><span class="o">.</span><span class="n">ast</span><span class="p">,</span> <span class="n">sort</span><span class="o">.</span><span class="n">ast</span><span class="p">),</span> <span class="n">ctx</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">fpToFPUnsigned</span><span class="p">(</span><span class="n">rm</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">ctx</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Create a Z3 floating-point conversion expression, from unsigned bit-vector to floating-point expression.&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">z3_debug</span><span class="p">():</span>
        <span class="n">_z3_assert</span><span class="p">(</span><span class="n">is_fprm</span><span class="p">(</span><span class="n">rm</span><span class="p">),</span> <span class="s2">&quot;First argument must be a Z3 floating-point rounding mode expression&quot;</span><span class="p">)</span>
        <span class="n">_z3_assert</span><span class="p">(</span><span class="n">is_bv</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="s2">&quot;Second argument must be a Z3 bit-vector expression&quot;</span><span class="p">)</span>
        <span class="n">_z3_assert</span><span class="p">(</span><span class="n">is_fp_sort</span><span class="p">(</span><span class="n">s</span><span class="p">),</span> <span class="s2">&quot;Third argument must be Z3 floating-point sort&quot;</span><span class="p">)</span>
    <span class="n">ctx</span> <span class="o">=</span> <span class="n">_get_ctx</span><span class="p">(</span><span class="n">ctx</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">FPRef</span><span class="p">(</span><span class="n">Z3_mk_fpa_to_fp_unsigned</span><span class="p">(</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="n">rm</span><span class="o">.</span><span class="n">ast</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">ast</span><span class="p">,</span> <span class="n">s</span><span class="o">.</span><span class="n">ast</span><span class="p">),</span> <span class="n">ctx</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">fpToSBV</span><span class="p">(</span><span class="n">rm</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">ctx</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Create a Z3 floating-point conversion expression, from floating-point expression to signed bit-vector.</span>

<span class="sd">    &gt;&gt;&gt; x = FP(&#39;x&#39;, FPSort(8, 24))</span>
<span class="sd">    &gt;&gt;&gt; y = fpToSBV(RTZ(), x, BitVecSort(32))</span>
<span class="sd">    &gt;&gt;&gt; print(is_fp(x))</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; print(is_bv(y))</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; print(is_fp(y))</span>
<span class="sd">    False</span>
<span class="sd">    &gt;&gt;&gt; print(is_bv(x))</span>
<span class="sd">    False</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">z3_debug</span><span class="p">():</span>
        <span class="n">_z3_assert</span><span class="p">(</span><span class="n">is_fprm</span><span class="p">(</span><span class="n">rm</span><span class="p">),</span> <span class="s2">&quot;First argument must be a Z3 floating-point rounding mode expression&quot;</span><span class="p">)</span>
        <span class="n">_z3_assert</span><span class="p">(</span><span class="n">is_fp</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="s2">&quot;Second argument must be a Z3 floating-point expression&quot;</span><span class="p">)</span>
        <span class="n">_z3_assert</span><span class="p">(</span><span class="n">is_bv_sort</span><span class="p">(</span><span class="n">s</span><span class="p">),</span> <span class="s2">&quot;Third argument must be Z3 bit-vector sort&quot;</span><span class="p">)</span>
    <span class="n">ctx</span> <span class="o">=</span> <span class="n">_get_ctx</span><span class="p">(</span><span class="n">ctx</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">BitVecRef</span><span class="p">(</span><span class="n">Z3_mk_fpa_to_sbv</span><span class="p">(</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="n">rm</span><span class="o">.</span><span class="n">ast</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">ast</span><span class="p">,</span> <span class="n">s</span><span class="o">.</span><span class="n">size</span><span class="p">()),</span> <span class="n">ctx</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">fpToUBV</span><span class="p">(</span><span class="n">rm</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">ctx</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Create a Z3 floating-point conversion expression, from floating-point expression to unsigned bit-vector.</span>

<span class="sd">    &gt;&gt;&gt; x = FP(&#39;x&#39;, FPSort(8, 24))</span>
<span class="sd">    &gt;&gt;&gt; y = fpToUBV(RTZ(), x, BitVecSort(32))</span>
<span class="sd">    &gt;&gt;&gt; print(is_fp(x))</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; print(is_bv(y))</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; print(is_fp(y))</span>
<span class="sd">    False</span>
<span class="sd">    &gt;&gt;&gt; print(is_bv(x))</span>
<span class="sd">    False</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">z3_debug</span><span class="p">():</span>
        <span class="n">_z3_assert</span><span class="p">(</span><span class="n">is_fprm</span><span class="p">(</span><span class="n">rm</span><span class="p">),</span> <span class="s2">&quot;First argument must be a Z3 floating-point rounding mode expression&quot;</span><span class="p">)</span>
        <span class="n">_z3_assert</span><span class="p">(</span><span class="n">is_fp</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="s2">&quot;Second argument must be a Z3 floating-point expression&quot;</span><span class="p">)</span>
        <span class="n">_z3_assert</span><span class="p">(</span><span class="n">is_bv_sort</span><span class="p">(</span><span class="n">s</span><span class="p">),</span> <span class="s2">&quot;Third argument must be Z3 bit-vector sort&quot;</span><span class="p">)</span>
    <span class="n">ctx</span> <span class="o">=</span> <span class="n">_get_ctx</span><span class="p">(</span><span class="n">ctx</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">BitVecRef</span><span class="p">(</span><span class="n">Z3_mk_fpa_to_ubv</span><span class="p">(</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="n">rm</span><span class="o">.</span><span class="n">ast</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">ast</span><span class="p">,</span> <span class="n">s</span><span class="o">.</span><span class="n">size</span><span class="p">()),</span> <span class="n">ctx</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">fpToReal</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">ctx</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Create a Z3 floating-point conversion expression, from floating-point expression to real.</span>

<span class="sd">    &gt;&gt;&gt; x = FP(&#39;x&#39;, FPSort(8, 24))</span>
<span class="sd">    &gt;&gt;&gt; y = fpToReal(x)</span>
<span class="sd">    &gt;&gt;&gt; print(is_fp(x))</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; print(is_real(y))</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; print(is_fp(y))</span>
<span class="sd">    False</span>
<span class="sd">    &gt;&gt;&gt; print(is_real(x))</span>
<span class="sd">    False</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">z3_debug</span><span class="p">():</span>
        <span class="n">_z3_assert</span><span class="p">(</span><span class="n">is_fp</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="s2">&quot;First argument must be a Z3 floating-point expression&quot;</span><span class="p">)</span>
    <span class="n">ctx</span> <span class="o">=</span> <span class="n">_get_ctx</span><span class="p">(</span><span class="n">ctx</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">ArithRef</span><span class="p">(</span><span class="n">Z3_mk_fpa_to_real</span><span class="p">(</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="n">x</span><span class="o">.</span><span class="n">ast</span><span class="p">),</span> <span class="n">ctx</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">fpToIEEEBV</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">ctx</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;\brief Conversion of a floating-point term into a bit-vector term in IEEE 754-2008 format.</span>

<span class="sd">    The size of the resulting bit-vector is automatically determined.</span>

<span class="sd">    Note that IEEE 754-2008 allows multiple different representations of NaN. This conversion</span>
<span class="sd">    knows only one NaN and it will always produce the same bit-vector representation of</span>
<span class="sd">    that NaN.</span>

<span class="sd">    &gt;&gt;&gt; x = FP(&#39;x&#39;, FPSort(8, 24))</span>
<span class="sd">    &gt;&gt;&gt; y = fpToIEEEBV(x)</span>
<span class="sd">    &gt;&gt;&gt; print(is_fp(x))</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; print(is_bv(y))</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; print(is_fp(y))</span>
<span class="sd">    False</span>
<span class="sd">    &gt;&gt;&gt; print(is_bv(x))</span>
<span class="sd">    False</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">z3_debug</span><span class="p">():</span>
        <span class="n">_z3_assert</span><span class="p">(</span><span class="n">is_fp</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="s2">&quot;First argument must be a Z3 floating-point expression&quot;</span><span class="p">)</span>
    <span class="n">ctx</span> <span class="o">=</span> <span class="n">_get_ctx</span><span class="p">(</span><span class="n">ctx</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">BitVecRef</span><span class="p">(</span><span class="n">Z3_mk_fpa_to_ieee_bv</span><span class="p">(</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="n">x</span><span class="o">.</span><span class="n">ast</span><span class="p">),</span> <span class="n">ctx</span><span class="p">)</span>


<span class="c1">#########################################</span>
<span class="c1">#</span>
<span class="c1"># Strings, Sequences and Regular expressions</span>
<span class="c1">#</span>
<span class="c1">#########################################</span>

<span class="k">class</span> <span class="nc">SeqSortRef</span><span class="p">(</span><span class="n">SortRef</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Sequence sort.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">is_string</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Determine if sort is a string</span>
<span class="sd">        &gt;&gt;&gt; s = StringSort()</span>
<span class="sd">        &gt;&gt;&gt; s.is_string()</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; s = SeqSort(IntSort())</span>
<span class="sd">        &gt;&gt;&gt; s.is_string()</span>
<span class="sd">        False</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Z3_is_string_sort</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx_ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">ast</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">basis</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">_to_sort_ref</span><span class="p">(</span><span class="n">Z3_get_seq_sort_basis</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx_ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">ast</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">CharSortRef</span><span class="p">(</span><span class="n">SortRef</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Character sort.&quot;&quot;&quot;</span>


<span class="k">def</span> <span class="nf">StringSort</span><span class="p">(</span><span class="n">ctx</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Create a string sort</span>
<span class="sd">    &gt;&gt;&gt; s = StringSort()</span>
<span class="sd">    &gt;&gt;&gt; print(s)</span>
<span class="sd">    String</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ctx</span> <span class="o">=</span> <span class="n">_get_ctx</span><span class="p">(</span><span class="n">ctx</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">SeqSortRef</span><span class="p">(</span><span class="n">Z3_mk_string_sort</span><span class="p">(</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">()),</span> <span class="n">ctx</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">CharSort</span><span class="p">(</span><span class="n">ctx</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Create a character sort</span>
<span class="sd">    &gt;&gt;&gt; ch = CharSort()</span>
<span class="sd">    &gt;&gt;&gt; print(ch)</span>
<span class="sd">    Char</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ctx</span> <span class="o">=</span> <span class="n">_get_ctx</span><span class="p">(</span><span class="n">ctx</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">CharSortRef</span><span class="p">(</span><span class="n">Z3_mk_char_sort</span><span class="p">(</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">()),</span> <span class="n">ctx</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">SeqSort</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Create a sequence sort over elements provided in the argument</span>
<span class="sd">    &gt;&gt;&gt; s = SeqSort(IntSort())</span>
<span class="sd">    &gt;&gt;&gt; s == Unit(IntVal(1)).sort()</span>
<span class="sd">    True</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">SeqSortRef</span><span class="p">(</span><span class="n">Z3_mk_seq_sort</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">ctx_ref</span><span class="p">(),</span> <span class="n">s</span><span class="o">.</span><span class="n">ast</span><span class="p">),</span> <span class="n">s</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">SeqRef</span><span class="p">(</span><span class="n">ExprRef</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Sequence expression.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">sort</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">SeqSortRef</span><span class="p">(</span><span class="n">Z3_get_sort</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx_ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_ast</span><span class="p">()),</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Concat</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__radd__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Concat</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">_is_int</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">IntVal</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">_to_expr_ref</span><span class="p">(</span><span class="n">Z3_mk_seq_nth</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx_ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_ast</span><span class="p">(),</span> <span class="n">i</span><span class="o">.</span><span class="n">as_ast</span><span class="p">()),</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">at</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">_is_int</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">IntVal</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">SeqRef</span><span class="p">(</span><span class="n">Z3_mk_seq_at</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx_ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_ast</span><span class="p">(),</span> <span class="n">i</span><span class="o">.</span><span class="n">as_ast</span><span class="p">()),</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">is_string</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Z3_is_string_sort</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx_ref</span><span class="p">(),</span> <span class="n">Z3_get_sort</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx_ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_ast</span><span class="p">()))</span>

    <span class="k">def</span> <span class="nf">is_string_value</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Z3_is_string</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx_ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_ast</span><span class="p">())</span>

    <span class="k">def</span> <span class="nf">as_string</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a string representation of sequence expression.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_string_value</span><span class="p">():</span>
            <span class="n">string_length</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_uint</span><span class="p">()</span>
            <span class="n">chars</span> <span class="o">=</span> <span class="n">Z3_get_lstring</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx_ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_ast</span><span class="p">(),</span> <span class="n">byref</span><span class="p">(</span><span class="n">string_length</span><span class="p">))</span>
            <span class="k">return</span> <span class="n">string_at</span><span class="p">(</span><span class="n">chars</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">string_length</span><span class="o">.</span><span class="n">value</span><span class="p">)</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s2">&quot;latin-1&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Z3_ast_to_string</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx_ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_ast</span><span class="p">())</span>

    <span class="k">def</span> <span class="fm">__le__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">_to_expr_ref</span><span class="p">(</span><span class="n">Z3_mk_str_le</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx_ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_ast</span><span class="p">(),</span> <span class="n">other</span><span class="o">.</span><span class="n">as_ast</span><span class="p">()),</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__lt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">_to_expr_ref</span><span class="p">(</span><span class="n">Z3_mk_str_lt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx_ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_ast</span><span class="p">(),</span> <span class="n">other</span><span class="o">.</span><span class="n">as_ast</span><span class="p">()),</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__ge__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">_to_expr_ref</span><span class="p">(</span><span class="n">Z3_mk_str_le</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx_ref</span><span class="p">(),</span> <span class="n">other</span><span class="o">.</span><span class="n">as_ast</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_ast</span><span class="p">()),</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__gt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">_to_expr_ref</span><span class="p">(</span><span class="n">Z3_mk_str_lt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx_ref</span><span class="p">(),</span> <span class="n">other</span><span class="o">.</span><span class="n">as_ast</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_ast</span><span class="p">()),</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_coerce_char</span><span class="p">(</span><span class="n">ch</span><span class="p">,</span> <span class="n">ctx</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ch</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="n">ctx</span> <span class="o">=</span> <span class="n">_get_ctx</span><span class="p">(</span><span class="n">ctx</span><span class="p">)</span>
        <span class="n">ch</span> <span class="o">=</span> <span class="n">CharVal</span><span class="p">(</span><span class="n">ch</span><span class="p">,</span> <span class="n">ctx</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">is_expr</span><span class="p">(</span><span class="n">ch</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">Z3Exception</span><span class="p">(</span><span class="s2">&quot;Character expression expected&quot;</span><span class="p">)</span>    
    <span class="k">return</span> <span class="n">ch</span>

<span class="k">class</span> <span class="nc">CharRef</span><span class="p">(</span><span class="n">ExprRef</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Character expression.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__le__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="n">other</span> <span class="o">=</span> <span class="n">_coerce_char</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">_to_expr_ref</span><span class="p">(</span><span class="n">Z3_mk_char_le</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx_ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_ast</span><span class="p">(),</span> <span class="n">other</span><span class="o">.</span><span class="n">as_ast</span><span class="p">()),</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">to_int</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">_to_expr_ref</span><span class="p">(</span><span class="n">Z3_mk_char_to_int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx_ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_ast</span><span class="p">()),</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">to_bv</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">_to_expr_ref</span><span class="p">(</span><span class="n">Z3_mk_char_to_bv</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx_ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_ast</span><span class="p">()),</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">is_digit</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">_to_expr_ref</span><span class="p">(</span><span class="n">Z3_mk_char_is_digit</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx_ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">as_ast</span><span class="p">()),</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">CharVal</span><span class="p">(</span><span class="n">ch</span><span class="p">,</span> <span class="n">ctx</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="n">ctx</span> <span class="o">=</span> <span class="n">_get_ctx</span><span class="p">(</span><span class="n">ctx</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ch</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="n">ch</span> <span class="o">=</span> <span class="nb">ord</span><span class="p">(</span><span class="n">ch</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ch</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">Z3Exception</span><span class="p">(</span><span class="s2">&quot;character value should be an ordinal&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">_to_expr_ref</span><span class="p">(</span><span class="n">Z3_mk_char</span><span class="p">(</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="n">ch</span><span class="p">),</span> <span class="n">ctx</span><span class="p">)</span>
    
<span class="k">def</span> <span class="nf">CharFromBv</span><span class="p">(</span><span class="n">bv</span><span class="p">):</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">is_expr</span><span class="p">(</span><span class="n">bv</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">Z3Exception</span><span class="p">(</span><span class="s2">&quot;Bit-vector expression needed&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">_to_expr_ref</span><span class="p">(</span><span class="n">Z3_mk_char_from_bv</span><span class="p">(</span><span class="n">bv</span><span class="o">.</span><span class="n">ctx_ref</span><span class="p">(),</span> <span class="n">bv</span><span class="o">.</span><span class="n">as_ast</span><span class="p">()),</span> <span class="n">bv</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">CharToBv</span><span class="p">(</span><span class="n">ch</span><span class="p">,</span> <span class="n">ctx</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="n">ch</span> <span class="o">=</span> <span class="n">_coerce_char</span><span class="p">(</span><span class="n">ch</span><span class="p">,</span> <span class="n">ctx</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">ch</span><span class="o">.</span><span class="n">to_bv</span><span class="p">()</span>

<span class="k">def</span> <span class="nf">CharToInt</span><span class="p">(</span><span class="n">ch</span><span class="p">,</span> <span class="n">ctx</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="n">ch</span> <span class="o">=</span> <span class="n">_coerce_char</span><span class="p">(</span><span class="n">ch</span><span class="p">,</span> <span class="n">ctx</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">ch</span><span class="o">.</span><span class="n">to_int</span><span class="p">()</span>

<span class="k">def</span> <span class="nf">CharIsDigit</span><span class="p">(</span><span class="n">ch</span><span class="p">,</span> <span class="n">ctx</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="n">ch</span> <span class="o">=</span> <span class="n">_coerce_char</span><span class="p">(</span><span class="n">ch</span><span class="p">,</span> <span class="n">ctx</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">ch</span><span class="o">.</span><span class="n">is_digit</span><span class="p">()</span>

<span class="k">def</span> <span class="nf">_coerce_seq</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">ctx</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="n">ctx</span> <span class="o">=</span> <span class="n">_get_ctx</span><span class="p">(</span><span class="n">ctx</span><span class="p">)</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">StringVal</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">ctx</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">is_expr</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">Z3Exception</span><span class="p">(</span><span class="s2">&quot;Non-expression passed as a sequence&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">is_seq</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">Z3Exception</span><span class="p">(</span><span class="s2">&quot;Non-sequence passed as a sequence&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">s</span>


<span class="k">def</span> <span class="nf">_get_ctx2</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">ctx</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">is_expr</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">a</span><span class="o">.</span><span class="n">ctx</span>
    <span class="k">if</span> <span class="n">is_expr</span><span class="p">(</span><span class="n">b</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">b</span><span class="o">.</span><span class="n">ctx</span>
    <span class="k">if</span> <span class="n">ctx</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">ctx</span> <span class="o">=</span> <span class="n">main_ctx</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">ctx</span>


<span class="k">def</span> <span class="nf">is_seq</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return `True` if `a` is a Z3 sequence expression.</span>
<span class="sd">    &gt;&gt;&gt; print (is_seq(Unit(IntVal(0))))</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; print (is_seq(StringVal(&quot;abc&quot;)))</span>
<span class="sd">    True</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">SeqRef</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">is_string</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return `True` if `a` is a Z3 string expression.</span>
<span class="sd">    &gt;&gt;&gt; print (is_string(StringVal(&quot;ab&quot;)))</span>
<span class="sd">    True</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">SeqRef</span><span class="p">)</span> <span class="ow">and</span> <span class="n">a</span><span class="o">.</span><span class="n">is_string</span><span class="p">()</span>


<span class="k">def</span> <span class="nf">is_string_value</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;return &#39;True&#39; if &#39;a&#39; is a Z3 string constant expression.</span>
<span class="sd">    &gt;&gt;&gt; print (is_string_value(StringVal(&quot;a&quot;)))</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; print (is_string_value(StringVal(&quot;a&quot;) + StringVal(&quot;b&quot;)))</span>
<span class="sd">    False</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">SeqRef</span><span class="p">)</span> <span class="ow">and</span> <span class="n">a</span><span class="o">.</span><span class="n">is_string_value</span><span class="p">()</span>

<span class="k">def</span> <span class="nf">StringVal</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">ctx</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;create a string expression&quot;&quot;&quot;</span>
    <span class="n">s</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">ch</span><span class="p">)</span> <span class="k">if</span> <span class="mi">32</span> <span class="o">&lt;=</span> <span class="nb">ord</span><span class="p">(</span><span class="n">ch</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">ord</span><span class="p">(</span><span class="n">ch</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">127</span> <span class="k">else</span> <span class="s2">&quot;</span><span class="se">\\</span><span class="s2">u{</span><span class="si">%x</span><span class="s2">}&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">ord</span><span class="p">(</span><span class="n">ch</span><span class="p">))</span> <span class="k">for</span> <span class="n">ch</span> <span class="ow">in</span> <span class="n">s</span><span class="p">)</span>
    <span class="n">ctx</span> <span class="o">=</span> <span class="n">_get_ctx</span><span class="p">(</span><span class="n">ctx</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">SeqRef</span><span class="p">(</span><span class="n">Z3_mk_string</span><span class="p">(</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="n">s</span><span class="p">),</span> <span class="n">ctx</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">String</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">ctx</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return a string constant named `name`. If `ctx=None`, then the global context is used.</span>

<span class="sd">    &gt;&gt;&gt; x = String(&#39;x&#39;)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ctx</span> <span class="o">=</span> <span class="n">_get_ctx</span><span class="p">(</span><span class="n">ctx</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">SeqRef</span><span class="p">(</span><span class="n">Z3_mk_const</span><span class="p">(</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="n">to_symbol</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">ctx</span><span class="p">),</span> <span class="n">StringSort</span><span class="p">(</span><span class="n">ctx</span><span class="p">)</span><span class="o">.</span><span class="n">ast</span><span class="p">),</span> <span class="n">ctx</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">Strings</span><span class="p">(</span><span class="n">names</span><span class="p">,</span> <span class="n">ctx</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return a tuple of String constants. &quot;&quot;&quot;</span>
    <span class="n">ctx</span> <span class="o">=</span> <span class="n">_get_ctx</span><span class="p">(</span><span class="n">ctx</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">names</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="n">names</span> <span class="o">=</span> <span class="n">names</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot; &quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">String</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">ctx</span><span class="p">)</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">names</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">SubString</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">length</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Extract substring or subsequence starting at offset&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">Extract</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">length</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">SubSeq</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">length</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Extract substring or subsequence starting at offset&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">Extract</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">length</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">Empty</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Create the empty sequence of the given sort</span>
<span class="sd">    &gt;&gt;&gt; e = Empty(StringSort())</span>
<span class="sd">    &gt;&gt;&gt; e2 = StringVal(&quot;&quot;)</span>
<span class="sd">    &gt;&gt;&gt; print(e.eq(e2))</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; e3 = Empty(SeqSort(IntSort()))</span>
<span class="sd">    &gt;&gt;&gt; print(e3)</span>
<span class="sd">    Empty(Seq(Int))</span>
<span class="sd">    &gt;&gt;&gt; e4 = Empty(ReSort(SeqSort(IntSort())))</span>
<span class="sd">    &gt;&gt;&gt; print(e4)</span>
<span class="sd">    Empty(ReSort(Seq(Int)))</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">SeqSortRef</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">SeqRef</span><span class="p">(</span><span class="n">Z3_mk_seq_empty</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">ctx_ref</span><span class="p">(),</span> <span class="n">s</span><span class="o">.</span><span class="n">ast</span><span class="p">),</span> <span class="n">s</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">ReSortRef</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">ReRef</span><span class="p">(</span><span class="n">Z3_mk_re_empty</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">ctx_ref</span><span class="p">(),</span> <span class="n">s</span><span class="o">.</span><span class="n">ast</span><span class="p">),</span> <span class="n">s</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>
    <span class="k">raise</span> <span class="n">Z3Exception</span><span class="p">(</span><span class="s2">&quot;Non-sequence, non-regular expression sort passed to Empty&quot;</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">Full</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Create the regular expression that accepts the universal language</span>
<span class="sd">    &gt;&gt;&gt; e = Full(ReSort(SeqSort(IntSort())))</span>
<span class="sd">    &gt;&gt;&gt; print(e)</span>
<span class="sd">    Full(ReSort(Seq(Int)))</span>
<span class="sd">    &gt;&gt;&gt; e1 = Full(ReSort(StringSort()))</span>
<span class="sd">    &gt;&gt;&gt; print(e1)</span>
<span class="sd">    Full(ReSort(String))</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">ReSortRef</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">ReRef</span><span class="p">(</span><span class="n">Z3_mk_re_full</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">ctx_ref</span><span class="p">(),</span> <span class="n">s</span><span class="o">.</span><span class="n">ast</span><span class="p">),</span> <span class="n">s</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>
    <span class="k">raise</span> <span class="n">Z3Exception</span><span class="p">(</span><span class="s2">&quot;Non-sequence, non-regular expression sort passed to Full&quot;</span><span class="p">)</span>



<span class="k">def</span> <span class="nf">Unit</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Create a singleton sequence&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">SeqRef</span><span class="p">(</span><span class="n">Z3_mk_seq_unit</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">ctx_ref</span><span class="p">(),</span> <span class="n">a</span><span class="o">.</span><span class="n">as_ast</span><span class="p">()),</span> <span class="n">a</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">PrefixOf</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Check if &#39;a&#39; is a prefix of &#39;b&#39;</span>
<span class="sd">    &gt;&gt;&gt; s1 = PrefixOf(&quot;ab&quot;, &quot;abc&quot;)</span>
<span class="sd">    &gt;&gt;&gt; simplify(s1)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; s2 = PrefixOf(&quot;bc&quot;, &quot;abc&quot;)</span>
<span class="sd">    &gt;&gt;&gt; simplify(s2)</span>
<span class="sd">    False</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ctx</span> <span class="o">=</span> <span class="n">_get_ctx2</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">_coerce_seq</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">ctx</span><span class="p">)</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">_coerce_seq</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">ctx</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">BoolRef</span><span class="p">(</span><span class="n">Z3_mk_seq_prefix</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">ctx_ref</span><span class="p">(),</span> <span class="n">a</span><span class="o">.</span><span class="n">as_ast</span><span class="p">(),</span> <span class="n">b</span><span class="o">.</span><span class="n">as_ast</span><span class="p">()),</span> <span class="n">a</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">SuffixOf</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Check if &#39;a&#39; is a suffix of &#39;b&#39;</span>
<span class="sd">    &gt;&gt;&gt; s1 = SuffixOf(&quot;ab&quot;, &quot;abc&quot;)</span>
<span class="sd">    &gt;&gt;&gt; simplify(s1)</span>
<span class="sd">    False</span>
<span class="sd">    &gt;&gt;&gt; s2 = SuffixOf(&quot;bc&quot;, &quot;abc&quot;)</span>
<span class="sd">    &gt;&gt;&gt; simplify(s2)</span>
<span class="sd">    True</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ctx</span> <span class="o">=</span> <span class="n">_get_ctx2</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">_coerce_seq</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">ctx</span><span class="p">)</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">_coerce_seq</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">ctx</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">BoolRef</span><span class="p">(</span><span class="n">Z3_mk_seq_suffix</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">ctx_ref</span><span class="p">(),</span> <span class="n">a</span><span class="o">.</span><span class="n">as_ast</span><span class="p">(),</span> <span class="n">b</span><span class="o">.</span><span class="n">as_ast</span><span class="p">()),</span> <span class="n">a</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">Contains</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Check if &#39;a&#39; contains &#39;b&#39;</span>
<span class="sd">    &gt;&gt;&gt; s1 = Contains(&quot;abc&quot;, &quot;ab&quot;)</span>
<span class="sd">    &gt;&gt;&gt; simplify(s1)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; s2 = Contains(&quot;abc&quot;, &quot;bc&quot;)</span>
<span class="sd">    &gt;&gt;&gt; simplify(s2)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; x, y, z = Strings(&#39;x y z&#39;)</span>
<span class="sd">    &gt;&gt;&gt; s3 = Contains(Concat(x,y,z), y)</span>
<span class="sd">    &gt;&gt;&gt; simplify(s3)</span>
<span class="sd">    True</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ctx</span> <span class="o">=</span> <span class="n">_get_ctx2</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">_coerce_seq</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">ctx</span><span class="p">)</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">_coerce_seq</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">ctx</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">BoolRef</span><span class="p">(</span><span class="n">Z3_mk_seq_contains</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">ctx_ref</span><span class="p">(),</span> <span class="n">a</span><span class="o">.</span><span class="n">as_ast</span><span class="p">(),</span> <span class="n">b</span><span class="o">.</span><span class="n">as_ast</span><span class="p">()),</span> <span class="n">a</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">Replace</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">dst</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Replace the first occurrence of &#39;src&#39; by &#39;dst&#39; in &#39;s&#39;</span>
<span class="sd">    &gt;&gt;&gt; r = Replace(&quot;aaa&quot;, &quot;a&quot;, &quot;b&quot;)</span>
<span class="sd">    &gt;&gt;&gt; simplify(r)</span>
<span class="sd">    &quot;baa&quot;</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ctx</span> <span class="o">=</span> <span class="n">_get_ctx2</span><span class="p">(</span><span class="n">dst</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">ctx</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">is_expr</span><span class="p">(</span><span class="n">src</span><span class="p">):</span>
        <span class="n">ctx</span> <span class="o">=</span> <span class="n">src</span><span class="o">.</span><span class="n">ctx</span>
    <span class="n">src</span> <span class="o">=</span> <span class="n">_coerce_seq</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">ctx</span><span class="p">)</span>
    <span class="n">dst</span> <span class="o">=</span> <span class="n">_coerce_seq</span><span class="p">(</span><span class="n">dst</span><span class="p">,</span> <span class="n">ctx</span><span class="p">)</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">_coerce_seq</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">ctx</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">SeqRef</span><span class="p">(</span><span class="n">Z3_mk_seq_replace</span><span class="p">(</span><span class="n">src</span><span class="o">.</span><span class="n">ctx_ref</span><span class="p">(),</span> <span class="n">s</span><span class="o">.</span><span class="n">as_ast</span><span class="p">(),</span> <span class="n">src</span><span class="o">.</span><span class="n">as_ast</span><span class="p">(),</span> <span class="n">dst</span><span class="o">.</span><span class="n">as_ast</span><span class="p">()),</span> <span class="n">s</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">IndexOf</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">substr</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Retrieve the index of substring within a string starting at a specified offset.</span>
<span class="sd">    &gt;&gt;&gt; simplify(IndexOf(&quot;abcabc&quot;, &quot;bc&quot;, 0))</span>
<span class="sd">    1</span>
<span class="sd">    &gt;&gt;&gt; simplify(IndexOf(&quot;abcabc&quot;, &quot;bc&quot;, 2))</span>
<span class="sd">    4</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">offset</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">offset</span> <span class="o">=</span> <span class="n">IntVal</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">ctx</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="n">is_expr</span><span class="p">(</span><span class="n">offset</span><span class="p">):</span>
        <span class="n">ctx</span> <span class="o">=</span> <span class="n">offset</span><span class="o">.</span><span class="n">ctx</span>
    <span class="n">ctx</span> <span class="o">=</span> <span class="n">_get_ctx2</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">substr</span><span class="p">,</span> <span class="n">ctx</span><span class="p">)</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">_coerce_seq</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">ctx</span><span class="p">)</span>
    <span class="n">substr</span> <span class="o">=</span> <span class="n">_coerce_seq</span><span class="p">(</span><span class="n">substr</span><span class="p">,</span> <span class="n">ctx</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">_is_int</span><span class="p">(</span><span class="n">offset</span><span class="p">):</span>
        <span class="n">offset</span> <span class="o">=</span> <span class="n">IntVal</span><span class="p">(</span><span class="n">offset</span><span class="p">,</span> <span class="n">ctx</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">ArithRef</span><span class="p">(</span><span class="n">Z3_mk_seq_index</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">ctx_ref</span><span class="p">(),</span> <span class="n">s</span><span class="o">.</span><span class="n">as_ast</span><span class="p">(),</span> <span class="n">substr</span><span class="o">.</span><span class="n">as_ast</span><span class="p">(),</span> <span class="n">offset</span><span class="o">.</span><span class="n">as_ast</span><span class="p">()),</span> <span class="n">s</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">LastIndexOf</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">substr</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Retrieve the last index of substring within a string&quot;&quot;&quot;</span>
    <span class="n">ctx</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">ctx</span> <span class="o">=</span> <span class="n">_get_ctx2</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">substr</span><span class="p">,</span> <span class="n">ctx</span><span class="p">)</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">_coerce_seq</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">ctx</span><span class="p">)</span>
    <span class="n">substr</span> <span class="o">=</span> <span class="n">_coerce_seq</span><span class="p">(</span><span class="n">substr</span><span class="p">,</span> <span class="n">ctx</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">ArithRef</span><span class="p">(</span><span class="n">Z3_mk_seq_last_index</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">ctx_ref</span><span class="p">(),</span> <span class="n">s</span><span class="o">.</span><span class="n">as_ast</span><span class="p">(),</span> <span class="n">substr</span><span class="o">.</span><span class="n">as_ast</span><span class="p">()),</span> <span class="n">s</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">Length</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Obtain the length of a sequence &#39;s&#39;</span>
<span class="sd">    &gt;&gt;&gt; l = Length(StringVal(&quot;abc&quot;))</span>
<span class="sd">    &gt;&gt;&gt; simplify(l)</span>
<span class="sd">    3</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">_coerce_seq</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">ArithRef</span><span class="p">(</span><span class="n">Z3_mk_seq_length</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">ctx_ref</span><span class="p">(),</span> <span class="n">s</span><span class="o">.</span><span class="n">as_ast</span><span class="p">()),</span> <span class="n">s</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">StrToInt</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Convert string expression to integer</span>
<span class="sd">    &gt;&gt;&gt; a = StrToInt(&quot;1&quot;)</span>
<span class="sd">    &gt;&gt;&gt; simplify(1 == a)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; b = StrToInt(&quot;2&quot;)</span>
<span class="sd">    &gt;&gt;&gt; simplify(1 == b)</span>
<span class="sd">    False</span>
<span class="sd">    &gt;&gt;&gt; c = StrToInt(IntToStr(2))</span>
<span class="sd">    &gt;&gt;&gt; simplify(1 == c)</span>
<span class="sd">    False</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">_coerce_seq</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">ArithRef</span><span class="p">(</span><span class="n">Z3_mk_str_to_int</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">ctx_ref</span><span class="p">(),</span> <span class="n">s</span><span class="o">.</span><span class="n">as_ast</span><span class="p">()),</span> <span class="n">s</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">IntToStr</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Convert integer expression to string&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">is_expr</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">_py2expr</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">SeqRef</span><span class="p">(</span><span class="n">Z3_mk_int_to_str</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">ctx_ref</span><span class="p">(),</span> <span class="n">s</span><span class="o">.</span><span class="n">as_ast</span><span class="p">()),</span> <span class="n">s</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">StrToCode</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Convert a unit length string to integer code&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">is_expr</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">_py2expr</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">ArithRef</span><span class="p">(</span><span class="n">Z3_mk_string_to_code</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">ctx_ref</span><span class="p">(),</span> <span class="n">s</span><span class="o">.</span><span class="n">as_ast</span><span class="p">()),</span> <span class="n">s</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">StrFromCode</span><span class="p">(</span><span class="n">c</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Convert code to a string&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">is_expr</span><span class="p">(</span><span class="n">c</span><span class="p">):</span>
        <span class="n">c</span> <span class="o">=</span> <span class="n">_py2expr</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">SeqRef</span><span class="p">(</span><span class="n">Z3_mk_string_from_code</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">ctx_ref</span><span class="p">(),</span> <span class="n">c</span><span class="o">.</span><span class="n">as_ast</span><span class="p">()),</span> <span class="n">c</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>
    
<span class="k">def</span> <span class="nf">Re</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">ctx</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;The regular expression that accepts sequence &#39;s&#39;</span>
<span class="sd">    &gt;&gt;&gt; s1 = Re(&quot;ab&quot;)</span>
<span class="sd">    &gt;&gt;&gt; s2 = Re(StringVal(&quot;ab&quot;))</span>
<span class="sd">    &gt;&gt;&gt; s3 = Re(Unit(BoolVal(True)))</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">_coerce_seq</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">ctx</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">ReRef</span><span class="p">(</span><span class="n">Z3_mk_seq_to_re</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">ctx_ref</span><span class="p">(),</span> <span class="n">s</span><span class="o">.</span><span class="n">as_ast</span><span class="p">()),</span> <span class="n">s</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>


<span class="c1"># Regular expressions</span>

<span class="k">class</span> <span class="nc">ReSortRef</span><span class="p">(</span><span class="n">SortRef</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Regular expression sort.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">basis</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">_to_sort_ref</span><span class="p">(</span><span class="n">Z3_get_re_sort_basis</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx_ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">ast</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">ReSort</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">is_ast</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">ReSortRef</span><span class="p">(</span><span class="n">Z3_mk_re_sort</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="n">s</span><span class="o">.</span><span class="n">ast</span><span class="p">),</span> <span class="n">s</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">s</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">Context</span><span class="p">):</span>
        <span class="n">ctx</span> <span class="o">=</span> <span class="n">_get_ctx</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ReSortRef</span><span class="p">(</span><span class="n">Z3_mk_re_sort</span><span class="p">(</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="n">Z3_mk_string_sort</span><span class="p">(</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">())),</span> <span class="n">s</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>
    <span class="k">raise</span> <span class="n">Z3Exception</span><span class="p">(</span><span class="s2">&quot;Regular expression sort constructor expects either a string or a context or no argument&quot;</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">ReRef</span><span class="p">(</span><span class="n">ExprRef</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Regular expressions.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Union</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">is_re</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">ReRef</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">InRe</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">re</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Create regular expression membership test</span>
<span class="sd">    &gt;&gt;&gt; re = Union(Re(&quot;a&quot;),Re(&quot;b&quot;))</span>
<span class="sd">    &gt;&gt;&gt; print (simplify(InRe(&quot;a&quot;, re)))</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; print (simplify(InRe(&quot;b&quot;, re)))</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; print (simplify(InRe(&quot;c&quot;, re)))</span>
<span class="sd">    False</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">_coerce_seq</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">BoolRef</span><span class="p">(</span><span class="n">Z3_mk_seq_in_re</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">ctx_ref</span><span class="p">(),</span> <span class="n">s</span><span class="o">.</span><span class="n">as_ast</span><span class="p">(),</span> <span class="n">re</span><span class="o">.</span><span class="n">as_ast</span><span class="p">()),</span> <span class="n">s</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">Union</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Create union of regular expressions.</span>
<span class="sd">    &gt;&gt;&gt; re = Union(Re(&quot;a&quot;), Re(&quot;b&quot;), Re(&quot;c&quot;))</span>
<span class="sd">    &gt;&gt;&gt; print (simplify(InRe(&quot;d&quot;, re)))</span>
<span class="sd">    False</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">args</span> <span class="o">=</span> <span class="n">_get_args</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
    <span class="n">sz</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">z3_debug</span><span class="p">():</span>
        <span class="n">_z3_assert</span><span class="p">(</span><span class="n">sz</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;At least one argument expected.&quot;</span><span class="p">)</span>
        <span class="n">_z3_assert</span><span class="p">(</span><span class="nb">all</span><span class="p">([</span><span class="n">is_re</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">args</span><span class="p">]),</span> <span class="s2">&quot;All arguments must be regular expressions.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">sz</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">ctx</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">ctx</span>
    <span class="n">v</span> <span class="o">=</span> <span class="p">(</span><span class="n">Ast</span> <span class="o">*</span> <span class="n">sz</span><span class="p">)()</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">sz</span><span class="p">):</span>
        <span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">as_ast</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">ReRef</span><span class="p">(</span><span class="n">Z3_mk_re_union</span><span class="p">(</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="n">sz</span><span class="p">,</span> <span class="n">v</span><span class="p">),</span> <span class="n">ctx</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">Intersect</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Create intersection of regular expressions.</span>
<span class="sd">    &gt;&gt;&gt; re = Intersect(Re(&quot;a&quot;), Re(&quot;b&quot;), Re(&quot;c&quot;))</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">args</span> <span class="o">=</span> <span class="n">_get_args</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
    <span class="n">sz</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">z3_debug</span><span class="p">():</span>
        <span class="n">_z3_assert</span><span class="p">(</span><span class="n">sz</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;At least one argument expected.&quot;</span><span class="p">)</span>
        <span class="n">_z3_assert</span><span class="p">(</span><span class="nb">all</span><span class="p">([</span><span class="n">is_re</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">args</span><span class="p">]),</span> <span class="s2">&quot;All arguments must be regular expressions.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">sz</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">ctx</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">ctx</span>
    <span class="n">v</span> <span class="o">=</span> <span class="p">(</span><span class="n">Ast</span> <span class="o">*</span> <span class="n">sz</span><span class="p">)()</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">sz</span><span class="p">):</span>
        <span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">as_ast</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">ReRef</span><span class="p">(</span><span class="n">Z3_mk_re_intersect</span><span class="p">(</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="n">sz</span><span class="p">,</span> <span class="n">v</span><span class="p">),</span> <span class="n">ctx</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">Plus</span><span class="p">(</span><span class="n">re</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Create the regular expression accepting one or more repetitions of argument.</span>
<span class="sd">    &gt;&gt;&gt; re = Plus(Re(&quot;a&quot;))</span>
<span class="sd">    &gt;&gt;&gt; print(simplify(InRe(&quot;aa&quot;, re)))</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; print(simplify(InRe(&quot;ab&quot;, re)))</span>
<span class="sd">    False</span>
<span class="sd">    &gt;&gt;&gt; print(simplify(InRe(&quot;&quot;, re)))</span>
<span class="sd">    False</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">z3_debug</span><span class="p">():</span>
        <span class="n">_z3_assert</span><span class="p">(</span><span class="n">is_expr</span><span class="p">(</span><span class="n">re</span><span class="p">),</span> <span class="s2">&quot;expression expected&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">ReRef</span><span class="p">(</span><span class="n">Z3_mk_re_plus</span><span class="p">(</span><span class="n">re</span><span class="o">.</span><span class="n">ctx_ref</span><span class="p">(),</span> <span class="n">re</span><span class="o">.</span><span class="n">as_ast</span><span class="p">()),</span> <span class="n">re</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">Option</span><span class="p">(</span><span class="n">re</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Create the regular expression that optionally accepts the argument.</span>
<span class="sd">    &gt;&gt;&gt; re = Option(Re(&quot;a&quot;))</span>
<span class="sd">    &gt;&gt;&gt; print(simplify(InRe(&quot;a&quot;, re)))</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; print(simplify(InRe(&quot;&quot;, re)))</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; print(simplify(InRe(&quot;aa&quot;, re)))</span>
<span class="sd">    False</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">z3_debug</span><span class="p">():</span>
        <span class="n">_z3_assert</span><span class="p">(</span><span class="n">is_expr</span><span class="p">(</span><span class="n">re</span><span class="p">),</span> <span class="s2">&quot;expression expected&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">ReRef</span><span class="p">(</span><span class="n">Z3_mk_re_option</span><span class="p">(</span><span class="n">re</span><span class="o">.</span><span class="n">ctx_ref</span><span class="p">(),</span> <span class="n">re</span><span class="o">.</span><span class="n">as_ast</span><span class="p">()),</span> <span class="n">re</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">Complement</span><span class="p">(</span><span class="n">re</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Create the complement regular expression.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ReRef</span><span class="p">(</span><span class="n">Z3_mk_re_complement</span><span class="p">(</span><span class="n">re</span><span class="o">.</span><span class="n">ctx_ref</span><span class="p">(),</span> <span class="n">re</span><span class="o">.</span><span class="n">as_ast</span><span class="p">()),</span> <span class="n">re</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">Star</span><span class="p">(</span><span class="n">re</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Create the regular expression accepting zero or more repetitions of argument.</span>
<span class="sd">    &gt;&gt;&gt; re = Star(Re(&quot;a&quot;))</span>
<span class="sd">    &gt;&gt;&gt; print(simplify(InRe(&quot;aa&quot;, re)))</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; print(simplify(InRe(&quot;ab&quot;, re)))</span>
<span class="sd">    False</span>
<span class="sd">    &gt;&gt;&gt; print(simplify(InRe(&quot;&quot;, re)))</span>
<span class="sd">    True</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">z3_debug</span><span class="p">():</span>
        <span class="n">_z3_assert</span><span class="p">(</span><span class="n">is_expr</span><span class="p">(</span><span class="n">re</span><span class="p">),</span> <span class="s2">&quot;expression expected&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">ReRef</span><span class="p">(</span><span class="n">Z3_mk_re_star</span><span class="p">(</span><span class="n">re</span><span class="o">.</span><span class="n">ctx_ref</span><span class="p">(),</span> <span class="n">re</span><span class="o">.</span><span class="n">as_ast</span><span class="p">()),</span> <span class="n">re</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">Loop</span><span class="p">(</span><span class="n">re</span><span class="p">,</span> <span class="n">lo</span><span class="p">,</span> <span class="n">hi</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Create the regular expression accepting between a lower and upper bound repetitions</span>
<span class="sd">    &gt;&gt;&gt; re = Loop(Re(&quot;a&quot;), 1, 3)</span>
<span class="sd">    &gt;&gt;&gt; print(simplify(InRe(&quot;aa&quot;, re)))</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; print(simplify(InRe(&quot;aaaa&quot;, re)))</span>
<span class="sd">    False</span>
<span class="sd">    &gt;&gt;&gt; print(simplify(InRe(&quot;&quot;, re)))</span>
<span class="sd">    False</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">z3_debug</span><span class="p">():</span>
        <span class="n">_z3_assert</span><span class="p">(</span><span class="n">is_expr</span><span class="p">(</span><span class="n">re</span><span class="p">),</span> <span class="s2">&quot;expression expected&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">ReRef</span><span class="p">(</span><span class="n">Z3_mk_re_loop</span><span class="p">(</span><span class="n">re</span><span class="o">.</span><span class="n">ctx_ref</span><span class="p">(),</span> <span class="n">re</span><span class="o">.</span><span class="n">as_ast</span><span class="p">(),</span> <span class="n">lo</span><span class="p">,</span> <span class="n">hi</span><span class="p">),</span> <span class="n">re</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">Range</span><span class="p">(</span><span class="n">lo</span><span class="p">,</span> <span class="n">hi</span><span class="p">,</span> <span class="n">ctx</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Create the range regular expression over two sequences of length 1</span>
<span class="sd">    &gt;&gt;&gt; range = Range(&quot;a&quot;,&quot;z&quot;)</span>
<span class="sd">    &gt;&gt;&gt; print(simplify(InRe(&quot;b&quot;, range)))</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; print(simplify(InRe(&quot;bb&quot;, range)))</span>
<span class="sd">    False</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">lo</span> <span class="o">=</span> <span class="n">_coerce_seq</span><span class="p">(</span><span class="n">lo</span><span class="p">,</span> <span class="n">ctx</span><span class="p">)</span>
    <span class="n">hi</span> <span class="o">=</span> <span class="n">_coerce_seq</span><span class="p">(</span><span class="n">hi</span><span class="p">,</span> <span class="n">ctx</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">z3_debug</span><span class="p">():</span>
        <span class="n">_z3_assert</span><span class="p">(</span><span class="n">is_expr</span><span class="p">(</span><span class="n">lo</span><span class="p">),</span> <span class="s2">&quot;expression expected&quot;</span><span class="p">)</span>
        <span class="n">_z3_assert</span><span class="p">(</span><span class="n">is_expr</span><span class="p">(</span><span class="n">hi</span><span class="p">),</span> <span class="s2">&quot;expression expected&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">ReRef</span><span class="p">(</span><span class="n">Z3_mk_re_range</span><span class="p">(</span><span class="n">lo</span><span class="o">.</span><span class="n">ctx_ref</span><span class="p">(),</span> <span class="n">lo</span><span class="o">.</span><span class="n">ast</span><span class="p">,</span> <span class="n">hi</span><span class="o">.</span><span class="n">ast</span><span class="p">),</span> <span class="n">lo</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">Diff</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">ctx</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Create the difference regular expression</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">z3_debug</span><span class="p">():</span>
        <span class="n">_z3_assert</span><span class="p">(</span><span class="n">is_expr</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="s2">&quot;expression expected&quot;</span><span class="p">)</span>
        <span class="n">_z3_assert</span><span class="p">(</span><span class="n">is_expr</span><span class="p">(</span><span class="n">b</span><span class="p">),</span> <span class="s2">&quot;expression expected&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">ReRef</span><span class="p">(</span><span class="n">Z3_mk_re_diff</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">ctx_ref</span><span class="p">(),</span> <span class="n">a</span><span class="o">.</span><span class="n">ast</span><span class="p">,</span> <span class="n">b</span><span class="o">.</span><span class="n">ast</span><span class="p">),</span> <span class="n">a</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">AllChar</span><span class="p">(</span><span class="n">regex_sort</span><span class="p">,</span> <span class="n">ctx</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Create a regular expression that accepts all single character strings</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ReRef</span><span class="p">(</span><span class="n">Z3_mk_re_allchar</span><span class="p">(</span><span class="n">regex_sort</span><span class="o">.</span><span class="n">ctx_ref</span><span class="p">(),</span> <span class="n">regex_sort</span><span class="o">.</span><span class="n">ast</span><span class="p">),</span> <span class="n">regex_sort</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>

<span class="c1"># Special Relations</span>


<span class="k">def</span> <span class="nf">PartialOrder</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">FuncDeclRef</span><span class="p">(</span><span class="n">Z3_mk_partial_order</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">ctx_ref</span><span class="p">(),</span> <span class="n">a</span><span class="o">.</span><span class="n">ast</span><span class="p">,</span> <span class="n">index</span><span class="p">),</span> <span class="n">a</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">LinearOrder</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">FuncDeclRef</span><span class="p">(</span><span class="n">Z3_mk_linear_order</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">ctx_ref</span><span class="p">(),</span> <span class="n">a</span><span class="o">.</span><span class="n">ast</span><span class="p">,</span> <span class="n">index</span><span class="p">),</span> <span class="n">a</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">TreeOrder</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">FuncDeclRef</span><span class="p">(</span><span class="n">Z3_mk_tree_order</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">ctx_ref</span><span class="p">(),</span> <span class="n">a</span><span class="o">.</span><span class="n">ast</span><span class="p">,</span> <span class="n">index</span><span class="p">),</span> <span class="n">a</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">PiecewiseLinearOrder</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">FuncDeclRef</span><span class="p">(</span><span class="n">Z3_mk_piecewise_linear_order</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">ctx_ref</span><span class="p">(),</span> <span class="n">a</span><span class="o">.</span><span class="n">ast</span><span class="p">,</span> <span class="n">index</span><span class="p">),</span> <span class="n">a</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">TransitiveClosure</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Given a binary relation R, such that the two arguments have the same sort</span>
<span class="sd">    create the transitive closure relation R+.</span>
<span class="sd">    The transitive closure R+ is a new relation.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">FuncDeclRef</span><span class="p">(</span><span class="n">Z3_mk_transitive_closure</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">ctx_ref</span><span class="p">(),</span> <span class="n">f</span><span class="o">.</span><span class="n">ast</span><span class="p">),</span> <span class="n">f</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">to_Ast</span><span class="p">(</span><span class="n">ptr</span><span class="p">,):</span>
    <span class="n">ast</span> <span class="o">=</span> <span class="n">Ast</span><span class="p">(</span><span class="n">ptr</span><span class="p">)</span>
    <span class="nb">super</span><span class="p">(</span><span class="n">ctypes</span><span class="o">.</span><span class="n">c_void_p</span><span class="p">,</span> <span class="n">ast</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">ptr</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">ast</span>

<span class="k">def</span> <span class="nf">to_ContextObj</span><span class="p">(</span><span class="n">ptr</span><span class="p">,):</span>
    <span class="n">ctx</span> <span class="o">=</span> <span class="n">ContextObj</span><span class="p">(</span><span class="n">ptr</span><span class="p">)</span>
    <span class="nb">super</span><span class="p">(</span><span class="n">ctypes</span><span class="o">.</span><span class="n">c_void_p</span><span class="p">,</span> <span class="n">ctx</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">ptr</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">ctx</span>

<span class="k">def</span> <span class="nf">to_AstVectorObj</span><span class="p">(</span><span class="n">ptr</span><span class="p">,):</span>
    <span class="n">v</span> <span class="o">=</span> <span class="n">AstVectorObj</span><span class="p">(</span><span class="n">ptr</span><span class="p">)</span>
    <span class="nb">super</span><span class="p">(</span><span class="n">ctypes</span><span class="o">.</span><span class="n">c_void_p</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">ptr</span><span class="p">)</span>    
    <span class="k">return</span> <span class="n">v</span>

<span class="c1"># NB. my-hacky-class only works for a single instance of OnClause</span>
<span class="c1"># it should be replaced with a proper correlation between OnClause</span>
<span class="c1"># and object references that can be passed over the FFI.</span>
<span class="c1"># for UserPropagator we use a global dictionary, which isn&#39;t great code.</span>

<span class="n">_my_hacky_class</span> <span class="o">=</span> <span class="kc">None</span>
<span class="k">def</span> <span class="nf">on_clause_eh</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">dep</span><span class="p">,</span> <span class="n">clause</span><span class="p">):</span>
    <span class="n">onc</span> <span class="o">=</span> <span class="n">_my_hacky_class</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">_to_expr_ref</span><span class="p">(</span><span class="n">to_Ast</span><span class="p">(</span><span class="n">p</span><span class="p">),</span> <span class="n">onc</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>
    <span class="n">clause</span> <span class="o">=</span> <span class="n">AstVector</span><span class="p">(</span><span class="n">to_AstVectorObj</span><span class="p">(</span><span class="n">clause</span><span class="p">),</span> <span class="n">onc</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>
    <span class="n">deps</span> <span class="o">=</span> <span class="p">[</span><span class="n">dep</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)]</span>
    <span class="n">onc</span><span class="o">.</span><span class="n">on_clause</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">deps</span><span class="p">,</span> <span class="n">clause</span><span class="p">)</span>
    
<span class="n">_on_clause_eh</span> <span class="o">=</span> <span class="n">Z3_on_clause_eh</span><span class="p">(</span><span class="n">on_clause_eh</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">OnClause</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">on_clause</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">s</span> <span class="o">=</span> <span class="n">s</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">ctx</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">on_clause</span> <span class="o">=</span> <span class="n">on_clause</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">idx</span> <span class="o">=</span> <span class="mi">22</span>
        <span class="k">global</span> <span class="n">_my_hacky_class</span>
        <span class="n">_my_hacky_class</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="n">Z3_solver_register_on_clause</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">s</span><span class="o">.</span><span class="n">solver</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">idx</span><span class="p">,</span> <span class="n">_on_clause_eh</span><span class="p">)</span>        
        

<span class="k">class</span> <span class="nc">PropClosures</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bases</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lock</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">set_threaded</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">lock</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="kn">import</span> <span class="nn">threading</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">lock</span> <span class="o">=</span> <span class="n">threading</span><span class="o">.</span><span class="n">Lock</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ctx</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">lock</span><span class="p">:</span>
            <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">lock</span><span class="p">:</span>
                <span class="n">r</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bases</span><span class="p">[</span><span class="n">ctx</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">r</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bases</span><span class="p">[</span><span class="n">ctx</span><span class="p">]</span>            
        <span class="k">return</span> <span class="n">r</span>

    <span class="k">def</span> <span class="nf">set</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ctx</span><span class="p">,</span> <span class="n">r</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">lock</span><span class="p">:</span>
            <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">lock</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">bases</span><span class="p">[</span><span class="n">ctx</span><span class="p">]</span> <span class="o">=</span> <span class="n">r</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">bases</span><span class="p">[</span><span class="n">ctx</span><span class="p">]</span> <span class="o">=</span> <span class="n">r</span>

    <span class="k">def</span> <span class="nf">insert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">r</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">lock</span><span class="p">:</span>
            <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">lock</span><span class="p">:</span>
                <span class="nb">id</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bases</span><span class="p">)</span> <span class="o">+</span> <span class="mi">3</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">bases</span><span class="p">[</span><span class="nb">id</span><span class="p">]</span> <span class="o">=</span> <span class="n">r</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">id</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bases</span><span class="p">)</span> <span class="o">+</span> <span class="mi">3</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">bases</span><span class="p">[</span><span class="nb">id</span><span class="p">]</span> <span class="o">=</span> <span class="n">r</span>
        <span class="k">return</span> <span class="nb">id</span>


<span class="n">_prop_closures</span> <span class="o">=</span> <span class="kc">None</span>


<span class="k">def</span> <span class="nf">ensure_prop_closures</span><span class="p">():</span>
    <span class="k">global</span> <span class="n">_prop_closures</span>
    <span class="k">if</span> <span class="n">_prop_closures</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">_prop_closures</span> <span class="o">=</span> <span class="n">PropClosures</span><span class="p">()</span>


<span class="k">def</span> <span class="nf">user_prop_push</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">cb</span><span class="p">):</span>
    <span class="n">prop</span> <span class="o">=</span> <span class="n">_prop_closures</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">ctx</span><span class="p">)</span>
    <span class="n">prop</span><span class="o">.</span><span class="n">cb</span> <span class="o">=</span> <span class="n">cb</span>
    <span class="n">prop</span><span class="o">.</span><span class="n">push</span><span class="p">()</span>


<span class="k">def</span> <span class="nf">user_prop_pop</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">cb</span><span class="p">,</span> <span class="n">num_scopes</span><span class="p">):</span>
    <span class="n">prop</span> <span class="o">=</span> <span class="n">_prop_closures</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">ctx</span><span class="p">)</span>
    <span class="n">prop</span><span class="o">.</span><span class="n">cb</span> <span class="o">=</span> <span class="n">cb</span>
    <span class="n">prop</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">num_scopes</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">user_prop_fresh</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">_new_ctx</span><span class="p">):</span>
    <span class="n">_prop_closures</span><span class="o">.</span><span class="n">set_threaded</span><span class="p">()</span>
    <span class="n">prop</span> <span class="o">=</span> <span class="n">_prop_closures</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">ctx</span><span class="p">)</span>
    <span class="n">nctx</span> <span class="o">=</span> <span class="n">Context</span><span class="p">()</span>
    <span class="n">Z3_del_context</span><span class="p">(</span><span class="n">nctx</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span>
    <span class="n">new_ctx</span> <span class="o">=</span> <span class="n">to_ContextObj</span><span class="p">(</span><span class="n">_new_ctx</span><span class="p">)</span>
    <span class="n">nctx</span><span class="o">.</span><span class="n">ctx</span> <span class="o">=</span> <span class="n">new_ctx</span>
    <span class="n">nctx</span><span class="o">.</span><span class="n">eh</span> <span class="o">=</span> <span class="n">Z3_set_error_handler</span><span class="p">(</span><span class="n">new_ctx</span><span class="p">,</span> <span class="n">z3_error_handler</span><span class="p">)</span>
    <span class="n">nctx</span><span class="o">.</span><span class="n">owner</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">new_prop</span> <span class="o">=</span> <span class="n">prop</span><span class="o">.</span><span class="n">fresh</span><span class="p">(</span><span class="n">nctx</span><span class="p">)</span>
    <span class="n">_prop_closures</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">new_prop</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">new_prop</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">new_prop</span><span class="o">.</span><span class="n">id</span>


<span class="k">def</span> <span class="nf">user_prop_fixed</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">cb</span><span class="p">,</span> <span class="nb">id</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
    <span class="n">prop</span> <span class="o">=</span> <span class="n">_prop_closures</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">ctx</span><span class="p">)</span>
    <span class="n">prop</span><span class="o">.</span><span class="n">cb</span> <span class="o">=</span> <span class="n">cb</span>
    <span class="nb">id</span> <span class="o">=</span> <span class="n">_to_expr_ref</span><span class="p">(</span><span class="n">to_Ast</span><span class="p">(</span><span class="nb">id</span><span class="p">),</span> <span class="n">prop</span><span class="o">.</span><span class="n">ctx</span><span class="p">())</span>
    <span class="n">value</span> <span class="o">=</span> <span class="n">_to_expr_ref</span><span class="p">(</span><span class="n">to_Ast</span><span class="p">(</span><span class="n">value</span><span class="p">),</span> <span class="n">prop</span><span class="o">.</span><span class="n">ctx</span><span class="p">())</span>
    <span class="n">prop</span><span class="o">.</span><span class="n">fixed</span><span class="p">(</span><span class="nb">id</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
    <span class="n">prop</span><span class="o">.</span><span class="n">cb</span> <span class="o">=</span> <span class="kc">None</span>

<span class="k">def</span> <span class="nf">user_prop_created</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">cb</span><span class="p">,</span> <span class="nb">id</span><span class="p">):</span>
    <span class="n">prop</span> <span class="o">=</span> <span class="n">_prop_closures</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">ctx</span><span class="p">)</span>
    <span class="n">prop</span><span class="o">.</span><span class="n">cb</span> <span class="o">=</span> <span class="n">cb</span>
    <span class="nb">id</span> <span class="o">=</span> <span class="n">_to_expr_ref</span><span class="p">(</span><span class="n">to_Ast</span><span class="p">(</span><span class="nb">id</span><span class="p">),</span> <span class="n">prop</span><span class="o">.</span><span class="n">ctx</span><span class="p">())</span>
    <span class="n">prop</span><span class="o">.</span><span class="n">created</span><span class="p">(</span><span class="nb">id</span><span class="p">)</span>
    <span class="n">prop</span><span class="o">.</span><span class="n">cb</span> <span class="o">=</span> <span class="kc">None</span>
    
<span class="k">def</span> <span class="nf">user_prop_final</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">cb</span><span class="p">):</span>
    <span class="n">prop</span> <span class="o">=</span> <span class="n">_prop_closures</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">ctx</span><span class="p">)</span>
    <span class="n">prop</span><span class="o">.</span><span class="n">cb</span> <span class="o">=</span> <span class="n">cb</span>
    <span class="n">prop</span><span class="o">.</span><span class="n">final</span><span class="p">()</span>
    <span class="n">prop</span><span class="o">.</span><span class="n">cb</span> <span class="o">=</span> <span class="kc">None</span>

<span class="k">def</span> <span class="nf">user_prop_eq</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">cb</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
    <span class="n">prop</span> <span class="o">=</span> <span class="n">_prop_closures</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">ctx</span><span class="p">)</span>
    <span class="n">prop</span><span class="o">.</span><span class="n">cb</span> <span class="o">=</span> <span class="n">cb</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">_to_expr_ref</span><span class="p">(</span><span class="n">to_Ast</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">prop</span><span class="o">.</span><span class="n">ctx</span><span class="p">())</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">_to_expr_ref</span><span class="p">(</span><span class="n">to_Ast</span><span class="p">(</span><span class="n">y</span><span class="p">),</span> <span class="n">prop</span><span class="o">.</span><span class="n">ctx</span><span class="p">())</span>
    <span class="n">prop</span><span class="o">.</span><span class="n">eq</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
    <span class="n">prop</span><span class="o">.</span><span class="n">cb</span> <span class="o">=</span> <span class="kc">None</span>

<span class="k">def</span> <span class="nf">user_prop_diseq</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">cb</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
    <span class="n">prop</span> <span class="o">=</span> <span class="n">_prop_closures</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">ctx</span><span class="p">)</span>
    <span class="n">prop</span><span class="o">.</span><span class="n">cb</span> <span class="o">=</span> <span class="n">cb</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">_to_expr_ref</span><span class="p">(</span><span class="n">to_Ast</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">prop</span><span class="o">.</span><span class="n">ctx</span><span class="p">())</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">_to_expr_ref</span><span class="p">(</span><span class="n">to_Ast</span><span class="p">(</span><span class="n">y</span><span class="p">),</span> <span class="n">prop</span><span class="o">.</span><span class="n">ctx</span><span class="p">())</span>
    <span class="n">prop</span><span class="o">.</span><span class="n">diseq</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
    <span class="n">prop</span><span class="o">.</span><span class="n">cb</span> <span class="o">=</span> <span class="kc">None</span>

<span class="k">def</span> <span class="nf">user_prop_decide</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">cb</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">phase</span><span class="p">):</span>
    <span class="n">prop</span> <span class="o">=</span> <span class="n">_prop_closures</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">ctx</span><span class="p">)</span>
    <span class="n">prop</span><span class="o">.</span><span class="n">cb</span> <span class="o">=</span> <span class="n">cb</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">_to_expr_ref</span><span class="p">(</span><span class="n">to_Ast</span><span class="p">(</span><span class="n">t_ref</span><span class="p">),</span> <span class="n">prop</span><span class="o">.</span><span class="n">ctx</span><span class="p">())</span>
    <span class="n">prop</span><span class="o">.</span><span class="n">decide</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">phase</span><span class="p">)</span>
    <span class="n">prop</span><span class="o">.</span><span class="n">cb</span> <span class="o">=</span> <span class="kc">None</span>
    

<span class="n">_user_prop_push</span> <span class="o">=</span> <span class="n">Z3_push_eh</span><span class="p">(</span><span class="n">user_prop_push</span><span class="p">)</span>
<span class="n">_user_prop_pop</span> <span class="o">=</span> <span class="n">Z3_pop_eh</span><span class="p">(</span><span class="n">user_prop_pop</span><span class="p">)</span>
<span class="n">_user_prop_fresh</span> <span class="o">=</span> <span class="n">Z3_fresh_eh</span><span class="p">(</span><span class="n">user_prop_fresh</span><span class="p">)</span>
<span class="n">_user_prop_fixed</span> <span class="o">=</span> <span class="n">Z3_fixed_eh</span><span class="p">(</span><span class="n">user_prop_fixed</span><span class="p">)</span>
<span class="n">_user_prop_created</span> <span class="o">=</span> <span class="n">Z3_created_eh</span><span class="p">(</span><span class="n">user_prop_created</span><span class="p">)</span>
<span class="n">_user_prop_final</span> <span class="o">=</span> <span class="n">Z3_final_eh</span><span class="p">(</span><span class="n">user_prop_final</span><span class="p">)</span>
<span class="n">_user_prop_eq</span> <span class="o">=</span> <span class="n">Z3_eq_eh</span><span class="p">(</span><span class="n">user_prop_eq</span><span class="p">)</span>
<span class="n">_user_prop_diseq</span> <span class="o">=</span> <span class="n">Z3_eq_eh</span><span class="p">(</span><span class="n">user_prop_diseq</span><span class="p">)</span>
<span class="n">_user_prop_decide</span> <span class="o">=</span> <span class="n">Z3_decide_eh</span><span class="p">(</span><span class="n">user_prop_decide</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">PropagateFunction</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="o">*</span><span class="n">sig</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Create a function that gets tracked by user propagator.</span>
<span class="sd">       Every term headed by this function symbol is tracked.</span>
<span class="sd">       If a term is fixed and the fixed callback is registered a</span>
<span class="sd">       callback is invoked that the term headed by this function is fixed.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">sig</span> <span class="o">=</span> <span class="n">_get_args</span><span class="p">(</span><span class="n">sig</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">z3_debug</span><span class="p">():</span>
        <span class="n">_z3_assert</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sig</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;At least two arguments expected&quot;</span><span class="p">)</span>
    <span class="n">arity</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">sig</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="n">rng</span> <span class="o">=</span> <span class="n">sig</span><span class="p">[</span><span class="n">arity</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">z3_debug</span><span class="p">():</span>
        <span class="n">_z3_assert</span><span class="p">(</span><span class="n">is_sort</span><span class="p">(</span><span class="n">rng</span><span class="p">),</span> <span class="s2">&quot;Z3 sort expected&quot;</span><span class="p">)</span>
    <span class="n">dom</span> <span class="o">=</span> <span class="p">(</span><span class="n">Sort</span> <span class="o">*</span> <span class="n">arity</span><span class="p">)()</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">arity</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">z3_debug</span><span class="p">():</span>
            <span class="n">_z3_assert</span><span class="p">(</span><span class="n">is_sort</span><span class="p">(</span><span class="n">sig</span><span class="p">[</span><span class="n">i</span><span class="p">]),</span> <span class="s2">&quot;Z3 sort expected&quot;</span><span class="p">)</span>
        <span class="n">dom</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">sig</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">ast</span>
    <span class="n">ctx</span> <span class="o">=</span> <span class="n">rng</span><span class="o">.</span><span class="n">ctx</span>
    <span class="k">return</span> <span class="n">FuncDeclRef</span><span class="p">(</span><span class="n">Z3_solver_propagate_declare</span><span class="p">(</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="n">to_symbol</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">ctx</span><span class="p">),</span> <span class="n">arity</span><span class="p">,</span> <span class="n">dom</span><span class="p">,</span> <span class="n">rng</span><span class="o">.</span><span class="n">ast</span><span class="p">),</span> <span class="n">ctx</span><span class="p">)</span>

    

<span class="k">class</span> <span class="nc">UserPropagateBase</span><span class="p">:</span>

    <span class="c1">#</span>
    <span class="c1"># Either solver is set or ctx is set.</span>
    <span class="c1"># Propagators that are created throuh callbacks</span>
    <span class="c1"># to &quot;fresh&quot; inherit the context of that is supplied</span>
    <span class="c1"># as argument to the callback.</span>
    <span class="c1"># This context should not be deleted. It is owned by the solver.</span>
    <span class="c1">#</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">ctx</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">assert</span> <span class="n">s</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">ctx</span> <span class="ow">is</span> <span class="kc">None</span>
        <span class="n">ensure_prop_closures</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">solver</span> <span class="o">=</span> <span class="n">s</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ctx</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fresh_ctx</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cb</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">id</span> <span class="o">=</span> <span class="n">_prop_closures</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fixed</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">final</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">eq</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">diseq</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">created</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">ctx</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fresh_ctx</span> <span class="o">=</span> <span class="n">ctx</span>
        <span class="k">if</span> <span class="n">s</span><span class="p">:</span>
            <span class="n">Z3_solver_propagate_init</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx_ref</span><span class="p">(),</span>
                                     <span class="n">s</span><span class="o">.</span><span class="n">solver</span><span class="p">,</span>
                                     <span class="n">ctypes</span><span class="o">.</span><span class="n">c_void_p</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">id</span><span class="p">),</span>
                                     <span class="n">_user_prop_push</span><span class="p">,</span>
                                     <span class="n">_user_prop_pop</span><span class="p">,</span>
                                     <span class="n">_user_prop_fresh</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__del__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ctx</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ctx</span><span class="o">.</span><span class="n">ctx</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">ctx</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">fresh_ctx</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">fresh_ctx</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">solver</span><span class="o">.</span><span class="n">ctx</span>

    <span class="k">def</span> <span class="nf">ctx_ref</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">()</span><span class="o">.</span><span class="n">ref</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">add_fixed</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fixed</span><span class="p">):</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">fixed</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ctx</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">solver</span><span class="p">:</span>
            <span class="n">Z3_solver_propagate_fixed</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx_ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">solver</span><span class="o">.</span><span class="n">solver</span><span class="p">,</span> <span class="n">_user_prop_fixed</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fixed</span> <span class="o">=</span> <span class="n">fixed</span>

    <span class="k">def</span> <span class="nf">add_created</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">created</span><span class="p">):</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">created</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ctx</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">solver</span><span class="p">:</span>
            <span class="n">Z3_solver_propagate_created</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx_ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">solver</span><span class="o">.</span><span class="n">solver</span><span class="p">,</span> <span class="n">_user_prop_created</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">created</span> <span class="o">=</span> <span class="n">created</span>
        
    <span class="k">def</span> <span class="nf">add_final</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">final</span><span class="p">):</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">final</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ctx</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">solver</span><span class="p">:</span>
            <span class="n">Z3_solver_propagate_final</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx_ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">solver</span><span class="o">.</span><span class="n">solver</span><span class="p">,</span> <span class="n">_user_prop_final</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">final</span> <span class="o">=</span> <span class="n">final</span>

    <span class="k">def</span> <span class="nf">add_eq</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">eq</span><span class="p">):</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">eq</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ctx</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">solver</span><span class="p">:</span>
            <span class="n">Z3_solver_propagate_eq</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx_ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">solver</span><span class="o">.</span><span class="n">solver</span><span class="p">,</span> <span class="n">_user_prop_eq</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">eq</span> <span class="o">=</span> <span class="n">eq</span>

    <span class="k">def</span> <span class="nf">add_diseq</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">diseq</span><span class="p">):</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">diseq</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ctx</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">solver</span><span class="p">:</span>
            <span class="n">Z3_solver_propagate_diseq</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx_ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">solver</span><span class="o">.</span><span class="n">solver</span><span class="p">,</span> <span class="n">_user_prop_diseq</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">diseq</span> <span class="o">=</span> <span class="n">diseq</span>

    <span class="k">def</span> <span class="nf">add_decide</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">decide</span><span class="p">):</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">decide</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ctx</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">solver</span><span class="p">:</span>
            <span class="n">Z3_solver_propagate_decide</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx_ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">solver</span><span class="o">.</span><span class="n">solver</span><span class="p">,</span> <span class="n">_user_prop_decide</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">decide</span> <span class="o">=</span> <span class="n">decide</span>        

    <span class="k">def</span> <span class="nf">push</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">Z3Exception</span><span class="p">(</span><span class="s2">&quot;push needs to be overwritten&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">pop</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">num_scopes</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">Z3Exception</span><span class="p">(</span><span class="s2">&quot;pop needs to be overwritten&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">fresh</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_ctx</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">Z3Exception</span><span class="p">(</span><span class="s2">&quot;fresh needs to be overwritten&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">e</span><span class="p">):</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ctx</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">solver</span><span class="p">:</span>
            <span class="n">Z3_solver_propagate_register</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx_ref</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">solver</span><span class="o">.</span><span class="n">solver</span><span class="p">,</span> <span class="n">e</span><span class="o">.</span><span class="n">ast</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">Z3_solver_propagate_register_cb</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx_ref</span><span class="p">(),</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_void_p</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cb</span><span class="p">),</span> <span class="n">e</span><span class="o">.</span><span class="n">ast</span><span class="p">)</span>
        
    <span class="c1">#</span>
    <span class="c1"># Tell the solver to perform the next split on a given term</span>
    <span class="c1"># If the term is a bit-vector the index idx specifies the index of the Boolean variable being</span>
    <span class="c1"># split on. A phase of true = 1/false = -1/undef = 0 = let solver decide is the last argument.</span>
    <span class="c1">#</span>
    <span class="k">def</span> <span class="nf">next_split</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">phase</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Z3_solver_next_split</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx_ref</span><span class="p">(),</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_void_p</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cb</span><span class="p">),</span> <span class="n">t</span><span class="o">.</span><span class="n">ast</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">phase</span><span class="p">)</span>
        
    <span class="c1">#</span>
    <span class="c1"># Propagation can only be invoked as during a fixed or final callback.</span>
    <span class="c1">#</span>
    <span class="k">def</span> <span class="nf">propagate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">e</span><span class="p">,</span> <span class="n">ids</span><span class="p">,</span> <span class="n">eqs</span><span class="o">=</span><span class="p">[]):</span>
        <span class="n">_ids</span><span class="p">,</span> <span class="n">num_fixed</span> <span class="o">=</span> <span class="n">_to_ast_array</span><span class="p">(</span><span class="n">ids</span><span class="p">)</span>
        <span class="n">num_eqs</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">eqs</span><span class="p">)</span>
        <span class="n">_lhs</span><span class="p">,</span> <span class="n">_num_lhs</span> <span class="o">=</span> <span class="n">_to_ast_array</span><span class="p">([</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">eqs</span><span class="p">])</span>
        <span class="n">_rhs</span><span class="p">,</span> <span class="n">_num_rhs</span> <span class="o">=</span> <span class="n">_to_ast_array</span><span class="p">([</span><span class="n">y</span> <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">eqs</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">Z3_solver_propagate_consequence</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">ref</span><span class="p">(),</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_void_p</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cb</span><span class="p">),</span> <span class="n">num_fixed</span><span class="p">,</span> <span class="n">_ids</span><span class="p">,</span> <span class="n">num_eqs</span><span class="p">,</span> <span class="n">_lhs</span><span class="p">,</span> <span class="n">_rhs</span><span class="p">,</span> <span class="n">e</span><span class="o">.</span><span class="n">ast</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">conflict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">deps</span> <span class="o">=</span> <span class="p">[],</span> <span class="n">eqs</span> <span class="o">=</span> <span class="p">[]):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">propagate</span><span class="p">(</span><span class="n">BoolVal</span><span class="p">(</span><span class="kc">False</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="p">()),</span> <span class="n">deps</span><span class="p">,</span> <span class="n">eqs</span><span class="p">)</span>
</pre></div>

          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../index.html">model</a></h1>








<h3>Navigation</h3>
<p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../modules.html">model</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../index.html">Documentation overview</a><ul>
  <li><a href="../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2024, Pau Jimeno.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 5.0.2</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
    </div>

    

    
  </body>
</html>